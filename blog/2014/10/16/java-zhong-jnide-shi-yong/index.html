
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>Java 中JNI的使用 - Young_Blog</title>
	<meta name="author" content="LanderlYoung">

	
	<meta name="description" content="Java 中JNI的使用 最近来电项目打算加入变声的功能，所以决定实用SoundTouch（这个库是LGPL协议的，所以对SoundTouch的代码没有修改的话是不需要开源代码的！LOL~~）。SoundTouch是用C++写的，因此需要一个Java的JNI封装，以便JAVA层比较方便的调用。 &hellip;">
	

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="/atom.xml" rel="alternate" title="Young_Blog" type="application/atom+xml">
	
	<link rel="canonical" href="http://LanderlYoung.github.io/blog/2014/10/16/java-zhong-jnide-shi-yong/">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  
  <script src="/javascripts/libs/jquery.min.js"></script>

	
</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner"><div class="profilepic">	
	 
	<img src="/images/profile.png" width=160px />
</div>
<h1><a href="/">Young_Blog</a></h1>
<p class="subtitle">Life with Passion<br/>Code with Creativity</p>
<nav id="main-nav"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
	<li><a href="/about-me/">About Me</a></li>
</ul>
</nav>
<nav id="sub-nav">
	<div class="social">
		
		<a class="weibo" href="http://www.weibo.com/1863369094" title="Weibo">Weibo</a>
		
		
		
		<a class="google" href="https://plus.google.com/101237485378321820376/posts" rel="author" title="Google+">Google+</a>
		
		
		
		<a class="github" href="https://github.com/LanderlYoung" title="GitHub">GitHub</a>
		
		
		
		
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
	</div>
</nav>

</header>				
			</div>
		</div>	
		<div class="mid-col">
			
			
			
			<div class="mid-col-container">
				<div id="content" class="inner"><article class="post" itemscope itemtype="http://schema.org/BlogPosting">
	<h1 class="title" itemprop="name">Java 中JNI的使用</h1>
	<div class="entry-content" itemprop="articleBody"><p>最近来电项目打算加入变声的功能，所以决定实用SoundTouch（这个库是LGPL协议的，所以对SoundTouch的代码没有修改的话是不需要开源代码的！LOL~~）。SoundTouch是用C++写的，因此需要一个Java的JNI封装，以便JAVA层比较方便的调用。这次用JNI封装SoundTouch的经历，还是颇有收获的。记录一下，方便以后查看。</p>

<p>JNI全称是<code>Java Native Interface</code>是在JAVA和Native层（包括但不限于C/C++）相互调用的接口规范。</p>

<!--more-->


<p>JNI在JAVA1.1中正式推出，在JAVA1.2版本中加入了<code>JNI_OnLoad</code>，<code>JNI_OnUnload</code>方法，这两个方法还是很有用的，后面再说。</p>

<h3>JNI基础篇</h3>

<p>Java通过JNI调用本地方法的过程大致是</p>

<ol>
<li>写一个Java类，在其中声明对应要调用的native方法，用<code>native</code>关键字修饰。 比如<code>private static native int native_newInstance();</code></li>
<li>通过<code>javah</code>命令生成java类对应的C/C++头文件。<code>javah -encoding utf-8 -cp src com.tencent.soundtouch.SoundTouch</code></li>
<li>在C/C++中实现头文件中声明的函数</li>
<li>编译C/C++代码为动态库（Windows中的dll，linux(Android)中的so，MAC OSX中的dylib）。</li>
<li>在java代码中加载动态库，即可像调用Java方法一样，调用到native函数。</li>
</ol>


<p>其中第三步在Java1.2中增加了<code>JNI_OnLoad</code>方法之后有另一种实现方式（<a href="#jni_onload">后面</a>说）。</p>

<p>javah生成的头文件大致是这样的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="cm">/* DO NOT EDIT THIS FILE - it is machine generated */</span>
</span><span class='line'><span class="err">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">jni</span><span class="o">.</span><span class="na">h</span><span class="o">&gt;</span>
</span><span class='line'><span class="cm">/* Header for class com_tencent_soundtouch_SoundTouch */</span>
</span><span class='line'>
</span><span class='line'><span class="err">#</span><span class="n">ifndef</span> <span class="n">_Included_com_tencent_soundtouch_SoundTouch</span>
</span><span class='line'><span class="err">#</span><span class="n">define</span> <span class="n">_Included_com_tencent_soundtouch_SoundTouch</span>
</span><span class='line'><span class="err">#</span><span class="n">ifdef</span> <span class="n">__cplusplus</span>
</span><span class='line'><span class="n">extern</span> <span class="s">&quot;C&quot;</span> <span class="o">{</span>
</span><span class='line'><span class="err">#</span><span class="n">endif</span>
</span><span class='line'><span class="err">#</span><span class="n">undef</span> <span class="n">com_tencent_soundtouch_SoundTouch_SETTING_USE_AA_FILTER</span>
</span><span class='line'><span class="err">#</span><span class="n">define</span> <span class="n">com_tencent_soundtouch_SoundTouch_SETTING_USE_AA_FILTER</span> <span class="mi">0L</span>
</span><span class='line'>  <span class="cm">/*</span>
</span><span class='line'><span class="cm"> * Class:     com_tencent_soundtouch_SoundTouch</span>
</span><span class='line'><span class="cm"> * Method:    native_getDefaultSampleElementSize</span>
</span><span class='line'><span class="cm"> * Signature: ()I</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'>  <span class="n">JNIEXPORT</span> <span class="n">jint</span> <span class="n">JNICALL</span> <span class="nf">Java_com_tencent_soundtouch_SoundTouch_native_1getDefaultSampleElementSize</span>
</span><span class='line'>      <span class="o">(</span><span class="n">JNIEnv</span> <span class="o">*,</span> <span class="n">jclass</span><span class="o">);</span>
</span><span class='line'><span class="err">#</span><span class="n">ifdef</span> <span class="n">__cplusplus</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="err">#</span><span class="n">endif</span>
</span><span class='line'><span class="err">#</span><span class="n">endif</span>
</span></code></pre></td></tr></table></div></figure>


<p>文件开头就是普通的头文件，但是可以发现：</p>

<ol>
<li><p>包含了jni.h头文件（一般位于<code>$JAVA_HOME/jd{jdk-version}/include</code>文目录内）。这是JNI中所有的<a href="#jni_type">类型</a>、函数、宏等定义的地方。所以C/C++世界的JNI是由他制定的游戏规则。</p></li>
<li><p>在类中生命的常量（<code>static final</code>）类型会在头文件中以宏的形式出现，这一点还是很方便的。</p></li>
<li><p>函数的注释还是比较全的，包括了：</p>

<ol>
<li>对应的class</li>
<li>对应的java方法名</li>
<li>对应java方法的<a href="#signature">签名</a></li>
</ol>
</li>
<li>方法的声明显得有点奇怪，由以下及部分组成：

<ol>
<li><code>JNIEXPORT</code>这是函数的导出方式</li>
<li>jint 返回值类型（jint由jni.h定义，对应int，<a href="#jni_type">下面</a>具体再说吧</li>
<li>JNICALL 函数的调用方式也就是汇编级别参数的传入方式</li>
<li> Java_com_tencent_soundtouch_SoundTouch_native_1getDefaultSampleElementSize —— 超级长的函数名！！！格式是<code>Java_</code> + <code>类全名</code> + <code>_</code> + JAVA中声明的native方法名。其中会把包名中的点（<code>.</code>）替换成下划线（<code>_</code>），同时为了避免冲突把下划线替换成<code>_1</code>。</li>
<li>方法的参数，上面的这个方法在JAVA的声明中实际上是没有参数的，其中的<code>JNIENV</code>顾名思义是JNI环境，和具体的线程绑定。而第二个参数<code>jclass</code>其实是java中的<code>Class</code>因为上面是一个<code>static</code>方法，因此第二个参数是<code>jclass</code>。如果是一个实例方法则对应第二个参数是<code>jobject</code>，相当于java中的<code>this</code>。</li>
</ol>
</li>
</ol>


<p>下面在C/C++中实现这个方法就行啦。但是在动手前现大致了解以下jni.h制定的游戏规则。</p>

<h4><a name="jni_type">类型转换</a>：</h4>

<p>javah生成的头文件里面使用的类型都是jni.h定义的，目的是做到<strong>平台无关</strong>，比如保证在所有平台上jint都是32位的有符号整型。</p>

<p><strong>基本对应关系如下：</strong></p>

<table>
<thead>
<tr>
<th style="text-align:center;">  jni 类型 </th>
<th style="text-align:center;"> JAVA类型 </th>
<th style="text-align:center;"> 对应本地类型  </th>
<th style="text-align:center;">  类型<a href="#signature">签名</a> </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;">  jboolean </td>
<td style="text-align:center;"> boolean </td>
<td style="text-align:center;"> uint8_t </td>
<td style="text-align:center;"> Z</td>
</tr>
<tr>
<td style="text-align:center;">  jbyte </td>
<td style="text-align:center;"> byte </td>
<td style="text-align:center;"> char </td>
<td style="text-align:center;"> B </td>
</tr>
<tr>
<td style="text-align:center;">  jcahr </td>
<td style="text-align:center;"> char </td>
<td style="text-align:center;"> uint16_t </td>
<td style="text-align:center;"> C </td>
</tr>
<tr>
<td style="text-align:center;">  jshort </td>
<td style="text-align:center;"> short </td>
<td style="text-align:center;"> int16_t </td>
<td style="text-align:center;"> S </td>
</tr>
<tr>
<td style="text-align:center;">  jint </td>
<td style="text-align:center;"> int </td>
<td style="text-align:center;"> int32_t </td>
<td style="text-align:center;"> I </td>
</tr>
<tr>
<td style="text-align:center;">  jlong </td>
<td style="text-align:center;"> long </td>
<td style="text-align:center;"> int64_t </td>
<td style="text-align:center;"> J </td>
</tr>
<tr>
<td style="text-align:center;">  jfloat </td>
<td style="text-align:center;"> float </td>
<td style="text-align:center;"> float </td>
<td style="text-align:center;"> F </td>
</tr>
<tr>
<td style="text-align:center;">  jdouble </td>
<td style="text-align:center;"> double </td>
<td style="text-align:center;"> double </td>
<td style="text-align:center;"> D </td>
</tr>
<tr>
<td style="text-align:center;">  void </td>
<td style="text-align:center;"> void </td>
<td style="text-align:center;"> void </td>
<td style="text-align:center;"> V </td>
</tr>
</tbody>
</table>


<p><strong>引用类型对应关系：</strong></p>

<table>
<thead>
<tr>
<th style="text-align:center;"> java类型 </th>
<th style="text-align:center;">  JNI 类型 </th>
<th style="text-align:center;"> java类型 </th>
<th style="text-align:center;">  JNI 类型 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> 所有的实例引用 </td>
<td style="text-align:center;"> jobject </td>
<td style="text-align:center;">java.lang.Class </td>
<td style="text-align:center;">  jclass </td>
</tr>
<tr>
<td style="text-align:center;"> java.lang.String </td>
<td style="text-align:center;"> jstring </td>
<td style="text-align:center;"> Ocject[] </td>
<td style="text-align:center;"> jobjectArray </td>
</tr>
<tr>
<td style="text-align:center;"> java.lang.Throwable </td>
<td style="text-align:center;"> jthrowable </td>
<td style="text-align:center;"> 基本类型[] </td>
<td style="text-align:center;"> jxxxArray </td>
</tr>
</tbody>
</table>


<p>通过表格发现，除了上面定义的<code>String</code>，<code>Class</code>，<code>Throwable</code>，其他的类（除了数组）都是以<code>jobject</code>的形式出现的！事实上jstring， jclass也都是object的子类。所以这里还是和java层一样，一切皆jobject。（当然，如果jni在C语言中编译的话是没有继承的概念的，此时jstring，jclass等其实就是jobject！用了typedef转换而已！！）</p>

<p>接下来是<code>JNIEnv *</code>这个指针，他提供了JNI中的一系列操作的接口函数。</p>

<h4>JNI中操作jobject</h4>

<p>其实也就是在native层操作java层的实例。
要操作一个实例无疑是：</p>

<ol>
<li><p>获取/设置 （即 get/set ）成员变量（field）的值</p></li>
<li><p>调用成员方法（method）</p></li>
</ol>


<p>所以问题来了：（挖掘机技术哪家强？！ o(*≧▽≦)ツ┏━┓ ）</p>

<p><strong>怎么得到field 和 method？</strong></p>

<p>通过使用<strong>jfieldID和jmethodID</strong>：
在JNI中使用类似于放射的方式来进行field和method的操作。JNI中使用jfieldID和jmethodID来表示成员变量和成员方法，获取方式是：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">jfieldID</span> <span class="nf">GetFieldID</span><span class="o">(</span><span class="n">jclass</span> <span class="n">clazz</span><span class="o">,</span> <span class="kd">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="o">,</span> <span class="kd">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sig</span><span class="o">);</span>
</span><span class='line'><span class="n">jfieldID</span> <span class="nf">GetStaticFieldID</span><span class="o">(</span><span class="n">jclass</span> <span class="n">clazz</span><span class="o">,</span> <span class="kd">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="o">,</span> <span class="kd">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sig</span><span class="o">);</span>
</span><span class='line'><span class="n">jmethodID</span> <span class="nf">GetMethodID</span><span class="o">(</span><span class="n">jclass</span> <span class="n">clazz</span><span class="o">,</span> <span class="kd">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="o">,</span> <span class="kd">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sig</span><span class="o">);</span>
</span><span class='line'><span class="n">jmethodID</span> <span class="nf">GetStaticMethodID</span><span class="o">(</span><span class="n">jclass</span> <span class="n">clazz</span><span class="o">,</span> <span class="kd">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="o">,</span> <span class="kd">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sig</span><span class="o">)</span> <span class="o">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中最后一个参数是<a href="#signature">签名</a>。
<strong>获取jclass的方法</strong>除了实用上面静态方法的第二个参数外，还可以手动获取。
<code>jclass FindClass(const char *name)</code>
需要注意的是<code>name</code>参数，他是一个类包括包名的全称，但是需要把包名中的点<code>.</code>替换成斜杠<code>/</code>。（好吧，事实上我不是太明白为啥要这么做。）</p>

<p>有了jfieldID和jmethodID就知道狗蛋住哪了，现在去狗蛋家找他玩 ♪(^∇^*)</p>

<p><strong>成员变量:</strong></p>

<ol>
<li><p>get:</p>

<ol>
<li><p><code>&lt;type&gt; Get&lt;type&gt;Field(jobject , jfieldID);</code>即可获得对应的field，其中field的类型是type，可以是上面<a href="#jni_type">类型</a>所叙述的任何一种。</p></li>
<li><p><code>&lt;type&gt; GetStatic&lt;type&gt;Field(jobject , jfieldID);</code>同1，唯一的区别是用来获取静态成员。</p></li>
</ol>
</li>
<li><p>set:</p>

<ol>
<li><p><code>void Set&lt;type&gt;Field(jobject obj, jfieldID fieldID, &lt;type&gt; val)</code></p></li>
<li><p><code>void SetStatic&lt;type&gt;Field(jclass clazz, jfieldID fieldID, &lt;type&gt; value);</code></p></li>
</ol>
</li>
</ol>


<p><strong>成员方法：</strong></p>

<p>调用方法自然要把方法的参数传递进去，JNI中实现了三种参数的传递方式：</p>

<ol>
<li><p><code>Call&lt;type&gt;Method(jobject obj, jmethod jmethodID, ...)</code>其中<code>...</code>是C中的可变长参数，类似于<code>printf</code>那样，可以传递不定长个参数。于是你可以把java方法需要的参数在这里面传递进去。</p></li>
<li><p><code>Call&lt;type&gt;MethodV(jobject obj, jmethodID methodID, va_list args)</code>其中的<code>va_list</code>也是C中可变长参数相关的内容（我不了解，不敢瞎说。。。偷懒粘一下Oracle的文档）Programmers place all arguments to the method in an args argument of type va_list that immediately follows the methodID argument. The Call<type>MethodV routine accepts the arguments, and, in turn, passes them to the Java method that the programmer wishes to invoke.</p></li>
<li><p><code>Call&lt;type&gt;MethodA(jobject obj, jmethodID methodID, const jvalue * args)</code>哎！这个我知道可以说两句LOL~~这里的<code>jvalue</code>通过查代码发现就是JNI中各个数据类型的union，所以可以使用任何类型复制！所以参数的传入方式是通过一个jvalue的数组，数组内的元素可以是任何jni类型。</p></li>
</ol>


<p>然后问题又来了：（挖掘机技术到底哪家强？！o(*≧▽≦)ツ┏━┓）
如果传进来的参数和java声明的参数的不一致会怎么样！（即不符合<a href="#signature">方法签名</a>）这里文档中没用明确解释，但是说道:</p>

<blockquote><p>Exceptions raised during the execution of the Java method.</p></blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">typedef</span> <span class="n">union</span> <span class="n">jvalue</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">jboolean</span> <span class="n">z</span><span class="o">;</span>
</span><span class='line'>    <span class="n">jbyte</span>    <span class="n">b</span><span class="o">;</span>
</span><span class='line'>    <span class="n">jchar</span>    <span class="n">c</span><span class="o">;</span>
</span><span class='line'>    <span class="n">jshort</span>   <span class="n">s</span><span class="o">;</span>
</span><span class='line'>    <span class="n">jint</span>     <span class="n">i</span><span class="o">;</span>
</span><span class='line'>    <span class="n">jlong</span>    <span class="n">j</span><span class="o">;</span>
</span><span class='line'>    <span class="n">jfloat</span>   <span class="n">f</span><span class="o">;</span>
</span><span class='line'>    <span class="n">jdouble</span>  <span class="n">d</span><span class="o">;</span>
</span><span class='line'>    <span class="n">jobject</span>  <span class="n">l</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span> <span class="n">jvalue</span><span class="o">;</span>
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>调用实例方法（instance method）：

<ol>
<li> <code>&lt;type&gt; Call&lt;type&gt;Method(jobject obj, jmethodID methodID, ...);</code>调用一个具有<code>&lt;type&gt;</code>类型返回值的方法。</li>
<li><code>&lt;type&gt; Call&lt;type&gt;MethodV(jobject obj, jmethodID methodID, va_list args);</code></li>
<li><code>Call&lt;type&gt;MethodA(jobject obj, jmethodID methodID, const jvalue * args)</code></li>
</ol>
</li>
<li>调用静态方法（static method）：

<ol>
<li><code>&lt;type&gt; CallStatic&lt;type&gt;Method(jobject obj, jmethodID methodID, ...);</code></li>
<li><code>&lt;type&gt; CallStatic&lt;type&gt;MethodV(jobject obj, jmethodID methodID, va_list args);</code></li>
<li><code>CallStatic&lt;type&gt;MethodA(jobject obj, jmethodID methodID, const jvalue * args)</code></li>
</ol>
</li>
<li>调用父类方法（super.method)，这个就有点不一样了。多了一个jclass参数，jclass可以使obj的父类，也可以是obj自己的class，但是methodID必须是从jclass获取到的，这样就可以调用到父类的方法。

<ol>
<li><code>&lt;type&gt; CallNonvirtual&lt;type&gt;Method(jobject obj, jclass clazz, jmethodID methodID, ...)</code></li>
<li><code>&lt;type&gt; CallNonvirtual&lt;type&gt;MethodV(JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, va_list args);</code></li>
<li> <code>&lt;type&gt; CallNonvirtual&lt;type&gt;MethodA(JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, const jvalue *args);</code></li>
</ol>
</li>
</ol>


<h4>数组的操作</h4>

<p>数组是一个很常用的数据类型，在但是在JNI中并不能直接操作jni数组（比如jshortArray，jfloatArray）。使用方法是：</p>

<ol>
<li>获取数组长度：<code>jsize GetArrayLength(jarray array)</code></li>
<li>创建新数组： <code>ArrayType New&lt;PrimitiveType&gt;Array(jsize length);</code></li>
<li>通过JNI数组获取一个C/C++数组：<code>&lt;type&gt;* Get&lt;type&gt;ArrayElements(jshortArray array, jboolean *isCopy)</code></li>
<li>指定原数组的范围获取一个C/C++数组（该方法只针对于原始数据数组，不包括Object数组）：<code>void Get&lt;PrimitiveType&gt;ArrayRegion(JNIEnv *env, ArrayType array, jsize start, jsize len, NativeType *buf);</code></li>
<li>设置数组元素：<code>void Set&lt;type&gt;ArrayRegion(jshortArray array, jsize start, jsize len,const &lt;type&gt; *buf)</code>。again，如果是Object数组需要使用：<code>void SetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index, jobject value);</code></li>
<li> 使用完之后，释放数组：<code>void Release&lt;type&gt;ArrayElements(jshortArray array, jshort *elems, jint mode)</code></li>
</ol>


<p>有点要说明的：</p>

<ol>
<li><p>上面的3中的isCopy：当你调用getArrayElements时JVM（Runtime）可以直接返回数组的原始指针，或者是copy一份，返回给你，这是由JVM决定的。所以isCopy就是用来记录这个的。他的值是<code>JNI_TURE</code>或者<code>JNI_FALSE</code>。</p></li>
<li><p>6释放数组。<strong>一定要释放你所获得数组</strong>。其中有一个<code>mode</code>参数，其有三个可选值，分别表示：</p></li>
<li><p> 0</p>

<ul>
<li><p>原始数组：允许原数组被垃圾回收。</p></li>
<li><p>copy： 数据会从get返回的buffer copy回去，同时buffer也会被释放。</p></li>
</ul>
</li>
<li><p> JNI_COMMIT</p>

<ul>
<li><p>原始数组：什么也不做</p></li>
<li><p>copy： 数据会从get返回的buffer copy回去，同时buffer<strong>不会</strong>被释放。</p></li>
</ul>
</li>
<li><p> JNI_ABORT</p>

<ul>
<li><p>原始数组：允许原数组被垃圾回收。之前由JNI_COMMIT提交的对数组的修改将得以保留。</p></li>
<li><p>copy： buffer会被释放，同时buffer中的修改将不会copy回数组！</p></li>
</ul>
</li>
</ol>


<h4>关于引用与垃圾回收</h4>

<p>比如上面有个方法传了一个jobject进来，然后我把她保存下来，方便以后使用。这样做是<strong>不行哒</strong>！因为他是一个LocalReference，所以不能保证jobject指向的真正的实例不被回收。也就是说有可能你用的时候那个指针已经是个野指针的。然后你的程序就直接Segment Fault了，呵呵。。。</p>

<p>在JNI中提供了三种类型的引用：</p>

<ol>
<li>Local Reference：即本地引用。在JNI层的函数，所有非全局引用对象都是Local Reference， 它包括函数调用是传入的jobject和JNI成函数创建的jobject。Local Reference的特点是一旦JNI层的函数返回，这些jobject就可能被垃圾回收。</li>
<li>Glocal Reference：全局引用，这些对象不会主动释放，永远不会被垃圾回收。</li>
<li>Weak Glocal Reference：弱全局引用，一种特殊的Global Reference，在运行过程中有可能被垃圾回收。所以使用之前需要使用<code>jboolean IsSameObject(jobject obj1, jobject obj2)</code>判断它是否已被回收。</li>
</ol>


<p>Glocal Reference:<br/>
 1. 创建：<code>jobject NewGlobalRef(jobject lobj);</code><br/>
 2. 释放：<code>void DeleteGlobalRef(jobject gref);</code></p>

<p>Local Reference:<br/>
LocalReference也有一个释放的函数：<code>void DeleteLocalRef(jobject obj)</code>，他会立即释放Local Reference。
这个方法可能略显多余，其实也是有它的用处的。刚才说Local Reference会再函数返回后释放掉，但是假如函数返回前就有很多引用占了很多内存，最好函数内就尽早释放不必要的内存。</p>

<h4>关于JNI_OnLoad<a name="jni_onload"></a></h4>

<p>开头提到JNI_OnLoad是java1.2中新增加的方法，对应的还有一个JNI_OnUnload，分别是动态库被JVM加载、卸载的时候调用的函数。有点类似于WIndows里的DllMain。<br/>
前面提到的实现对应native的方法是实现javah生成的头文件中定义的方法，这样有几个弊端：</p>

<ol>
<li>函数名太长。很长。。相当长。。。</li>
<li>函数会被导出，也就谁说可以在动态库的导出函数表里面找到这些函数。这将有利于别人对动态库的逆向工程，因此带来安全问题。</li>
</ol>


<p>现在有了JNI_OnLoad，情况好多了。你不光能在其中完成动态注册native函数的工作还可以完成一些初始化工作。java对应的有了<code>jint RegisterNatives(jclass clazz, const JNINativeMethod *methods,jint nMethods)</code>函数。参数分别是：</p>

<ol>
<li><p>jclass clazz，于native层对应的java class</p></li>
<li><p>const JNINativeMethod *methods这是一个数组，数组的元素是JNI定义的一个结构体JNINativeMethod</p></li>
<li><p>上面的数组的长度</p></li>
</ol>


<p><strong>JNINativeMethod</strong>：代码中的定义如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="cm">/*</span>
</span><span class='line'><span class="cm"> * used in RegisterNatives to describe native method name, signature,</span>
</span><span class='line'><span class="cm"> * and function pointer.</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'>
</span><span class='line'><span class="n">typedef</span> <span class="n">struct</span> <span class="o">{</span>
</span><span class='line'>    <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="o">;</span>
</span><span class='line'>    <span class="kt">char</span> <span class="o">*</span><span class="n">signature</span><span class="o">;</span>
</span><span class='line'>    <span class="kt">void</span> <span class="o">*</span><span class="n">fnPtr</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span> <span class="n">JNINativeMethod</span><span class="o">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>所以他有三个字段，分别是</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 字段 </th>
<th style="text-align:left;"> 含义 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">char *name </td>
<td style="text-align:left;"> java class中的native方法名，只需要方法名即可 </td>
</tr>
<tr>
<td style="text-align:left;"> char *signature </td>
<td style="text-align:left;"> 方法<a href="#signature">签名</a></td>
</tr>
<tr>
<td style="text-align:left;"> void *fnPtr </td>
<td style="text-align:left;"> 对应native方法的函数指针 </td>
</tr>
</tbody>
</table>


<p>于是现在你可以不用导出native函数了，而且可以随意给函数命名，唯一要保证的是参数及返回值的统一。然后需要一个<code>const JNINativeMethod *methods</code>数组来完成映射工作。</p>

<p>看起来大概是这样的:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">//只需导出JNI_OnLoad和JNI_OnUnload（这个函数不实现也行）</span>
</span><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * These are the exported function in this library.</span>
</span><span class='line'><span class="cm">*/</span>
</span><span class='line'><span class="n">JNIEXPORT</span> <span class="n">jint</span> <span class="n">JNICALL</span> <span class="n">JNI_OnLoad</span><span class="p">(</span><span class="n">JavaVM</span> <span class="o">*</span><span class="n">vm</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">reserved</span><span class="p">);</span>
</span><span class='line'><span class="n">JNIEXPORT</span> <span class="kt">void</span> <span class="n">JNICALL</span> <span class="n">JNI_OnUnload</span><span class="p">(</span><span class="n">JavaVM</span> <span class="o">*</span><span class="n">vm</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">reserved</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//为了在动态库中不用导出函数，全部声明为static</span>
</span><span class='line'><span class="c1">//native methods registered by JNI_OnLoad</span>
</span><span class='line'><span class="k">static</span> <span class="n">jint</span> <span class="n">native_newInstance</span> <span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jclass</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//实现native方法</span>
</span><span class='line'><span class="cm">/*</span>
</span><span class='line'><span class="cm">* Class:     com_tencent_soundtouch_SoundTouch</span>
</span><span class='line'><span class="cm">* Method:    native_newInstance</span>
</span><span class='line'><span class="cm">* Signature: ()I</span>
</span><span class='line'><span class="cm">*/</span>
</span><span class='line'><span class="k">static</span> <span class="n">jint</span> <span class="n">native_newInstance</span>
</span><span class='line'><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jclass</span> <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">instanceID</span> <span class="o">=</span> <span class="o">++</span><span class="n">sInstanceIdentifer</span><span class="p">;</span>
</span><span class='line'>  <span class="n">SoundTouchWrapper</span> <span class="o">*</span><span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SoundTouchWrapper</span><span class="p">();</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">instance</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">sInstancePool</span><span class="p">[</span><span class="n">instanceID</span><span class="p">]</span> <span class="o">=</span> <span class="n">instance</span><span class="p">;</span>
</span><span class='line'>      <span class="o">++</span><span class="n">sInstanceCount</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">LOGDBG</span><span class="p">(</span><span class="s">&quot;create new SouncTouch instance:%d&quot;</span><span class="p">,</span> <span class="n">instanceID</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">instanceID</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//构造JNINativeMethod数组</span>
</span><span class='line'><span class="k">static</span> <span class="n">JNINativeMethod</span> <span class="n">gsNativeMethods</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>      <span class="p">{</span>
</span><span class='line'>          <span class="s">&quot;native_newInstance&quot;</span><span class="p">,</span>
</span><span class='line'>          <span class="s">&quot;()I&quot;</span><span class="p">,</span>
</span><span class='line'>          <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">void</span> <span class="o">*&gt;</span> <span class="p">(</span><span class="n">native_newInstance</span><span class="p">)</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'><span class="p">}</span><span class="err">；</span>
</span><span class='line'><span class="c1">//计算数组大小</span>
</span><span class='line'><span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">gsMethodCount</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">gsNativeMethods</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">JNINativeMethod</span><span class="p">)</span><span class="err">；</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//JNI_OnLoad，注册native方法。</span>
</span><span class='line'><span class="n">JNIEXPORT</span> <span class="n">jint</span> <span class="n">JNICALL</span> <span class="n">JNI_OnLoad</span><span class="p">(</span><span class="n">JavaVM</span> <span class="o">*</span><span class="n">vm</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">reserved</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">JNIEnv</span><span class="o">*</span> <span class="n">env</span><span class="p">;</span>
</span><span class='line'>  <span class="n">jclass</span> <span class="n">clazz</span><span class="p">;</span>
</span><span class='line'>  <span class="n">LOGD</span><span class="p">(</span><span class="s">&quot;JNI_OnLoad called&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">vm</span><span class="o">-&gt;</span><span class="n">GetEnv</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">**&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">env</span><span class="p">),</span> <span class="n">JNI_VERSION_1_6</span><span class="p">)</span> <span class="o">!=</span> <span class="n">JNI_OK</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="c1">//FULL_CLASS_NAME是个宏定义，定义了对应java类的全名（要把包名中的点(.)_替换成斜杠(/)）</span>
</span><span class='line'>  <span class="n">clazz</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">FindClass</span><span class="p">(</span><span class="n">FULL_CLASS_NAME</span><span class="p">);</span>
</span><span class='line'>  <span class="n">LOGDBG</span><span class="p">(</span><span class="s">&quot;register method, method count:%d&quot;</span><span class="p">,</span> <span class="n">gsMethodCount</span><span class="p">);</span>
</span><span class='line'>  <span class="c1">//注册JNI函数</span>
</span><span class='line'>  <span class="n">env</span><span class="o">-&gt;</span><span class="n">RegisterNatives</span><span class="p">(</span><span class="n">clazz</span><span class="p">,</span> <span class="n">gsNativeMethods</span><span class="p">,</span>
</span><span class='line'>      <span class="n">gsMethodCount</span><span class="p">);</span>
</span><span class='line'>  <span class="c1">//必须返回一个JNI_VERSION_1_1以上（不含）的版本号，否则直接加载失败</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">JNI_VERSION_1_6</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>实战技巧篇</h3>

<p>这里主要是巧用C中的宏来减少重复工作：</p>

<h4>迅速生成全名</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">//修改包名时只需要改以下的宏定义即可</span>
</span><span class='line'><span class="cp">#define FULL_CLASS_NAME &quot;com/tencent/soundtouch/SoundTouch&quot;</span>
</span><span class='line'><span class="cp">#define func(name) Java_ ## com_tencent_soundtouch_SoundTouch_ ## name</span>
</span><span class='line'><span class="cp">#define constance(cons) com_tencent_soundtouch_SoundTouch_ ## cons</span>
</span></code></pre></td></tr></table></div></figure>


<p>比如<code>func(native_1newInstance)</code>展开成：<code>Java_com_tencent_soundtouch_SoundTouch_native_1newInstance</code>即JNI中需要导出的函数名（不过用动态注册方式没太大用了）</p>

<p><code>constance(AUDIO_FORMAT_PCM16)</code>展开成<code>com_tencent_soundtouch_SoundTouch_AUDIO_FORMAT_PCM16</code>这个着实有用。</p>

<p>而且如果包名改了也可以很方便的适应之。</p>

<h3>安卓的log</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">//define __USE_ANDROID_LOG__ in makefile to enable android log</span>
</span><span class='line'><span class="cp">#if defined(__ANDROID__) &amp;&amp; defined(__USE_ANDROID_LOG__)</span>
</span><span class='line'><span class="cp">#include &lt;android/log.h&gt;</span>
</span><span class='line'><span class="cp">#define LOGV(...)   __android_log_print((int)ANDROID_LOG_VERBOSE, &quot;ST_jni&quot;, __VA_ARGS__)</span>
</span><span class='line'><span class="cp">#define LOGD(msg)  __android_log_print((int)ANDROID_LOG_DEBUG, &quot;ST_jni_dbg&quot;, &quot;line:%3d %s&quot;, __LINE__, msg)</span>
</span><span class='line'><span class="cp">#define LOGDBG(fmt, ...) __android_log_print((int)ANDROID_LOG_DEBUG, &quot;ST_jni_dbg&quot;, &quot;line:%3d &quot; fmt, __LINE__, __VA_ARGS__)</span>
</span><span class='line'><span class="cp">#else</span>
</span><span class='line'><span class="cp">#define LOGV(...) </span>
</span><span class='line'><span class="cp">#define LOGD(fmt) </span>
</span><span class='line'><span class="cp">#define LOGDBG(fmt, ...) </span>
</span><span class='line'><span class="cp">#endif</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过这样的宏定义在打LOGD或者LOGDBG的时候还能自动加上行号！调试起来爽多了！</p>

<h4>C++中清理内存的方式</h4>

<p>由于C++里面需要手动清楚内存，因此我的解决方案是定义一个map，给每个实例一个id，用id把java中的对象和native中的对象绑定起来。在java层定义一个<code>release</code>方法，用来释放本地的对象。
本地的 KEY-对象 映射
<code>static std::map&lt;int, SoundTouchWrapper*&gt; sInstancePool;</code></p>

<h4>关于NDK</h4>

<p>因为安卓的约定是把本地代码放到jni目录下面，但是假如有多个jni lib的时候会比较混乱，所以方案是每一个lib都在jni里面建一个子目录，然后jni里面的Android.mk就可以去构建子目录中的lib了。</p>

<p>jni/Android.mk如下（超级简单）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='makefile'><span class='line'><span class="nv">LOCAL_PATH</span> <span class="o">:=</span> <span class="k">$(</span>call my-dir<span class="k">)</span>
</span><span class='line'><span class="cp">include $(call all-subdir-makefiles)</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后在子目录soundtouch_module中的Android.mk就可以像一般的Android.mk一样书写规则了。</p>

<p>同时记录一下在Andoroid.mk中使用makefile内建函数<code>wildcard</code>的方法。
有时候源文件是一个目录下的所有.cpp/.c文件，这时候<code>wildcard</code>来统配会很方便。但是Android.mk与普通的Makefile的不同在于：</p>

<ol>
<li>调用Android.mkmingling的${CWD}并不是Android.ml所在的目录。所以Android.mk中有一个变量<code>LOCAL_PATH := $(call my-dir)</code>来记录当前 Android.mk所在的目录。</li>
<li>同时还会把所有的<code>LOCAL_SRC_FILES</code> 前面加上<code>$(LOCAL_PATH)</code>这样写makefile的时候就可以用相对路径了，提供了方便。但是这也导致了坑！</li>
</ol>


<p>因为1，直接使用相对路径会导致<code>wildcard</code>匹配不到源文件。所以最好这么写<code>FILE_LIST := $(wildcard $(LOCAL_PATH)/soundtouch_source/source/SoundTouch/*.cpp)</code>。然而又因为2，这样还是不行的。所以还需要匹配之后把<code>$(LOCAL_PATH)</code>的部分去掉，因此还得这样<code>$(FILE_LIST:$(LOCAL_PATH)/%=%)</code>.</p>

<p>还有个小tip：<code>LOCAL_CFLAGS</code>中最好加上这个定义<code>-fvisibility=hidden</code>这样就不会在动态库中导出不必要的函数了。</p>

<h3>附录<a name="signature">签名</a></h3>

<p>JAVA中的函数签名包括了函数的参数类型，返回值类型。因此即使是重载了的函数，其函数签名也不一样。java编译器就会根据函数签名来判断你调用的到地址哪个方法。
签名中表示类型是这样的</p>

<p>1.基本类型都对应一个大写字母，如下：</p>

<table>
<thead>
<tr>
<th style="text-align:center;"> JAVA类型 </th>
<th style="text-align:center;">  类型签名 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> boolean </td>
<td style="text-align:center;"> Z </td>
</tr>
<tr>
<td style="text-align:center;">byte </td>
<td style="text-align:center;"> B </td>
</tr>
<tr>
<td style="text-align:center;"> char  </td>
<td style="text-align:center;"> C </td>
</tr>
<tr>
<td style="text-align:center;"> short </td>
<td style="text-align:center;"> S </td>
</tr>
<tr>
<td style="text-align:center;"> int </td>
<td style="text-align:center;"> I </td>
</tr>
<tr>
<td style="text-align:center;"> long </td>
<td style="text-align:center;"> J </td>
</tr>
<tr>
<td style="text-align:center;"> float </td>
<td style="text-align:center;"> F </td>
</tr>
<tr>
<td style="text-align:center;"> double </td>
<td style="text-align:center;"> D </td>
</tr>
<tr>
<td style="text-align:center;"> void </td>
<td style="text-align:center;"> V </td>
</tr>
</tbody>
</table>


<p>2.如果是类则是：
L + 类全名（报名中的点(.)用(/)代替）+ ；
比如java.lang.String 对应的是 <code>Ljava/lang/String;</code></p>

<p>3.如果是数组，则在前面加<code>[</code>然后加类型签名，几位数组就加几个<code>[</code>
比如int[]对应<code>[I</code>，boolean[][] 对应 <code>[[Z</code>，java.lang.Class[]对应<code>[Ljava/lang/Class;</code></p>

<p>可以通过javap命令来获取签名（javah生成的头文件注释中也有签名）:<code>javap -x -p &lt;类全名&gt;</code>
坑爹的是java中并不能通过反射来获取方法签名，需要自己写一个帮助类。
（其实我还写了个小程序可以自动生成签名，和JNI_OnLoad中注册要用到的<code>JNINativeMethod</code>数组，从此再也不用糟心的去写那该死的数组了。LOL~~~）</p>

<p>[全文完]</p>

<h4>参考资料</h4>

<p>[1] : <a href="http://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html">Oracle java SE documents</a></p>

<p>[2] : <a href="http://baike.baidu.com/view/6415820.htm">深入理解Android 卷 1</a> 第二章 ，邓凡平著，机械工业出版社</p>

<p>[3]: <a href="http://developer.android.com/training/articles/perf-jni.html">Google Android documents &ndash; JNI Tips</a></p>
</div>

</article>

	

<!--aThis Button BEGIN -->
<div class="jiathis_style">
	<span class="jiathis_txt">分享到：</span>
	<a class="jiathis_button_tools_1"></a>
	<a class="jiathis_button_tools_2"></a>
	<a class="jiathis_button_tools_3"></a>
	<a class="jiathis_button_tools_4"></a>
	<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
	<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->



<section id="comment">
    <h1 class="title">Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
</section>
</div>
			</div>
			<footer id="footer" class="inner">
<p>
  Copyright &copy; 2014 - LanderlYoung -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>
</footer>
			<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script>

<!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'landerlyoung';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://LanderlYoung.github.io/blog/2014/10/16/java-zhong-jnide-shi-yong/';
        var disqus_url = 'http://LanderlYoung.github.io/blog/2014/10/16/java-zhong-jnide-shi-yong/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







		</div>
	</div>

	<div id="slide">
		<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/10/16/java-zhong-jnide-shi-yong/">Java 中JNI的使用</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/10/14/run-commamd-before-build-in-intellij-idea/">Run Commamd Before Build in IntelliJ IDEA</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/09/30/an-zhuo-jian-ting-xin-shou-dao-duan-xin/">安卓监听新收到短信</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/09/23/javazhong-xian-cheng-chi-de-shi-yong/">Java(Android)中线程池的使用</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/10/yi-ci-dui-fei-jing-tai-nei-bu-lei-yin-yong-finalbian-liang-de-yan-jiu/">一次对非静态内部类引用final变量的研究</a>
      </li>
    
  </ul>
</section>
<section>
  <h1>Categories</h1>
    <ul id="category-list"><li><a href='/blog/categories/android/'>android (5)</a></li><li><a href='/blog/categories/git/'>git (2)</a></li><li><a href='/blog/categories/html5/'>html5 (5)</a></li><li><a href='/blog/categories/java/'>java (3)</a></li><li><a href='/blog/categories/javascript/'>javascript (3)</a></li><li><a href='/blog/categories/linux/'>linux (6)</a></li></ul>
</section>
<section>
	<h1>Tags</h1>
	<ul class="tag-cloud">
		<li><a style="font-size: 107.6%" href="/tags/android/">Android</a></li>
<li><a style="font-size: 89.7%" href="/tags/linux/">Linux</a></li>
<li><a style="font-size: 104.2%" href="/tags/html5/">HTML5</a></li>
<li><a style="font-size: 102.2%" href="/tags/java/">Java</a></li>
<li><a style="font-size: 116.1%" href="/tags/node-dot-js/">Node.js</a></li>
<li><a style="font-size: 85.6%" href="/tags/dictonary-node-dot-js/">dictonary_Node.js</a></li>
<li><a style="font-size: 113.7%" href="/tags/git/">Git</a></li>
<li><a style="font-size: 83.0%" href="/tags/vim/">Vim</a></li>
<li><a style="font-size: 109.7%" href="/tags/sou-gou-shu-ru-fa/">搜狗输入法</a></li>
<li><a style="font-size: 94.8%" href="/tags/ui/">UI</a></li>
<li><a style="font-size: 97.3%" href="/tags/zhuan-tie/">转贴</a></li>
<li><a style="font-size: 81.1%" href="/tags/svg/">SVG</a></li>
<li><a style="font-size: 95.9%" href="/tags/octpressban-qian-bian-ji-wei-zhi/">Octpress搬迁编辑位置</a></li>
<li><a style="font-size: 84.9%" href="/tags/tencent/">tencent</a></li>
<li><a style="font-size: 107.4%" href="/tags/androidyuan-dai-ma/">Android源代码</a></li>
<li><a style="font-size: 75.2%" href="/tags/java/">java</a></li>
<li><a style="font-size: 111.5%" href="/tags/android/">android</a></li>
<li><a style="font-size: 79.8%" href="/tags/intellij/">IntelliJ</a></li>
<li><a style="font-size: 82.8%" href="/tags/jni/">JNI</a></li>

	</ul>
</section>

	</div>
	<div id="hint">&gt;</div>

	<div id="drawer">
		<div id="touch"></div>
		<div id="bar">
			<div class="info">
				<ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
	<li><a href="/about-me/">About Me</a></li>
</ul>

			</div>
		</div>
	</div>
	<script src="/javascripts/slide.js"></script>

</body>
</html>
