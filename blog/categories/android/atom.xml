<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | Young_Blog]]></title>
  <link href="http://LanderlYoung.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://LanderlYoung.github.io/"/>
  <updated>2014-08-04T15:15:15+08:00</updated>
  <id>http://LanderlYoung.github.io/</id>
  <author>
    <name><![CDATA[LanderlYoung]]></name>
    <email><![CDATA[landerlyoung@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android 中的Handler相关源代码浅析]]></title>
    <link href="http://LanderlYoung.github.io/blog/2014/06/24/android-zhong-de-handlerxiang-guan-yuan-dai-ma-qian-xi/"/>
    <updated>2014-06-24T17:01:09+08:00</updated>
    <id>http://LanderlYoung.github.io/blog/2014/06/24/android-zhong-de-handlerxiang-guan-yuan-dai-ma-qian-xi</id>
    <content type="html"><![CDATA[<p>简单用法示例：</p>

<p>``` java
//在主线程中
private Handler handler = new Handler() {</p>

<pre><code>// 处理子线程给我们发送的消息。
@Override
    public void handleMessage(android.os.Message msg) {
        byte[] data = (byte[])msg.obj;
        Bitmap bitmap = BitmapFactory.decodeByteArray(data, 0, data.length);
        imageView.setImageBitmap(bitmap);
        Log.v("handler", "thread:" + Thread.currentThread().getName() +
                " msg.target=" msg.getTarget());
        if(msg.what == DOWNLOAD_IMG){
            dialog.dismiss();
        }
    }
</code></pre>

<p>}
```</p>

<!--more-->


<p>然后开启新的线程，在新的线程里面完成后台任务，任务完成后给这个handler发一个消息让它来处理。因为Handler是在主线程实例化(并且在实例化的时候没有指明Looper)，因此handler的handleMessage方法也是在主线程被调用的。</p>

<p>// 使用Handler Message MessageQueue Looper等方式去访问网络资源的时候，我们必须要开启一个子线程</p>

<p>```
public class MyThread implements Runnable{</p>

<pre><code>// 在run方法中完成网络耗时的操作
@Override
    public void run() {
        HttpClient httpClient = new DefaultHttpClient();
        HttpGet httpGet = new HttpGet(imgPath);
        HttpResponse httpResponse = null;
        try {
            Log.v("debug", "start download picture in thread:" +
                    Thread.currentThread().getName());
            httpResponse = httpClient.execute(httpGet);
            Log.v("debug", "download complete with status code" +
                    httpResponse.getStatusLine().getStatusCode());
            if(200 == httpResponse.getStatusLine().getStatusCode()){
                byte[] data = EntityUtils.toByteArray(httpResponse.getEntity());
                // 这里的数据data我们必须发送给UI的主线程，所以我们通过Message的方式来做桥梁。
                Message message = Message.obtain();
                message.obj = data;
                message.what = DOWNLOAD_IMG;
                handler.sendMessage(message);
            }
        } catch (Exception e) {
            // TODO: handle exception
        }
    }
</code></pre>

<p>}
```</p>

<p>分析一下整个过程的大致流程,首先从Handler的sendMessage下手：从源代码中看，sendMessage最终会调用到Handler中的sendMessageAtTime。</p>

<p>``` java
public boolean sendMessageAtTime(Message msg, long uptimeMillis)
{</p>

<pre><code>boolean sent = false;
MessageQueue queue = mQueue;
if (queue != null) {
    msg.target = this;
    sent = queue.enqueueMessage(msg, uptimeMillis);
}
else {
    RuntimeException e = new RuntimeException(
            this + " sendMessageAtTime() called with no mQueue");
    Log.w("Looper", e.getMessage(), e);
}
return sent;
</code></pre>

<p>}
```</p>

<p>看得出来主要做的事情就是把消息的target设置成自己，然后把消息存入到消息队列MessageQueue中去，
接着首先去看看MessageQueue mQueue的定义</p>

<p>在Handler类的最后，既然是final的那初始化一定在构造函数了：
默认构造函数，代码中的注释写道“默认构造函数，把这个handler和当前线程的消息队列联系起来，如果没有（当前线程的消息队列），这个handler就不能接收消息了。</p>

<p>```
/<em>*
 * Default constructor associates this handler with the queue for the
 * current thread.
 *
 * If there isn&rsquo;t one, this handler won&rsquo;t be able to receive messages.
 </em>/
public Handler() {</p>

<pre><code>...
    mLooper = Looper.myLooper();
if (mLooper == null) {
    throw new RuntimeException(
            "Can't create handler inside thread that has not called Looper.prepare()");
}
mQueue = mLooper.mQueue;
mCallback = null;
</code></pre>

<p>}
```</p>

<p>使用提供的消息队列，而不是使用默认的。</p>

<p>``` java
/<em>*
 * Use the provided queue instead of the default one.
 </em>/
public Handler(Looper looper) {</p>

<pre><code>mLooper = looper;
mQueue = looper.mQueue;
mCallback = null;
</code></pre>

<p>}
```</p>

<p>从上面两个函数可以看出来消息队列是Looper的，handler的sendMessage只是把Message加到了消息队列去。接着去看看Looper对消息对了mQueue做了什么。</p>

<p>Looper中的MessageQueue的定义如下：</p>

<p>然后是Looper 中的loop方法</p>

<p>``` java
/<em>*
 * Run the message queue in this thread. Be sure to call
 * {@link #quit()} to end the loop.
 </em>/
public static void loop() {</p>

<pre><code>final Looper me = myLooper();
if (me == null) {
    throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread.");
}
final MessageQueue queue = me.mQueue;

// Make sure the identity of this thread is that of the local process,
// and keep track of what that identity token actually is.
Binder.clearCallingIdentity();
final long ident = Binder.clearCallingIdentity();

for (;;) {
    Message msg = queue.next(); // might block
    if (msg == null) {
        // No message indicates that the message queue is quitting.
        return;
    }

    // This must be in a local variable, in case a UI event sets the logger
    Printer logging = me.mLogging;
    if (logging != null) {
        logging.println("&gt;&gt;&gt;&gt;&gt; Dispatching to " + msg.target + " " +
                msg.callback + ": " + msg.what);
    }

    msg.target.dispatchMessage(msg);

    if (logging != null) {
        logging.println("&lt;&lt;&lt;&lt;&lt; Finished to " + msg.target + " " + msg.callback);
    }

    // Make sure that during the course of dispatching the
    // identity of the thread wasn't corrupted.
    final long newIdent = Binder.clearCallingIdentity();
    if (ident != newIdent) {
        Log.wtf(TAG, "Thread identity changed from 0x"
                + Long.toHexString(ident) + " to 0x"
                + Long.toHexString(newIdent) + " while dispatching to "
                + msg.target.getClass().getName() + " "
                + msg.callback + " what=" + msg.what);
    }

    msg.recycle();
}
</code></pre>

<p>}
```</p>

<p>注意到中间的死循环 <code>for(;;;){...}</code>
以及关键的这一句：</p>

<p>猜测target就是这个message对应处理他的handler，于是我圆润的滚过去看看：
Message中的target是这么定义的：</p>

<p>看来八九不离十了。继续看target赋值的语句：</p>

<p>当然还有各种带有Handler参数的obtain方法，都会给target赋值。
于是看看Handler.dispatchMessage(Message)是做什么的：</p>

<p>``` java
public void dispatchMessage(Message msg) {</p>

<pre><code>if (msg.callback != null) {
    handleCallback(msg);
} else {
    if (mCallback != null) {
        if (mCallback.handleMessage(msg)) {
            return;
        }
    }
    handleMessage(msg);
}
</code></pre>

<p>}
```</p>

<p>如果msg的callback不为null就调用callback，否则如果就看看mCallback有没有设置，如果有的话就让callback来处理消息，如果没有就是用默认的处理方法。默认的处理方法是什么都不多，但是子类如果覆盖了handleMessage方法就可以执行子类想要做的代码了。</p>

<p>但是 事情没有那么简单！还有一个无参数的obtain方法，那么没有指定target的message是怎么成功发送到相应的handler的呢？还是圆润的滚过去看Looper的代码吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SNG迷你项目感悟]]></title>
    <link href="http://LanderlYoung.github.io/blog/2014/06/20/sngmi-ni-xiang-mu-gan-wu/"/>
    <updated>2014-06-20T16:38:32+08:00</updated>
    <id>http://LanderlYoung.github.io/blog/2014/06/20/sngmi-ni-xiang-mu-gan-wu</id>
    <content type="html"><![CDATA[<p>来腾讯实习有半个月来，刚进来公司统一培训了一天半，闲扯了点东西。然后SNG部门培训了3天时间，讲解一些业务流程。然后就是重头戏，所谓的迷你项目。我擦，虽然今天做完了，但是我还是想说这个巨坑啊！</p>

<!--more-->


<p>做这个迷你项目首先要说的是，还真的有点累的。。。每天早上做班车从酒店到公司，然后晚上一边九点走，到最后两天就更夸张了。前天在公司通宵了一夜，昨天夜里也是十二点多才走，欣慰的是腾大东侧的路上出租车排排停，估计我鹅长的员工加班都很积极吧。一个安卓应用，7天时间，两个人做，看这数据都觉得恐怖。</p>

<p>不过最后还是搞定了，尽管没拿奖，但是自己仍然很有成就感。做项目期间还是受到导师同事们的很大帮助的。最后一晚要不是wii帮qiuhang调了一个多小时的bug估计就得继续通宵了，而且说不定通宵了也搞不，那就苦逼了。</p>

<p>因为我做和服务器端的接口工作，当时一边商量一边改。一开始觉得商量接口真麻烦，后来才发现没有事先定义好接口才是做苦逼的。最荒唐的一件事是今天上午mini项目要测评了，结果昨天下午还在找后台的同学加接口。所以说：
<blockquote><p></p></p><p><h2>概要设计真的很重要</h2></p><p><br/><p></p></blockquote></p>

<p>前天晚上的问题是在电脑上调试完毕的net接口整合到Android上却得不到返回数据，比较奇怪的是有一个房屋信息POST请求能上传，而且数据库里会出现相应信息，但是返回值却是空的。一开始怀疑是没有申请网络访问权限，后来发现不是。后来sponsor Lewis 过来帮我调试，教了我安卓单步调试的方法，但是问题还是没能轻松解决。当天晚上熬了一夜，睡醒了4点，突然灵机一现决定把所有的JSON返回值都Log出来，同时所有的Exeption也要Log出来。后来慢慢调试才发现是<code>NetworkOnMainThreadException</code>！网络跑在主UI线程！所以每次执行到connect的时候android系统都会抛出这个异常，但是我却Too young， sometimes too naive！把所有可能抛出异常的地方都catch (Exception e) {}。就是说catch了所有Exception的父类并且什么也不做！对！就是不作为！后来跟我的导师raez说这件事，他说：
<blockquote><p></p></p><p><h2>异常本来是用来发现问题的，不能随便catch。</h2></p><p><br/><p></p></blockquote></p>

<p>对此我的理解是，需要catch一个exception的时候<strong>尽量精准catch</strong>。比如一个方法可能抛出IOException就不要懒懒的去直接catch Exception，同时如果抛出多种异常也要一个一个catch;
``` java
try {</p>

<pre><code>...
} catch (IOException e) {
        e.printStackTrace();
        ...
} catch (FileNotFoundException ex) {
        e.printStackTrace();
        ...
}
</code></pre>

<p><code>``
同时**捕获一个异常之后不能什么都不做**，至少应该</code>printStackTrace<code>或者是Log出来，否则出现问题之后很难排查出来。另外</code>NullPointerException<code>原则上不允许catch，</code>OutOfMemoryError`除了在大量消耗内存的代码片段上（比图图片处理，或者字符串拼接等）不允许catch。还有就是捕获异常是一定<strong>精准捕获</strong>。</p>

<p>另外关于安卓多线程的使用，学习到了两种方式：Activity的<code>runOnUiThread(Runnable)</code>方法，还有使用AsyncTask类, 另外还有是用Handler之类的方法，当时没有还没有学习。</p>

<p>另外一方面是缺少大型软开发的经验，原来自己写过的代码，最多也就一两千行。导致我们缺乏大型软件框架方面的知识。mini项目的Android端事实上来说就分了两个部分，UI和后台。今天听Wii讲了我们组的项目的大致构架，各个模块的分工功能，模块之间怎么通信回调，瞬间觉得高达上！真的是很开眼界。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[stepByStepAndroid-第一课]]></title>
    <link href="http://LanderlYoung.github.io/blog/2014/05/13/stepbystepandroid-di-%5B%3F%5D-ke/"/>
    <updated>2014-05-13T12:04:19+08:00</updated>
    <id>http://LanderlYoung.github.io/blog/2014/05/13/stepbystepandroid-di-[?]-ke</id>
    <content type="html"><![CDATA[<p>&lt;资源></p>

<ul>
<li>git项目<a href="https://github.com/LanderlYoung/stepByStepAndroid">github</a></li>
<li>详见<a href="https://github.com/LanderlYoung/stepByStepAndroid/releases">release note</a></li>
<li><a href="https://github.com/LanderlYoung/stepByStepAndroid/wiki">项目wiki</a></li>
</ul>


<p>&lt;/资源></p>

<p>梳理一下第一课学到的内容:</p>

<ol>
<li>创建简单的用户界面

<ul>
<li>简单的布局控制</li>
</ul>
</li>
<li>启动另一个Activity

<ul>
<li>给button添加回调函数</li>
<li>使用Intent</li>
</ul>
</li>
</ol>


<!--more-->


<h3>创建用户界面</h3>

<p>修改原来的fragment_main.xml文件，使用LinearLayout：
``` xml
&lt;LinearLayout xmlns:android=&ldquo;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&rdquo;</p>

<pre><code>xmlns:tools="http://schemas.android.com/tools"
android:layout_width="match_parent"
android:layout_height="match_parent"
android:orientation="horizontal" &gt;
</code></pre>

<p></LinearLayout>
<code>
上面的android:orientation属性把LinearLayout设置成水平线性布局，所有元素水平排列。
然后在LinearLayout中添加控件EditText和Button
</code> xml</p>

<pre><code>&lt;EditText 
    android:id="@+id/edit_message"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:hint="@string/edit_message" /&gt;
</code></pre>

<p>  &lt;Button</p>

<pre><code>    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="@string/button_send" /&gt;
</code></pre>

<p>```
然后在相应的strings.xml中添加string值。
效果如图：</p>

<p><img src="https://cloud.githubusercontent.com/assets/5700847/2953445/c8028f00-da59-11e3-9800-89a5c859064b.png" width="360" alt="device-2014-05-12-231827" /></p>

<p>接着控制一下布局：让EditText占据LinearLayout横向的剩余空间。只需要调整两个方面<code>android:layout_weight="1"</code>和<code>android:layout_width="0dp"</code>，其中layout_weight=1可以让它占据剩下的空间，layout_width=0改善性能。
看一下效果：</p>

<p><img src="https://cloud.githubusercontent.com/assets/5700847/2953442/b9d4597c-da59-11e3-886d-08d3f8e667a9.png" width="360" alt="device-2014-05-12-235041" /></p>

<h2>为button添加click事件处理</h2>

<p>在Button中添加一行<code>android:onClick="sendMessage"</code>这样就指定了button的click事件由<code>public void onClick(View view)</code>这样方法签名的方法来处理。
所以对应的去MainActicity.java中添加该函数：
``` java
//call back of the button
public void sendMessage(View view) {</p>

<pre><code>Intent intent = new Intent(getApplication(),DisplayMessageActivity.class);
EditText editText = (EditText)findViewById(R.id.edit_message);
String message = editText.getText().toString();
intent.putExtra(EXTRA_MESSAGE,message);
startActivity(intent);
</code></pre>

<p>}
```
上面的DisplayMessageActivity类是使用向导创建的新Activity。</p>

<h3>创建新Activity</h3>

<p>使用向导创建新的Activity，然后需要在AndroidManifest.xml里注册Activity</p>

<p>``` xml
   &lt;application</p>

<pre><code>   ......
    &lt;activity
        android:name="com.young.stepbystepandroid.DisplayMessageActivity"
        android:label="@string/title_activity_display_message"
        android:parentActivityName="com.young.stepbystepandroid.MainActivity" &gt;
        &lt;meta-data
            android:name="android.support.PARENT_ACTIVITY"
            android:value="com.young.stepbystepandroid.MainActivity" /&gt;
    &lt;/activity&gt;
&lt;/application&gt;
</code></pre>

<p>```</p>

<h3>使用Intent</h3>

<p><em>启动Intent</em>
``` java</p>

<pre><code>Intent intent = new Intent(getApplication(),DisplayMessageActivity.class);
EditText editText = (EditText)findViewById(R.id.edit_message);
String message = editText.getText().toString();
intent.putExtra(EXTRA_MESSAGE,message);
startActivity(intent);
</code></pre>

<p><code>
其中`public static final String EXTRA_MESSAGE = "com.young.stepByStepAndroid.MESSAGE";`
这个是一个显示Intent构造函数第一个参数是Context，可以使用this，因为Activity继承Context；但是推荐使用ApplicationContext防止内存泄漏。
*接收Intent*
</code> java</p>

<pre><code>Intent intent = getIntent();
String message = intent.getStringExtra(
        MainActivity.EXTRA_MESSAGE);

TextView textView = new TextView(this);
textView.setTextSize(40);
textView.setText(message);
</code></pre>

<p>```
代码很明显，不多说什么了。当然在Intent里面附加信息推荐使用<a href="http://developer.android.com/reference/android/os/Bundle.html">Bundle</a>。</p>

<p>看看成果：</p>

<p><img src="https://cloud.githubusercontent.com/assets/5700847/2953446/d6257c5a-da59-11e3-8e67-80bbecb4640f.png" width="360" alt="device-2014-05-13-002646" /></p>

<p><img src="https://cloud.githubusercontent.com/assets/5700847/2953447/d71cdef0-da59-11e3-9d39-e3e5d4de150d.png" width="360" alt="device-2014-05-13-002651" /></p>
]]></content>
  </entry>
  
</feed>
