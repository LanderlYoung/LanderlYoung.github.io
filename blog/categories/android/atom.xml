<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: android | Young_Blog]]></title>
  <link href="http://LanderlYoung.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://LanderlYoung.github.io/"/>
  <updated>2016-01-11T00:43:50+08:00</updated>
  <id>http://LanderlYoung.github.io/</id>
  <author>
    <name><![CDATA[LanderlYoung]]></name>
    <email><![CDATA[landerlyoung@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[retro-lambda 测试报告]]></title>
    <link href="http://LanderlYoung.github.io/blog/2016/01/11/re-lambda-ce-shi-bao-gao/"/>
    <updated>2016-01-11T00:10:42+08:00</updated>
    <id>http://LanderlYoung.github.io/blog/2016/01/11/re-lambda-ce-shi-bao-gao</id>
    <content type="html"><![CDATA[<h1>retrolambda测试报告</h1>

<p>先说结论</p>

<ol>
<li>堆栈行号完全匹配！没有任何问题，包括最新的android build tools自身支持的switch string，MultiCatch，和retrolambda的所有特性都没问题。</li>
<li>lambda是通过生成class来实现的，而且是生成static class而不是anonumous class，因此没有this$0引用。且支持<strong><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html">method reference （推荐阅读）</a></strong>。</li>
<li>但是lambda会生成冗余方法，每个Lambda类4个方法（下面有代码），其中一个是原接口的方法；增加3个，一个是构造方法，两个是静态工厂方法。</li>
<li>支持MultiCatch。</li>
<li>支持interface加default方法，亲测可行，但是使用该特性必须禁用增量编译。</li>
<li>支持interface加static方法，亲测不可行（可能版本bug），同上需要禁用增量编译。</li>
<li>支持tryWithResource但是估计这个用的不多，问题在于默认会吞掉Exception。同时Android Studio会报错说API19才能用，但是可以编译。</li>
<li>不支持Java8的新增API，包括Lambda相关的function包，和其他新包比如stream api。</li>
</ol>


<p>下面是测试细节以及源代码和反编译代码对比：</p>

<h2>switch string（这个是java7自身的语法糖）</h2>

<p>源代码：</p>

<pre><code class="cpp">private static void switchWithString(String str) {
    System.out.println("switchWithString");
    switch (str) {
        case "hello":
            System.out.println("Hello");
            break;
        case "World":
        case "world":
            new Throwable().printStackTrace();
            break;
    }
}
</code></pre>

<p>class反编译：</p>

<pre><code class="cpp">private static void switchWithString(String str) {
    System.out.println("switchWithString");
    byte var2 = -1;
    switch(str.hashCode()) {
    case 83766130:
        if(str.equals("World")) {
            var2 = 1;
        }
        break;
    case 99162322:
        if(str.equals("hello")) {
            var2 = 0;
        }
        break;
    case 113318802:
        if(str.equals("world")) {
            var2 = 2;
        }
    }

    switch(var2) {
    case 0:
        System.out.println("Hello");
        break;
    case 1:
    case 2:
        (new Throwable()).printStackTrace();
    }

}
</code></pre>

<h2>lambda</h2>

<p>源代码：</p>

<pre><code class="cpp">findViewById(R.id.stop).setOnClickListener((v) -&gt; {
    //Yes! use "this" to refer to the MainActivity.this
    Toast.makeText(this, "Hello lambda", Toast.LENGTH_SHORT).show();

    System.out.println("crash in lambda");
    new Throwable().printStackTrace();
});
</code></pre>

<p>class反编译：</p>

<pre><code class="cpp">this.findViewById(2131492943).setOnClickListener(MainActivity$$Lambda$1.lambdaFactory$(this));
final class MainActivity$$Lambda$1 implements OnClickListener {
    private final MainActivity arg$1;

    private MainActivity$$Lambda$1(MainActivity var1) {
        this.arg$1 = var1;
    }

    private static OnClickListener get$Lambda(MainActivity var0) {
        return new MainActivity$$Lambda$1(var0);
    }

    public void onClick(View var1) {
        MainActivity.access$lambda$0(this.arg$1, var1);
    }

    public static OnClickListener lambdaFactory$(MainActivity var0) {
        return new MainActivity$$Lambda$1(var0);
    }
}
</code></pre>

<p>可以看到生成的class中两个工厂方法get$Lambda和lambdaFactory$其实除了名字其他都一样，而且代码中只调用了后者，因此proguard混淆之后，会删除get$Lambda方法。这样和之前的InnerClass比起来就只是多了LambdaFactory$一个工厂方法。然而lambda的实现中会在MainActivity中添加一个 MainActivity.access$lambda$0 ，然后该方法会调用 MainActivity.lambda$onCreate$0 方法（这个命名和java8的lambda是一致的）。然而这里其实没必要使用access方法，因为lambda方法（即上文的MainActivity.lambda$onCreate$0 ）是编译器生成的，不会被其他方法引用。（嗯！java8就没有access方法！），不过没关系retrolambda是开源的，不爽可以自己改（就是这么任性！）。</p>

<p>优：</p>

<ol>
<li>把InnerClass改成了外部static class。避免了this$0逸出。</li>
</ol>


<p>劣：</p>

<pre><code>1. 所以总体方法数多了两个。可以改成只多一个。
2. lambda内部的堆栈dump会多几层，但是最后还是会定位到lambda内部。
</code></pre>

<p>下面是lambda内部crash堆栈dump：</p>

<pre><code class="bash">08-14 09:30:46.402  11348-11348/young.com.demo I/System.out﹕ crash in lambda
08-14 09:30:46.402  11348-11348/young.com.demo W/System.err﹕ java.lang.Throwable
08-14 09:30:46.402  11348-11348/young.com.demo W/System.err﹕ at young.com.demo.MainActivity.lambda$onCreate$0(MainActivity.java:81)
08-14 09:30:46.402  11348-11348/young.com.demo W/System.err﹕ at young.com.demo.MainActivity.access$lambda$0(MainActivity.java)
08-14 09:30:46.402  11348-11348/young.com.demo W/System.err﹕ at young.com.demo.MainActivity$$Lambda$1.onClick(Unknown Source)
08-14 09:30:46.402  11348-11348/young.com.demo W/System.err﹕ at android.view.View.performClick(View.java:4781)
08-14 09:30:46.402  11348-11348/young.com.demo W/System.err﹕ at android.view.View$PerformClick.run(View.java:19873)
08-14 09:30:46.402  11348-11348/young.com.demo W/System.err﹕ at android.os.Handler.handleCallback(Handler.java:739)
08-14 09:30:46.403  11348-11348/young.com.demo W/System.err﹕ at android.os.Handler.dispatchMessage(Handler.java:95)
08-14 09:30:46.403  11348-11348/young.com.demo W/System.err﹕ at android.os.Looper.loop(Looper.java:135)
08-14 09:30:46.403  11348-11348/young.com.demo W/System.err﹕ at android.app.ActivityThread.main(ActivityThread.java:5289)
08-14 09:30:46.403  11348-11348/young.com.demo W/System.err﹕ at java.lang.reflect.Method.invoke(Native Method)
08-14 09:30:46.403  11348-11348/young.com.demo W/System.err﹕ at java.lang.reflect.Method.invoke(Method.java:372)
08-14 09:30:46.403  11348-11348/young.com.demo W/System.err﹕ at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:904)
08-14 09:30:46.403  11348-11348/young.com.demo W/System.err﹕ at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:699)
</code></pre>

<h2>Lambda Method Reference：</h2>

<p>源代码：</p>

<pre><code class="cpp">private interface StringConsumer {
    void consumeAString(String str);
}

private static void testMethodReference(StringConsumer sc) {
    sc.consumeAString("testStringConsumer");
}

testMethodReference(System.out::println);
</code></pre>

<p>class反编译：</p>

<pre><code class="cpp">testMethodReference(MainActivity$$Lambda$4.lambdaFactory$(var10000));

final class MainActivity$$Lambda$4 implements StringConsumer {
    private final PrintStream arg$1;

    private MainActivity$$Lambda$4(PrintStream var1) {
        this.arg$1 = var1;
    }

    private static StringConsumer get$Lambda(PrintStream var0) {
        return new MainActivity$$Lambda$4(var0);
    }

    public void consumeAString(String var1) {
        this.arg$1.println(var1);
    }

    public static StringConsumer lambdaFactory$(PrintStream var0) {
        return new MainActivity$$Lambda$4(var0);
    }
}
</code></pre>

<h2>MultiCatch</h2>

<p>源代码：</p>

<pre><code class="cpp">private static void testMultiCatch(int i) {
    System.out.println("testMultiCatch");
    try {
        switch (i) {
            case 0:
                throw new NullPointerException();
            case 1:
                throw new IllegalStateException();
            case 2:
                throw new IOException();
            case 3:
                throw new RuntimeException();
        }
    } catch (NullPointerException | IllegalStateException | IOException e) {
        e.printStackTrace();
    } catch (RuntimeException ex) {
        //make this branch different to suppress warnings
        int a = ex.hashCode();
        ex.printStackTrace();
    }
}
</code></pre>

<p>class反编译：</p>

<pre><code class="cpp">private static void testMultiCatch(int i) {
    System.out.println("testMultiCatch");

    try {
        switch(i) {
        case 0:
            throw new NullPointerException();
        case 1:
            throw new IllegalStateException();
        case 2:
            throw new IOException();
        case 3:
            throw new RuntimeException();
        }
    } catch (IllegalStateException | IOException | NullPointerException var3) {
        var3.printStackTrace();
    } catch (RuntimeException var4) {
        int a = var4.hashCode();
        var4.printStackTrace();
    }

}
</code></pre>

<pre><code>好像没什么区别，不是我粘错了，估计是JVM本来就支持这个特性。
</code></pre>

<h2>tryWithResource</h2>

<p>源代码：</p>

<pre><code class="cpp">
private static void testTryWithResource(ServerSocket ss) {
if (ss == null) return;

try (Socket in = ss.accept();
     InputStream is = in.getInputStream()) {
    is.read();
} catch (IOException e) {

}
</code></pre>

<p>class反编译：</p>

<pre><code class="cpp">
private static void testTryWithResource(ServerSocket ss) {
    if(ss != null) {
        try {
            Socket in = ss.accept();
            Throwable var2 = null;

            try {
                InputStream is = in.getInputStream();
                Throwable var4 = null;

                try {
                    is.read();
                } catch (Throwable var29) {
                    var4 = var29;
                    throw var29;
                } finally {
                    if(is != null) {
                        if(var4 != null) {
                            try {
                                is.close();
                            } catch (Throwable var28) {
                                ;
                            }
                    } else {
                            is.close();
                        }
                    }

                }
            } catch (Throwable var31) {
                var2 = var31;
                throw var31;
            } finally {
                if(in != null) {
                    if(var2 != null) {
                        try {
                            in.close();
                        } catch (Throwable var27) {
                            ;
                        }
                    } else {
                        in.close();
                }
                }

            }
        } catch (IOException var33) {
            ;
        }

    }
}
</code></pre>

<p>好™啰嗦啦！绝对不要用这个。</p>

<p>附录
关于androidBuildTool对java7的支持，原文来自：</p>

<p><a href="">http://tools.android.com/tech-docs/new-build-system/user-guide#TOC-Using-sourceCompatibility-1.7</a></p>

<p>Using sourceCompatibility 1.7
With Android KitKat (buildToolsVersion 19) you can use the diamond operator, multi-catch, strings in switches, try with resources, etc. To do this, add the following to your build file:</p>

<pre><code class="cpp">
android {
    compileSdkVersion 19
    buildToolsVersion "19.0.0"

    defaultConfig {
        minSdkVersion 7
        targetSdkVersion 19
    }

    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_7
        targetCompatibility JavaVersion.VERSION_1_7
    }
}
</code></pre>

<p>Note that you can use minSdkVersion with a value earlier than 19, for all language features <em>except try with resources</em>. If you want to use try with resources, you will need to also use a minSdkVersion of 19.</p>

<p>You also need to make sure that Gradle is using version 1.7 or later of the JDK. (And version 0.6.1 or later of the Android Gradle plugin.)</p>

<h1>匿名类 VS Lambda</h1>

<p>今天修复了几个listener导致内存泄露的问题。
在review代码的过程中发现很多泄露是匿名类的this$0导致的，事实上挺多时候匿名类并没有显式的使用到this。</p>

<h2>匿名类</h2>

<p><strong>匿名类必然会引用this，不管代码中是否真正用到。</strong>
java中的匿名类和非static内部类（标准叫法是嵌套类nested class，内部类专指static inner class），都会有外部类的引用，通过构造函数传进来，并在内部类的this$0成员变量中保存；但是我们通常不会注意到他们，因为java编译器帮我们做了这些；如果我们查看反编译的class文件会发现他们是真真切切的存在。</p>

<p>比如：</p>

<pre><code class="cpp">
private BroadcastReceiver mCollectionReceiver = new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            //...
        }
    };
</code></pre>

<p>反编译javac生成的class</p>

<pre><code class="cpp">
class BroadcastDetailFragment$4
  extends BroadcastReceiver
{
  BroadcastDetailFragment$4(BroadcastDetailFragment this$0) {}

  public void onReceive(Context context, Intent intent)
  {
    //...
  }
}
</code></pre>

<p>可以看到构造函数中是有个this$0的参数的。</p>

<h2>Lambda</h2>

<p><strong>lambda不一定会引用this，具体看lambda里面是否用到。</strong>
Lambda中所有引用到的外部的变量都是通过参数的形式传给实现lambda的函数的。如果lambda中用到this或非static成员方法、非static成员变量，那么lambda就必须引用this，这个this就是作为参数传给实现lambda的函数；反之，若lambda不需要this，编译器就不会传this作为参数，这时候该lambda生成的类就不会泄露我们的Fragment，Activity。</p>

<h2>总结：</h2>

<p>使用Lambda除了可以使代码更优雅，还可以减少不必要的this泄露。
之前我曾担心过：retro-lambda会给每个lambda生成一个类，会不会带来性能，内存之类的压力；但是想到scala语言就是用这种方式实现的lambda，而且玩的很欢乐，想必不用过度担心。</p>

<h3>附录：</h3>

<ol>
<li><p>关于scala和java8是怎么分别实现lambda的，可以参看<a href="http://blog.takipi.com/compiling-lambda-expressions-scala-vs-java-8/">这篇文章</a>。PS：retro-lambda是模仿了scala的做法（因为android中不支持invokedynamic虚拟机指令，其在java7中引入，所以理论上javac生成的lambda在java7上也是能跑的）</p></li>
<li><p>retrolambda测试报告，在项目引入retro-lambda之前，我做了几个实验，验证之前的疑问点。下面是之前的结论，再贴一遍~方便翻阅~</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android中service的使用]]></title>
    <link href="http://LanderlYoung.github.io/blog/2014/11/09/androidzhong-servicede-shi-yong/"/>
    <updated>2014-11-09T18:07:03+08:00</updated>
    <id>http://LanderlYoung.github.io/blog/2014/11/09/androidzhong-servicede-shi-yong</id>
    <content type="html"><![CDATA[<h2>Android 中service的使用 笔记</h2>

<h3>Service是何物</h3>

<p>service是安卓四大组件（Activity、BroadcastReceiver、ContentProvider、Service）之一。Service用于执行耗时比较长的操作，在后台运行，没有界面显示。</p>

<p><strong>Service与进程</strong>：<br/>
Service可以在应用的主进程中运行，也可以在单独的进程中运行。只需要在Service的[Manifest声明][manifest]中指明进程名即可。同一个应用中所有具有相同进程名的组件（四大组件，包括Activity）均可以运行在同一个进程中。</p>

<p><strong>Service的寿命</strong>： <br/>
这里说的<code>寿命</code>只是service什么时候运行什么时候终止而已并非生命周期的概念。service的启动方式有两种：<br/>
 1. 通过<code>Context::strtService</code>来启动一个Service，这个Service会一直在后台运行，即使启动该Service的组件已经结束。它只能自己结束自己，通过<code>Service::stopSelf()</code>或者是被其他组件显示的结束，通过<code>Context::StopService</code>。或者系统可用内存不够，android系统会选择性的kill掉一些service，在需要的时候再重新启动他们。当然如果进程自己crash也是会结束的(╯‵□′)╯︵┻━┻（这不是废话）。 <br/>
 2. 通过<code>Context::bindService</code>启动Service。一个绑定的Service一般是 C-S（客户端-服务器）类型的，通常会和其他组件进行通信，包括：发送请求，收取返回结果，甚至是进程间通信——IPC。一个绑定的Service的寿命和绑定他的组件相关，当所有绑定到他上面的组件都结束（或者取消绑定——通过<code>Context::unbindService</code>方法）的时候，这个service就自然结束。</p>

<!--more-->


<p>当然启动一个Service还可以同时用上面两个方法：先startService启动一个常驻service，然后bind到他上面进行通信——IPC。</p>

<blockquote><p>Service运行在进程的主线程上。所以如果要执行长耗时或CPU高消耗任务的话还是要自行创建线程，以免阻塞主进程导致service的声明周期方法不能及时回调。</p></blockquote>

<h3>基础知识：</h3>

<p>创建一个Service时，必须创建一个Service的子类，并覆盖相应的声明周期回调方法，来进行相应的处理。你需要覆盖的最重要的几个声明周期回调是：<br/>
 1. onStartCommand：当其他组件（比如Activity）通过startService方法启动Service的时候，系统就会回调这个方法。一旦这个方法被调用，该service就会永久的运行下去。因此你将有义务来结束这个service，通过service自己调用<code>stopSelf</code>或者在其他组件中调用<code>Context::stopService</code>。如果你只是希望通过bind来启动这个service，则没有什么必要来覆盖这个方法。这个方法有三个参数，第一个是启动这个Service的Intent，第二个是启动Flag，第三个是startID，每次这个方法回调的时候这个ID就会增加一次（保证每次都不一样）。<br/>
 2. onBind：当其他组件调用<code>Context::bindService</code>来绑定到service上的时候，一般会在onBind中返回一个IBinder对象的实例，提供给Client调用Service中的方法。相应的如果不希望客户端绑定到service上就返回<code>null</code>好了。 <br/>
 3. onCreate：和Activity的onCreate一样，在整个生命周期中值调用一次——在service被创建的时候。 <br/>
 4. onDestroy：也是和Activity一样，在整个生命周期中也只调用一次——在service被销毁的时候。这个方法是service中最后一个执行的方法。</p>

<p><strong>重申</strong>：</p>

<blockquote><p>如果Service是通过<code>Context::startService</code>来启动的话，它将一直运行下去，知道他结束自己（通过<code>Service::stopSelf</code>方法）或者其他组件结束掉他（通过<code>Context:stopService</code>方法）。<strong>另外</strong>：即使上面所说两个方法（<code>Service::stopSelf</code>和<code>Context:stopService</code>）已经调用，只要有bind到这个service上的组件没有unbind这个service也不会立即结束。</p></blockquote>

<h3>在Manifest中声明你的service：</h3>

<p>语法如下：</p>

<pre><code class="xml">&lt;service android:enabled=["true" | "false"]
         android:exported=["true" | "false"]
         android:icon="drawable resource"
         android:isolatedProcess=["true" | "false"]
         android:label="string resource"
         android:name="string"
         android:permission="string"
         android:process="string" &gt;
    . . .
&lt;/service&gt;
</code></pre>

<p>上面的attribute和大部分的组件都是一样的。<br/>
 1. <code>android:isolatedProcess</code>：如果是true的话这个service将运行在一个隔离的特殊进程中，并且不具备任何权限（包括你在Manifest中声明的）。唯一能和service通信的方式就是bind和start。
 2. <code>android:process</code>：进程名。就是这个service运行的进程的名字。虽然其他三个组件也可以指定进程名，但是service才是真正需要这个属性的组件！因为一些进程往往需要长时间运行，在主进程之外运行。
     1. 如果不指定这个属性的话，组件将在默认进程中执行，进程名就是包名。<br/>
     2. 如果指定了进程名，则运行在指定的进程中，其他组件也可以访问该service，只要满足service指定的权限。
     3. 特殊情况：如果进程名以「冒号」开头（<code>:</code>），则该service是应用私有的service，其他应用不能访问到。</p>

<p>**bindService和unbindService：
bind和onBind必须成对出现，否则service不会终止。加入你的onBind卸载activity的onDestroy中，然后activity被系统终止而没有调用onDestroy，此时系统会帮你调用onBind并log一个warnning警告你！<br/>
<code>boolean bindService(Intent service, ServiceConnection conn, int flags)</code>:其中intent是启动service的Intent，conn是回调。定义是：</p>

<pre><code class="java">public interface ServiceConnection {
    //service连接成功时的回调，IBinder就是service返回的Binder
    public void onServiceConnected(ComponentName name, IBinder service);
    //service**意外**终止时的回调，一般是service进程crash或者被系统杀掉。他并不会关闭与service的连接。
    public void onServiceDisconnected(ComponentName name);
}
</code></pre>

<p><code>public void unbindService(ServiceConnection conn)</code>:unbind中有个conn参数，就是你在bind是传入的那个回调。</p>

<h3>Android中的进程间通信——IPC</h3>

<p>这个是一个很精彩的内容，用过android的ipc机制才发现<strong>IPC从未如此简单！</strong>。</p>

<h4>Android Interface Definition Language (AIDL)</h4>

<p>android的IPC通过<code>aidl</code>文件来指定接口，aidl的含义是「Android Interface Definition Language 」，其使用了一种很类似java的语法来制定IPC接口。<br/>
<a name="aidl_chestnut">举个栗子</>，比如在com.example.service包中，写一个aidl文件，内容如下：</p>

<pre><code class="java">package com.example.service;

import com.example.service.ICallback;
import android.os.Bundle;

interface IDemoServiceController {
    int getPid();
    int add(int a, int b);
    void causeToStop();
    void paramInAndOut(in Bundle bundleIn, out Bundle bundleOut, inout Bundle bundleInOut);
}
</code></pre>

<p>可以看到基本上和JAVA一模一样！<br/>
<strong>需要注意</strong>：<br/>
 1. AIDL支持的数据类型<a name="aidl_types"></>：<br/>
     1. <a href="#aidl_default_type">AIDL默认支持的数据类型</a><br/>
     2. <a href="#parcelable">实现了Parcelable接口</a>任意类<br/>
 2. 另外你必须import所有使用到的class到你的AIDL文件中，即使他跟你的aidl文件在同一个包中！<br/>
 3. 方法可以有0到多个参数，也可以返回void。<br/>
 4. 参数中的所有的非java原始类型（必须指定一个参数的数据走向，是<code>int</code>，<code>out</code>，<code>inout</code>，三者之一）。<br/>
 5. 参数中的所有的原始类型都是in，而且不能被修改。</p>

<p><a name="aidl_default_type"></a>AIDL默认支持的数据类型如下：</p>

<ol>
<li><p>java语言中的所有原始类型（primitive type，比如：int, long, char, boolean)</p></li>
<li><p>String</p></li>
<li><p>CharSequence</p></li>
<li><p>支持数组！虽然文档没说，但经过实验证明是支持数组的。但是数组的元素必须是AIDL所支持的<a href="#aidl_types">数据类型</a>。</p></li>
<li><p>List <strong>注意</strong></p>

<ol>
<li>List中的所有类型也必须是AIDL所支持的<a href="#aidl_types">数据类型</a>。</li>
<li>List可以被当做泛型类来使用（比如<code>List&lt;String&gt;</code>）。</li>
<li>接收参数的另一端（对于client，另一端指service；对于service另一端指  client）收到的List实际类型总是ArrayList。</li>
</ol>
</li>
<li><p>Map <strong>注意</strong></p>

<ol>
<li>Map所支持的类型同上。</li>
<li>泛型Map并不支持。</li>
<li>接收参数的另一端接收到的Map实际类型是HashMap。</li>
</ol>
</li>
</ol>


<h4>实现Parcelable接口</h4>

<p>因为实例是要在进程间传递的因此必须序列化才行。Parcelable就是android定义的一个用于class序列化的即轻量级又高效的机制。<br/>
Parcelable接口的定义如下：</p>

<pre><code class="java">public interface Parcelable {
    public int describeContents();
    public void writeToParcel(Parcel dest, int flags);
    public interface Creator&lt;T&gt; {
        public T createFromParcel(Parcel source);
        public T[] newArray(int size);
    }
}
</code></pre>

<p>其中<code>describeContents()</code>用于描述数据类型，可以简单的返回0。
然后是用于序列化的方法<code>writeToParcel(Parcel dest, int flags)</code>：<br/>
dest就是用于存储序列的类的容器，然后flags可以是普通的0，或者是<code>PARCELABLE_WRITE_RETURN_VALUE</code>用来告诉你这个object是被写回返回值的（比如下列方法中  <code>Parcelable someFunction()</code>, <code>void someFunction(out Parcelable)</code>, or <code>void someFunction(inout Parcelable)</code>），以此来告诉你该清理资源就赶紧的！</p>

<p>然后问题来了：怎么只有序列化没有反序列化！这只出不进不是要弹尽粮绝（<del>精尽人亡</del>）吗？！<br/>
好了，Parcelable接口是有魔力的，他并不是一个普通的接口。android规定，要实现这个接口除了实现上面两个接口还要在类中定义一个static成员变量，名字必须叫“CREATOR”（此处需要注意配置proguard混淆，很明显android会用反射来获取这个变量，<del>忍不住吐槽一句！google你怎么那么喜欢反射！！</del>），然后这个CREATOR必须是<code>Parcelable.Creator&lt;T&gt;</code>的实现，android系统将使用这个实例来进行反序列化。</p>

<p>举个栗子（盗自android文档Parcelable篇）：</p>

<pre><code class="java">public class MyParcelable implements Parcelable {
     private int mData;

     public int describeContents() {
         return 0;
     }

     public void writeToParcel(Parcel out, int flags) {
         out.writeInt(mData);
     }

     public static final Parcelable.Creator&lt;MyParcelable&gt; CREATOR
             = new Parcelable.Creator&lt;MyParcelable&gt;() {
         public MyParcelable createFromParcel(Parcel in) {
             return new MyParcelable(in);
         }

         public MyParcelable[] newArray(int size) {
             return new MyParcelable[size];
         }
     };

     private MyParcelable(Parcel in) {
         mData = in.readInt();
     }
 }
</code></pre>

<h4>在Client和Service端调用aidl指定的方法</h4>

<p>android sdk tool会自动根据aidl文件生成相应的java文件。因此可以直接使用之。</p>

<p><strong>在server端</strong><br/>
前面说过onBind方法会返回一个IBinder的实例给client调用。这里返回的IBinder实例就和你的aidl有关。你需要在server中实现aidl中指定的接口的实现，还举<a href="#aidl_chestnut">刚才的栗子</a>。你需要在server中这样：</p>

<pre><code class="java">private class MyBinder extends IDemoServiceController.Stub {
        @Override
        public int getPid() throws RemoteException {
            return android.os.Process.myPid();
        }

        @Override
        public int add(int a, int b) throws RemoteException {
            return a + b;
        }

        @Override
        public void causeToStop() throws RemoteException {
            log("causeToStop");
            stopSelf();
        }

        @Override
        public boolean addCallback(ICallback callback) throws RemoteException {
            clientCallback = callback;
            return true;
        }

        @Override
        public void invokeCallback() throws RemoteException {
            if (clientCallback != null) {
                clientCallback.call(0);
            }
        }

        @Override
        public void paramInAndOut(Bundle[] bundleIn, Bundle bundleOut) throws RemoteException {

        }
    }
</code></pre>

<p>其中的Stub是aldi工具自动生成的，<a href="#aidl_implements">等会</a>详细说为啥要继承自他而不是自己实现Interface即可。然后你在onBinde中返回这个实现的实例即可：</p>

<pre><code>private IBinder mBinder = new MyBinder();
public IBinder onBind(Intent intent) {
    log("onBind");
    return mBinder;
}
</code></pre>

<p><strong>client端</strong>：
记得上面说的bindService的回调吗在<code>onServiceConnected</code>中：</p>

<pre><code class="java">public void onServiceConnected(ComponentName name, IBinder service) {
    log("service name:" + name);
    mDemoServiceBinder = IDemoServiceController.Stub.asInterface(service);
}
</code></pre>

<p>是的，这里还是要用那个Stub。然后你只需要在Client中调用mDemoServiceBinder 中的所有方法即可。因为Stub是实现了AIDL中的接口的，所以它提供给你了你定义的所有方法。<br/>
<strong>需要注意</strong>：AIDL中定义的方法会抛出RemoteException，所以记得捕获之。</p>

<h3>好奇：“AIDL是怎么实现跨进程方法调用的  ”</h3>

<p>这里点很类似于java EE中的RMI（Remote Method Invoke）。但是比他轻量级，简单，方便。想知道android中怎么实现RMI的，不妨从上面用的的神器Stub入手。于是我们就打开了sdk tool从aidl生成的java文件。看看Stub到底长啥样！！</p>

<pre><code class="java">public static abstract class Stub extends android.os.Binder implements com.example.service.IDemoServiceController {
    private static final java.lang.String DESCRIPTOR = "com.example.service.IDemoServiceController";

    /**
     * Construct the stub at attach it to the interface.
     */
    public Stub() {
        this.attachInterface(this, DESCRIPTOR);
    }

    /**
     * Cast an IBinder object into an com.example.service.IDemoServiceController interface,
     * generating a proxy if needed.
     */
    public static com.example.service.IDemoServiceController asInterface(android.os.IBinder obj) {
        if ((obj == null)) {
            return null;
        }
        android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);
        if (((iin != null) &amp;&amp; (iin instanceof com.example.service.IDemoServiceController))) {
            return ((com.example.service.IDemoServiceController) iin);
        }
        return new com.example.service.IDemoServiceController.Stub.Proxy(obj);
    }

    @Override
    public android.os.IBinder asBinder() {
        return this;
    }

    @Override
    public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException {
        switch (code) {
            case INTERFACE_TRANSACTION: {
                reply.writeString(DESCRIPTOR);
                return true;
            }
            case TRANSACTION_paramInAndOut: {
                    data.enforceInterface(DESCRIPTOR);
                    android.os.Bundle _arg0;
                    if ((0 != data.readInt())) {
                        _arg0 = android.os.Bundle.CREATOR.createFromParcel(data);
                    } else {
                        _arg0 = null;
                    }
                    android.os.Bundle _arg1;
                    _arg1 = new android.os.Bundle();
                    this.paramInAndOut(_arg0, _arg1);
                    reply.writeNoException();
                    if ((_arg1 != null)) {
                        reply.writeInt(1);
                        _arg1.writeToParcel(reply, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
                    } else {
                        reply.writeInt(0);
                    }
                    return true;
                }
        }
        return super.onTransact(code, data, reply, flags);
    }

    private static class Proxy implements com.example.service.IDemoServiceController { ... }

    ...
    static final int TRANSACTION_paramInAndOut = (android.os.IBinder.FIRST_CALL_TRANSACTION + 3);
    ...

}
</code></pre>

<p>所以说Stub是个抽象类，继承自Binder，实现了AIDL接口，我们在service端就是直接实现的这个类。在Stub有很长的一个方法叫<code>onTransact</code>他是Binder的方法，从上面可以看到（为了篇幅删了好几个case）。然后在case里面才调用到了aidl接口的实现，对边找一个case看看，会发现他是从Parcel中获取参数，然后调用真正的方法实现，最后在把返回值写回parcel。所以可以看到如果client调用某个方法，系统会调用service的onTransact。所以RMI最主要的还是数据（参数，返回值，Exception）的传输。</p>

<p>注意到Client中是把<code>onServiceConnection</code>返回的IBinder通过Stub的<code>asInterface</code>方法获取的ALDI实现，于是去看看<code>asInterface</code>是干嘛的。有点复杂，总之看最后一句<code>return new com.example.service.IDemoServiceController.Stub.Proxy(obj);</code>!哦！Stub里还有个Proxy类。所以我们最后拿到的是Proxy的实例咯。</p>

<p>其实从名字（Proxy）可以知道他是干啥的，就是个代理嘛，用到了面向对象的Proxy设计模式。所以我们在Client中调用的所有方法都是由Proxy实现的，于是看看Proxy。</p>

<p>举个栗子呗：</p>

<pre><code class="java">@Override
public int paramInAndOut(android.os.Bundle bundleIn, android.os.Bundle bundleOut) throws android.os.RemoteException {
    android.os.Parcel _data = android.os.Parcel.obtain();
    android.os.Parcel _reply = android.os.Parcel.obtain();
    int _result;
    try {
        _data.writeInterfaceToken(DESCRIPTOR);
        if ((bundleIn != null)) {
            _data.writeInt(1);
            bundleIn.writeToParcel(_data, 0);
        } else {
            _data.writeInt(0);
        }
        mRemote.transact(Stub.TRANSACTION_paramInAndOut, _data, _reply, 0);
        _reply.readException();
        _result = _reply.readInt();
        if ((0 != _reply.readInt())) {
            bundleOut.readFromParcel(_reply);
        }
    } finally {
        _reply.recycle();
        _data.recycle();
    }
    return _result;
}
</code></pre>

<p>吼吼吼，所以就是把参数写进Parcel，调用Binder的transact，再从返回的parcel中取得数据，最后返回。其中readException会捕获service中抛出的异常，然后丢回给client。</p>

<h3>附录——Service回调Client</h3>

<p>通过AIDL可以很方便的让client调用service的方法，但是有时候service需要回调Client。（比如报告任务的进度从而更新进度条。）</p>

<p>最简单粗暴的方式就是发广播！这个方法怎么样？好啊！真的不错，但是不够轻量级吧。而且有点不够方便。</p>

<blockquote><p>有没有像AIDL中Client调Service中的方法呢，还是那样方便呀！
答案是：<strong>有！</strong></p></blockquote>

<p>好了，关子卖完了。说正事！</p>

<p>这里需要定义一个回调函数的AIDL接口（比如 &ldquo;ICallback.aidl&#8221;），然后还要在Client——Service通信的AIDL中添加类似<code>boolean addCallback(in ICallback callback);</code>、<code>void invokeCallback();</code>的方法。</p>

<p>然后你在Client实现一个<code>ICallback.Stub</code>类，在<code>addCallback</code>中把他传给service，service收到之后存下来，当你调用<code>invokeCallback</code>的时候service就会调用刚才传进来的callback。</p>

<p>栗子——Client:</p>

<pre><code class="java">private ICallback mServiceCallback = new ICallback.Stub() {
    @Override
    public void call(int code) {
        log("pid:" + android.os.Process.myPid());
        mStartServiceButton.setBackgroundColor(Color.parseColor("#ff00ff"));
    }
};

if (mDemoServiceBinder != null) {
    try {
        mDemoServiceBinder.addCallback(mServiceCallback);
        log("add 1 + 2 = " + mDemoServiceBinder.add(1, 2));
    } catch (RemoteException e) {
        log("add 1 + 2 reveived remoteexception" + e.toString());
    }
} else {
    log("not binded yet");
}
</code></pre>

<p>栗子——Service：</p>

<pre><code class="java">private class MyBinder extends IDemoServiceController.Stub {
...
    @Override
    public boolean addCallback(ICallback callback) throws RemoteException {
        clientCallback = callback;
        return true;
    }

    @Override
    public void invokeCallback() throws RemoteException {
        if (clientCallback != null) {
            clientCallback.call(0);
        }
    }
...
}
</code></pre>

<p>很简单，就酱！</p>

<h3>参考资料</h3>

<p>[API Guide——Service]：<a href="http://developer.android.com/guide/components/services.html">http://developer.android.com/guide/components/services.html</a></p>

<p>[API Guide——AIDL]: <a href="http://developer.android.com/guide/components/aidl.html">http://developer.android.com/guide/components/aidl.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android中的WakeLock使用]]></title>
    <link href="http://LanderlYoung.github.io/blog/2014/10/31/androidzhong-de-wakelockshi-yong/"/>
    <updated>2014-10-31T10:08:26+08:00</updated>
    <id>http://LanderlYoung.github.io/blog/2014/10/31/androidzhong-de-wakelockshi-yong</id>
    <content type="html"><![CDATA[<p>android系统在手机屏幕锁定之后一般会让手机休眠，以提高电池的使用时间。但是休眠意味着CPU频率降低，有时候可能需要做一些需要大量运算的任务，所以需要唤醒CPU。WakeLock可以做到这一点。</p>

<!--more-->


<h3>WakeLock的创建是：</h3>

<pre><code class="java">
PowerManager powerManager = (PowerManager) getSystemService(POWER_SERVICE);

Wakelock wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,

        "MyWakelockTag");
</code></pre>

<p>另外如果要使用WakeLock需要在Manifest中添加如下权限</p>

<p><code>&lt;uses-permission android:name="android.permission.WAKE_LOCK" /&gt;</code></p>

<h3>WakeLock的等级</h3>

<p>上面的第一个参数是WakeLock levelAndFlag，分别代表了一种WakeLock等级，并且可以通过「或」位操作组合使用。他们是：</p>

<ol>
<li><p>PARTIAL_WAKE_LOCK：保证CPU保持高性能运行，而屏幕和键盘背光（也可能是触摸按键的背光）关闭。一般情况下都会使用这个WakeLock。</p></li>
<li><p>ACQUIRE_CAUSES_WAKEUP：这个WakeLock除了会使CPU高性能运行外还会导致屏幕亮起，即使屏幕原先处于关闭的状态下。</p></li>
<li><p>ON_AFTER_RELEASE：如果释放WakeLock的时候屏幕处于亮着的状态，则在释放WakeLock之后让屏幕再保持亮一小会。如果释放WakeLock的时候屏幕本身就没亮，则不会有动作。</p></li>
</ol>


<p>被<strong>弃用</strong>的WakeLock：</p>

<ol>
<li><p>SCREEN_DIM_WAKE_LOCK：保证屏幕亮起，但是亮度可能比较低。同时键盘背光也可以不亮。</p></li>
<li><p>SCREEN_BRIGHT_WAKE_LOCK ：保证屏幕全亮，同时键盘背光也亮。</p></li>
<li><p>FULL_WAKE_LOCK：表现和SCREEN_BRIGHT_WAKE_LOCK 类似，但是区别在于这个等级的WakeLock使用的是<strong>最高亮度</strong>！</p></li>
</ol>


<p>这三个Level在API17被弃用。被弃用说明肯定有替代品吗，上面三个类型的作用无非就是保持屏幕长亮。所以推荐是用WindowFlag<code>WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON</code>。使用方法是：</p>

<ol>
<li><p>在Activity中： <code>getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);</code></p></li>
<li><p>甚至可以在布局中添加这个属性：<code>android:keepScreenOn="true"</code></p></li>
</ol>


<p>被<strong>隐藏</strong>的WakeLock：</p>

<p>android中的部分api并不对用户应用开放，他们通过在注释中加入<code>{@hide}</code>来注明。但是在SDK提供的源代码中是可以看到的。</p>

<ul>
<li>WAIT_FOR_PROXIMITY_NEGATIVE：用于和接近传感器配合使用，来实现电话应用中打电话时可以使屏幕黑掉，手机离开时又能使屏幕亮起来的功能。acqure的时候屏幕会暗下来，release之后屏幕会亮。其值是32（int）。虽然被hide起来，但是感觉这个超实用的好吗！！！为啥要hide起来。。。「话说在API21 上终于开放了（开放这么晚有个屁用啊(╯‵□′)╯︵┻━┻）」经试验，不过newWakeLock的时候flag直接用32代替是可以创建这个等级的WakeLock的，但是因为是非开放API，不能保证第三方OEM修改这个代码实现！因此使用起来并不安全。「说的好像开放的API第三方OEM就不会乱改一样。。。(╯‵□′)╯︵┻━┻」</li>
</ul>


<h3>WakeLock的使用：</h3>

<ul>
<li><p>获取WakeLock：</p>

<ol>
<li><p><code>void acquire()</code>:获得WakeLock</p></li>
<li><p><code>void acquire(long timeOut)</code>:获得WakeLock timeOut时长，当超过timeOut之后系统自动释放WakeLock。</p></li>
</ol>
</li>
<li><p>释放WakeLock：<code>release()</code></p></li>
<li><p>判断是否已经获取WakeLock：<code>boolean isHeld()</code></p></li>
<li><p><code>void setReferenceCounted(boolean value)</code>：是否使用引用计数。类似于垃圾回收策略，只是把垃圾回收改成了WakeLock回收。如果value是true的话将启用该特性，如果一个WakeLock acquire了多次也必须release多次才能释放掉。但是如果释放次数比acquire多则会抛出<code>RuntimeException("WakeLock under-locked " + mTag)</code>异常。<strong>默认是开启了引用计数的！</strong></p></li>
</ul>


<h3>PowerManager的几个实用方法</h3>

<ol>
<li><p><code>boolean PowerManager::isScreenOn ()</code>判断屏幕是否亮着（不管是暗的dimed还是正常亮度），在API20被弃用，推荐<code>boolean PowerManager::isInteractive ()</code></p></li>
<li><p><code>void PowerManager::goToSleep(long time)</code>time是时间戳，一般是System.currentTimeMillis()+timeDelay。强制系统立刻休眠，需要Manifest中添加权限<code>"android.permission.DEVICE_POWER"</code>。按下电源键锁屏时调用的就是这个方法。</p></li>
<li><p><code>void PowerManager::wakeUp(long time)</code>与上面对应。参数含义，所需权限与上同。按下电源键解锁屏幕时调用的就是这个方法。</p></li>
<li><p><code>void PowerManager::reboot(String reason)</code>重启手机，reason是要传给linux内核的参数，比如“recovery”重启进recovery模式，“fastboot”重启进fastboot模式。需要权限<code>"android.permission.REBOOT"</code>。</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[安卓监听新收到短信]]></title>
    <link href="http://LanderlYoung.github.io/blog/2014/09/30/an-zhuo-jian-ting-xin-shou-dao-duan-xin/"/>
    <updated>2014-09-30T11:52:25+08:00</updated>
    <id>http://LanderlYoung.github.io/blog/2014/09/30/an-zhuo-jian-ting-xin-shou-dao-duan-xin</id>
    <content type="html"><![CDATA[<p>安卓收到短信的事件是由系统发一个有序广播的，所以这里需要一个BroadcastReceiver。receiver收到的Intent里面并不是直接存储的短信内容，而是短信的原始数据。所以我们需要自己解码。</p>

<p><strong>获取短信的原始数据：</strong>
原始数据被叫做<a href="http://en.wikipedia.org/wiki/Protocol_data_unit">PDU</a>，一个PDU就是一个数据段，如果短信比较长的话可能是由几个PDU组成的。</p>

<pre><code class="java">@Override
public void onReceive(Context context, Intent intent) {
    //监听到验证码短信后自动填写验证码
    Log.i(TAG, "SMSBroadcastReceiver SMS_RECEIVED");
    Bundle smsBundle = intent.getExtras();

    if (smsBundle != null) {
        Object[] pdus = (Object[]) smsBundle.get("pdus");
    }
}
</code></pre>

<!--more-->


<p>上面的<code>smsBundle.get("pdus")</code>返回的实际类型是<code>byte[][]</code>，二位数组的每一个子数组就是一个pdu。</p>

<p><strong>解码短信内容：</strong>
这里主要使用到的是<a href="http://developer.android.com/reference/android/telephony/SmsMessage.html#createFromPdu(byte[])"><code>SmsMessage.createFromPdu</code></a>方法。</p>

<pre><code class="java">private String parseMessageFromRawData(Object[] pdus) {
    if (pdus == null) return null;

    try {
        StringBuilder message = new StringBuilder();
        for (Object pdu : pdus) {
            SmsMessage smsMessage = SmsMessage.createFromPdu((byte[]) pdu);
            if (smsMessage == null) continue;
            message.append(smsMessage.getDisplayMessageBody());
        }
        return message.toString();
    } catch (Exception e) {
        Log.e(TAG, "SMSBroadcastReceiver read sms failed", e);
    } catch (OutOfMemoryError oom) {
        Log.e(TAG, "SMSBroadcastReceiver caused OOM =_=!", oom);
        //为了避免后续操作出现问题，gc一下
        System.gc();
        System.gc();
    }
    return null;
}
</code></pre>

<p>上面的重点就是<code>SmsMessage smsMessage = SmsMessage.createFromPdu((byte[]) pdu);</code>这一句了。需要注意的是这个操作容易导致OOM（已经有好多Crash上报了。。。），所以要特别处理一下。</p>

<p><strong>另外：</strong>
上面的<a href="http://developer.android.com/reference/android/telephony/SmsMessage.html#createFromPdu(byte[])"><code>SmsMessage.createFromPdu</code></a>方法已经被官方文档说明即将被废弃（deprecated）原因是为了同时支持<a href="http://en.wikipedia.org/wiki/3GPP">3GPP</a>和<a href="http://en.wikipedia.org/wiki/3GPP2">3GPP2</a>，他们是移动系统通信标准的拟定组织分别拟定了<code>GSM/UMTS/LTE</code>标准和<code>CDMA/LTE</code>标准。因此推荐是用的方法是<code>createFromPdu(byte[] pdu, String format)</code>其中fotmat可以是<code>SmsConstants.FORMAT_3GPP</code>或者<code>SmsConstants.FORMAT_3GPP2</code>。</p>

<p>出于好奇我看了一眼<a href="http://developer.android.com/reference/android/telephony/SmsMessage.html#createFromPdu(byte[])"><code>SmsMessage.createFromPdu</code></a>的代码实现，发现他本身就做了制式判断的（=_=!），代码写的还是不错的，粘出来。万一以后这个方法被废弃了，还有个参考。</p>

<pre><code class="java">public static SmsMessage createFromPdu(byte[] pdu) {
     SmsMessage message = null;

    // cdma(3gpp2) vs gsm(3gpp) format info was not given,
    // guess from active voice phone type
    int activePhone = TelephonyManager.getDefault().getCurrentPhoneType();
    String format = (PHONE_TYPE_CDMA == activePhone) ?
            SmsConstants.FORMAT_3GPP2 : SmsConstants.FORMAT_3GPP;
    message = createFromPdu(pdu, format);

    if (null == message || null == message.mWrappedSmsMessage) {
        // decoding pdu failed based on activePhone type, must be other format
        format = (PHONE_TYPE_CDMA == activePhone) ?
                SmsConstants.FORMAT_3GPP : SmsConstants.FORMAT_3GPP2;
        message = createFromPdu(pdu, format);
    }
    return message;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[安卓中传感器的使用]]></title>
    <link href="http://LanderlYoung.github.io/blog/2014/09/10/an-zhuo-zhong-chuan-gan-qi-de-shi-yong/"/>
    <updated>2014-09-10T10:12:22+08:00</updated>
    <id>http://LanderlYoung.github.io/blog/2014/09/10/an-zhuo-zhong-chuan-gan-qi-de-shi-yong</id>
    <content type="html"><![CDATA[<p>由于需要一个像系统电话应用那样：打电话时可以使屏幕黑掉，手机离开时又能使屏幕亮起来的功能。所以需要能够获取「接近传感器」的数据。</p>

<p>Android中的传感器只是一个抽象，它可能是硬件传感器，也可能是通过软件模拟的一个传感器。但是不管哪一种，对程序员来说都是一样的。</p>

<p>Android中的传感器分为两类：</p>

<ul>
<li><p>连续性的传感器 比如：接近传感器，加速度传感器等。可以连续的反馈数据</p></li>
<li><p>触发性的传感器 比如：significant motion sensor（好吧，我不知道他是啥；看名字貌似是监听用户的什么动作的）。总之就是那种会再特定情况下触发的传感器。</p></li>
</ul>


<!--more-->


<p>Sensor的使用过程如下：</p>

<pre><code class="java">public class SensorActivity extends Activity implements SensorEventListener {
    private final SensorManager mSensorManager;
    private final Sensor mAccelerometer;

    public SensorActivity() {
        //获取SensorManager
        mSensorManager = (SensorManager) getSystemService(SENSOR_SERVICE);
        //获取对应的Sensor
        mAccelerometer = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
    }

    protected void onResume() {
        super.onResume();
        //注册一个Sensor的监听器，监听器的回调函数是在主线程中被调用的，因此要尽量避免阻塞主线程！
        mSensorManager.registerListener(this, mAccelerometer, SensorManager.SENSOR_DELAY_NORMAL);
    }

    protected void onPause() {
        super.onPause();
        //取消注册一个Sensor的监听器
        mSensorManager.unregisterListener(this);
    }

    /**
     * SensorEventListener的回调方法
     *
     * @param sensor
     * @param accuracy
     */
    @Override
    public void onAccuracyChanged(Sensor sensor, int accuracy) {
    }

    /**
     * SensorEventListener的回调方法
     *
     * @param event
     */
    @Override
    public void onSensorChanged(SensorEvent event) {
        float[] values = event.values;
        /**
         * 这是传感器传送来的数据，根据不同的传感器，其值和数组长度会有所不同。
         */
    }
}
</code></pre>

<p>上面的注册监听器是针对以连续性的传感器，如果是触发性的传感器相应的换成：</p>

<ul>
<li><p>注册： <a href="http://developer.android.com/reference/android/hardware/SensorManager.html#requestTriggerSensor(android.hardware.TriggerEventListener,%20android.hardware.Sensor"><code>boolean SensorManager::requestTriggerSensor(TriggerEventListener listener, Sensor sensor)</code></a></p></li>
<li><p>取消注册：<a href="http://developer.android.com/reference/android/hardware/SensorManager.html#cancelTriggerSensor(android.hardware.TriggerEventListener,%20android.hardware.Sensor"><code>boolean SensorManager::cancelTriggerSensor(TriggerEventListener listener, Sensor sensor)</code></a></p></li>
<li><p>监听器：<a href="http://developer.android.com/reference/android/hardware/TriggerEventListener.html"><code>TriggerEventListener</code></a></p></li>
</ul>


<p>上面registerListener中最后一个参数是传感器的频率，频率越高单位时间内数据采集就越多，相应的也就更费电！频率从高到低分别是：</p>

<ol>
<li><p><code>SensorManager.SENSOR_DELAY_FASTEST</code> : 获取数据尽可能的快</p></li>
<li><p><code>SensorManager.SENSOR_DELAY_GAME</code> : 适合游戏的频率</p></li>
<li><p><code>SensorManager.SENSOR_DELAY_NORMAL</code>： 正常的频率，一般实时性要求不高都可以用这个设定。</p></li>
<li><p><code>SensorManager.SENSOR_DELAY_UI</code>：适合普通用户界面的平率。由于频率低，所以，延时大，但是也会更省电。</p></li>
</ol>

]]></content>
  </entry>
  
</feed>
