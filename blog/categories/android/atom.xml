<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: android | Young_Blog]]></title>
  <link href="http://LanderlYoung.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://LanderlYoung.github.io/"/>
  <updated>2015-04-05T01:54:39+08:00</updated>
  <id>http://LanderlYoung.github.io/</id>
  <author>
    <name><![CDATA[LanderlYoung]]></name>
    <email><![CDATA[landerlyoung@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android中service的使用]]></title>
    <link href="http://LanderlYoung.github.io/blog/2014/11/09/androidzhong-servicede-shi-yong/"/>
    <updated>2014-11-09T18:07:03+08:00</updated>
    <id>http://LanderlYoung.github.io/blog/2014/11/09/androidzhong-servicede-shi-yong</id>
    <content type="html"><![CDATA[<h2>Android 中service的使用 笔记</h2>

<h3>Service是何物</h3>

<p>service是安卓四大组件（Activity、BroadcastReceiver、ContentProvider、Service）之一。Service用于执行耗时比较长的操作，在后台运行，没有界面显示。</p>

<p><strong>Service与进程</strong>：<br/>
Service可以在应用的主进程中运行，也可以在单独的进程中运行。只需要在Service的[Manifest声明][manifest]中指明进程名即可。同一个应用中所有具有相同进程名的组件（四大组件，包括Activity）均可以运行在同一个进程中。</p>

<p><strong>Service的寿命</strong>： <br/>
这里说的<code>寿命</code>只是service什么时候运行什么时候终止而已并非生命周期的概念。service的启动方式有两种：<br/>
 1. 通过<code>Context::strtService</code>来启动一个Service，这个Service会一直在后台运行，即使启动该Service的组件已经结束。它只能自己结束自己，通过<code>Service::stopSelf()</code>或者是被其他组件显示的结束，通过<code>Context::StopService</code>。或者系统可用内存不够，android系统会选择性的kill掉一些service，在需要的时候再重新启动他们。当然如果进程自己crash也是会结束的(╯‵□′)╯︵┻━┻（这不是废话）。 <br/>
 2. 通过<code>Context::bindService</code>启动Service。一个绑定的Service一般是 C-S（客户端-服务器）类型的，通常会和其他组件进行通信，包括：发送请求，收取返回结果，甚至是进程间通信——IPC。一个绑定的Service的寿命和绑定他的组件相关，当所有绑定到他上面的组件都结束（或者取消绑定——通过<code>Context::unbindService</code>方法）的时候，这个service就自然结束。</p>

<!--more-->


<p>当然启动一个Service还可以同时用上面两个方法：先startService启动一个常驻service，然后bind到他上面进行通信——IPC。</p>

<blockquote><p>Service运行在进程的主线程上。所以如果要执行长耗时或CPU高消耗任务的话还是要自行创建线程，以免阻塞主进程导致service的声明周期方法不能及时回调。</p></blockquote>

<h3>基础知识：</h3>

<p>创建一个Service时，必须创建一个Service的子类，并覆盖相应的声明周期回调方法，来进行相应的处理。你需要覆盖的最重要的几个声明周期回调是：<br/>
 1. onStartCommand：当其他组件（比如Activity）通过startService方法启动Service的时候，系统就会回调这个方法。一旦这个方法被调用，该service就会永久的运行下去。因此你将有义务来结束这个service，通过service自己调用<code>stopSelf</code>或者在其他组件中调用<code>Context::stopService</code>。如果你只是希望通过bind来启动这个service，则没有什么必要来覆盖这个方法。这个方法有三个参数，第一个是启动这个Service的Intent，第二个是启动Flag，第三个是startID，每次这个方法回调的时候这个ID就会增加一次（保证每次都不一样）。<br/>
 2. onBind：当其他组件调用<code>Context::bindService</code>来绑定到service上的时候，一般会在onBind中返回一个IBinder对象的实例，提供给Client调用Service中的方法。相应的如果不希望客户端绑定到service上就返回<code>null</code>好了。 <br/>
 3. onCreate：和Activity的onCreate一样，在整个生命周期中值调用一次——在service被创建的时候。 <br/>
 4. onDestroy：也是和Activity一样，在整个生命周期中也只调用一次——在service被销毁的时候。这个方法是service中最后一个执行的方法。</p>

<p><strong>重申</strong>：</p>

<blockquote><p>如果Service是通过<code>Context::startService</code>来启动的话，它将一直运行下去，知道他结束自己（通过<code>Service::stopSelf</code>方法）或者其他组件结束掉他（通过<code>Context:stopService</code>方法）。<strong>另外</strong>：即使上面所说两个方法（<code>Service::stopSelf</code>和<code>Context:stopService</code>）已经调用，只要有bind到这个service上的组件没有unbind这个service也不会立即结束。</p></blockquote>

<h3>在Manifest中声明你的service：</h3>

<p>语法如下：</p>

<pre><code class="xml">&lt;service android:enabled=["true" | "false"]
         android:exported=["true" | "false"]
         android:icon="drawable resource"
         android:isolatedProcess=["true" | "false"]
         android:label="string resource"
         android:name="string"
         android:permission="string"
         android:process="string" &gt;
    . . .
&lt;/service&gt;
</code></pre>

<p>上面的attribute和大部分的组件都是一样的。<br/>
 1. <code>android:isolatedProcess</code>：如果是true的话这个service将运行在一个隔离的特殊进程中，并且不具备任何权限（包括你在Manifest中声明的）。唯一能和service通信的方式就是bind和start。
 2. <code>android:process</code>：进程名。就是这个service运行的进程的名字。虽然其他三个组件也可以指定进程名，但是service才是真正需要这个属性的组件！因为一些进程往往需要长时间运行，在主进程之外运行。
     1. 如果不指定这个属性的话，组件将在默认进程中执行，进程名就是包名。<br/>
     2. 如果指定了进程名，则运行在指定的进程中，其他组件也可以访问该service，只要满足service指定的权限。
     3. 特殊情况：如果进程名以「冒号」开头（<code>:</code>），则该service是应用私有的service，其他应用不能访问到。</p>

<p>**bindService和unbindService：
bind和onBind必须成对出现，否则service不会终止。加入你的onBind卸载activity的onDestroy中，然后activity被系统终止而没有调用onDestroy，此时系统会帮你调用onBind并log一个warnning警告你！<br/>
<code>boolean bindService(Intent service, ServiceConnection conn, int flags)</code>:其中intent是启动service的Intent，conn是回调。定义是：</p>

<pre><code class="java">public interface ServiceConnection {
    //service连接成功时的回调，IBinder就是service返回的Binder
    public void onServiceConnected(ComponentName name, IBinder service);
    //service**意外**终止时的回调，一般是service进程crash或者被系统杀掉。他并不会关闭与service的连接。
    public void onServiceDisconnected(ComponentName name);
}
</code></pre>

<p><code>public void unbindService(ServiceConnection conn)</code>:unbind中有个conn参数，就是你在bind是传入的那个回调。</p>

<h3>Android中的进程间通信——IPC</h3>

<p>这个是一个很精彩的内容，用过android的ipc机制才发现<strong>IPC从未如此简单！</strong>。</p>

<h4>Android Interface Definition Language (AIDL)</h4>

<p>android的IPC通过<code>aidl</code>文件来指定接口，aidl的含义是「Android Interface Definition Language 」，其使用了一种很类似java的语法来制定IPC接口。<br/>
<a name="aidl_chestnut">举个栗子</>，比如在com.example.service包中，写一个aidl文件，内容如下：</p>

<pre><code class="java">package com.example.service;

import com.example.service.ICallback;
import android.os.Bundle;

interface IDemoServiceController {
    int getPid();
    int add(int a, int b);
    void causeToStop();
    void paramInAndOut(in Bundle bundleIn, out Bundle bundleOut, inout Bundle bundleInOut);
}
</code></pre>

<p>可以看到基本上和JAVA一模一样！<br/>
<strong>需要注意</strong>：<br/>
 1. AIDL支持的数据类型<a name="aidl_types"></>：<br/>
     1. <a href="#aidl_default_type">AIDL默认支持的数据类型</a><br/>
     2. <a href="#parcelable">实现了Parcelable接口</a>任意类<br/>
 2. 另外你必须import所有使用到的class到你的AIDL文件中，即使他跟你的aidl文件在同一个包中！<br/>
 3. 方法可以有0到多个参数，也可以返回void。<br/>
 4. 参数中的所有的非java原始类型（必须指定一个参数的数据走向，是<code>int</code>，<code>out</code>，<code>inout</code>，三者之一）。<br/>
 5. 参数中的所有的原始类型都是in，而且不能被修改。</p>

<p><a name="aidl_default_type"></a>AIDL默认支持的数据类型如下：</p>

<ol>
<li><p>java语言中的所有原始类型（primitive type，比如：int, long, char, boolean)</p></li>
<li><p>String</p></li>
<li><p>CharSequence</p></li>
<li><p>支持数组！虽然文档没说，但经过实验证明是支持数组的。但是数组的元素必须是AIDL所支持的<a href="#aidl_types">数据类型</a>。</p></li>
<li><p>List <strong>注意</strong></p>

<ol>
<li>List中的所有类型也必须是AIDL所支持的<a href="#aidl_types">数据类型</a>。</li>
<li>List可以被当做泛型类来使用（比如<code>List&lt;String&gt;</code>）。</li>
<li>接收参数的另一端（对于client，另一端指service；对于service另一端指  client）收到的List实际类型总是ArrayList。</li>
</ol>
</li>
<li><p>Map <strong>注意</strong></p>

<ol>
<li>Map所支持的类型同上。</li>
<li>泛型Map并不支持。</li>
<li>接收参数的另一端接收到的Map实际类型是HashMap。</li>
</ol>
</li>
</ol>


<h4>实现Parcelable接口</h4>

<p>因为实例是要在进程间传递的因此必须序列化才行。Parcelable就是android定义的一个用于class序列化的即轻量级又高效的机制。<br/>
Parcelable接口的定义如下：</p>

<pre><code class="java">public interface Parcelable {
    public int describeContents();
    public void writeToParcel(Parcel dest, int flags);
    public interface Creator&lt;T&gt; {
        public T createFromParcel(Parcel source);
        public T[] newArray(int size);
    }
}
</code></pre>

<p>其中<code>describeContents()</code>用于描述数据类型，可以简单的返回0。
然后是用于序列化的方法<code>writeToParcel(Parcel dest, int flags)</code>：<br/>
dest就是用于存储序列的类的容器，然后flags可以是普通的0，或者是<code>PARCELABLE_WRITE_RETURN_VALUE</code>用来告诉你这个object是被写回返回值的（比如下列方法中  <code>Parcelable someFunction()</code>, <code>void someFunction(out Parcelable)</code>, or <code>void someFunction(inout Parcelable)</code>），以此来告诉你该清理资源就赶紧的！</p>

<p>然后问题来了：怎么只有序列化没有反序列化！这只出不进不是要弹尽粮绝（<del>精尽人亡</del>）吗？！<br/>
好了，Parcelable接口是有魔力的，他并不是一个普通的接口。android规定，要实现这个接口除了实现上面两个接口还要在类中定义一个static成员变量，名字必须叫“CREATOR”（此处需要注意配置proguard混淆，很明显android会用反射来获取这个变量，<del>忍不住吐槽一句！google你怎么那么喜欢反射！！</del>），然后这个CREATOR必须是<code>Parcelable.Creator&lt;T&gt;</code>的实现，android系统将使用这个实例来进行反序列化。</p>

<p>举个栗子（盗自android文档Parcelable篇）：</p>

<pre><code class="java">public class MyParcelable implements Parcelable {
     private int mData;

     public int describeContents() {
         return 0;
     }

     public void writeToParcel(Parcel out, int flags) {
         out.writeInt(mData);
     }

     public static final Parcelable.Creator&lt;MyParcelable&gt; CREATOR
             = new Parcelable.Creator&lt;MyParcelable&gt;() {
         public MyParcelable createFromParcel(Parcel in) {
             return new MyParcelable(in);
         }

         public MyParcelable[] newArray(int size) {
             return new MyParcelable[size];
         }
     };

     private MyParcelable(Parcel in) {
         mData = in.readInt();
     }
 }
</code></pre>

<h4>在Client和Service端调用aidl指定的方法</h4>

<p>android sdk tool会自动根据aidl文件生成相应的java文件。因此可以直接使用之。</p>

<p><strong>在server端</strong><br/>
前面说过onBind方法会返回一个IBinder的实例给client调用。这里返回的IBinder实例就和你的aidl有关。你需要在server中实现aidl中指定的接口的实现，还举<a href="#aidl_chestnut">刚才的栗子</a>。你需要在server中这样：</p>

<pre><code class="java">private class MyBinder extends IDemoServiceController.Stub {
        @Override
        public int getPid() throws RemoteException {
            return android.os.Process.myPid();
        }

        @Override
        public int add(int a, int b) throws RemoteException {
            return a + b;
        }

        @Override
        public void causeToStop() throws RemoteException {
            log("causeToStop");
            stopSelf();
        }

        @Override
        public boolean addCallback(ICallback callback) throws RemoteException {
            clientCallback = callback;
            return true;
        }

        @Override
        public void invokeCallback() throws RemoteException {
            if (clientCallback != null) {
                clientCallback.call(0);
            }
        }

        @Override
        public void paramInAndOut(Bundle[] bundleIn, Bundle bundleOut) throws RemoteException {

        }
    }
</code></pre>

<p>其中的Stub是aldi工具自动生成的，<a href="#aidl_implements">等会</a>详细说为啥要继承自他而不是自己实现Interface即可。然后你在onBinde中返回这个实现的实例即可：</p>

<pre><code>private IBinder mBinder = new MyBinder();
public IBinder onBind(Intent intent) {
    log("onBind");
    return mBinder;
}
</code></pre>

<p><strong>client端</strong>：
记得上面说的bindService的回调吗在<code>onServiceConnected</code>中：</p>

<pre><code class="java">public void onServiceConnected(ComponentName name, IBinder service) {
    log("service name:" + name);
    mDemoServiceBinder = IDemoServiceController.Stub.asInterface(service);
}
</code></pre>

<p>是的，这里还是要用那个Stub。然后你只需要在Client中调用mDemoServiceBinder 中的所有方法即可。因为Stub是实现了AIDL中的接口的，所以它提供给你了你定义的所有方法。<br/>
<strong>需要注意</strong>：AIDL中定义的方法会抛出RemoteException，所以记得捕获之。</p>

<h3>好奇：“AIDL是怎么实现跨进程方法调用的  ”</h3>

<p>这里点很类似于java EE中的RMI（Remote Method Invoke）。但是比他轻量级，简单，方便。想知道android中怎么实现RMI的，不妨从上面用的的神器Stub入手。于是我们就打开了sdk tool从aidl生成的java文件。看看Stub到底长啥样！！</p>

<pre><code class="java">public static abstract class Stub extends android.os.Binder implements com.example.service.IDemoServiceController {
    private static final java.lang.String DESCRIPTOR = "com.example.service.IDemoServiceController";

    /**
     * Construct the stub at attach it to the interface.
     */
    public Stub() {
        this.attachInterface(this, DESCRIPTOR);
    }

    /**
     * Cast an IBinder object into an com.example.service.IDemoServiceController interface,
     * generating a proxy if needed.
     */
    public static com.example.service.IDemoServiceController asInterface(android.os.IBinder obj) {
        if ((obj == null)) {
            return null;
        }
        android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);
        if (((iin != null) &amp;&amp; (iin instanceof com.example.service.IDemoServiceController))) {
            return ((com.example.service.IDemoServiceController) iin);
        }
        return new com.example.service.IDemoServiceController.Stub.Proxy(obj);
    }

    @Override
    public android.os.IBinder asBinder() {
        return this;
    }

    @Override
    public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException {
        switch (code) {
            case INTERFACE_TRANSACTION: {
                reply.writeString(DESCRIPTOR);
                return true;
            }
            case TRANSACTION_paramInAndOut: {
                    data.enforceInterface(DESCRIPTOR);
                    android.os.Bundle _arg0;
                    if ((0 != data.readInt())) {
                        _arg0 = android.os.Bundle.CREATOR.createFromParcel(data);
                    } else {
                        _arg0 = null;
                    }
                    android.os.Bundle _arg1;
                    _arg1 = new android.os.Bundle();
                    this.paramInAndOut(_arg0, _arg1);
                    reply.writeNoException();
                    if ((_arg1 != null)) {
                        reply.writeInt(1);
                        _arg1.writeToParcel(reply, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
                    } else {
                        reply.writeInt(0);
                    }
                    return true;
                }
        }
        return super.onTransact(code, data, reply, flags);
    }

    private static class Proxy implements com.example.service.IDemoServiceController { ... }

    ...
    static final int TRANSACTION_paramInAndOut = (android.os.IBinder.FIRST_CALL_TRANSACTION + 3);
    ...

}
</code></pre>

<p>所以说Stub是个抽象类，继承自Binder，实现了AIDL接口，我们在service端就是直接实现的这个类。在Stub有很长的一个方法叫<code>onTransact</code>他是Binder的方法，从上面可以看到（为了篇幅删了好几个case）。然后在case里面才调用到了aidl接口的实现，对边找一个case看看，会发现他是从Parcel中获取参数，然后调用真正的方法实现，最后在把返回值写回parcel。所以可以看到如果client调用某个方法，系统会调用service的onTransact。所以RMI最主要的还是数据（参数，返回值，Exception）的传输。</p>

<p>注意到Client中是把<code>onServiceConnection</code>返回的IBinder通过Stub的<code>asInterface</code>方法获取的ALDI实现，于是去看看<code>asInterface</code>是干嘛的。有点复杂，总之看最后一句<code>return new com.example.service.IDemoServiceController.Stub.Proxy(obj);</code>!哦！Stub里还有个Proxy类。所以我们最后拿到的是Proxy的实例咯。</p>

<p>其实从名字（Proxy）可以知道他是干啥的，就是个代理嘛，用到了面向对象的Proxy设计模式。所以我们在Client中调用的所有方法都是由Proxy实现的，于是看看Proxy。</p>

<p>举个栗子呗：</p>

<pre><code class="java">@Override
public int paramInAndOut(android.os.Bundle bundleIn, android.os.Bundle bundleOut) throws android.os.RemoteException {
    android.os.Parcel _data = android.os.Parcel.obtain();
    android.os.Parcel _reply = android.os.Parcel.obtain();
    int _result;
    try {
        _data.writeInterfaceToken(DESCRIPTOR);
        if ((bundleIn != null)) {
            _data.writeInt(1);
            bundleIn.writeToParcel(_data, 0);
        } else {
            _data.writeInt(0);
        }
        mRemote.transact(Stub.TRANSACTION_paramInAndOut, _data, _reply, 0);
        _reply.readException();
        _result = _reply.readInt();
        if ((0 != _reply.readInt())) {
            bundleOut.readFromParcel(_reply);
        }
    } finally {
        _reply.recycle();
        _data.recycle();
    }
    return _result;
}
</code></pre>

<p>吼吼吼，所以就是把参数写进Parcel，调用Binder的transact，再从返回的parcel中取得数据，最后返回。其中readException会捕获service中抛出的异常，然后丢回给client。</p>

<h3>附录——Service回调Client</h3>

<p>通过AIDL可以很方便的让client调用service的方法，但是有时候service需要回调Client。（比如报告任务的进度从而更新进度条。）</p>

<p>最简单粗暴的方式就是发广播！这个方法怎么样？好啊！真的不错，但是不够轻量级吧。而且有点不够方便。</p>

<blockquote><p>有没有像AIDL中Client调Service中的方法呢，还是那样方便呀！
答案是：<strong>有！</strong></p></blockquote>

<p>好了，关子卖完了。说正事！</p>

<p>这里需要定义一个回调函数的AIDL接口（比如 &ldquo;ICallback.aidl&#8221;），然后还要在Client——Service通信的AIDL中添加类似<code>boolean addCallback(in ICallback callback);</code>、<code>void invokeCallback();</code>的方法。</p>

<p>然后你在Client实现一个<code>ICallback.Stub</code>类，在<code>addCallback</code>中把他传给service，service收到之后存下来，当你调用<code>invokeCallback</code>的时候service就会调用刚才传进来的callback。</p>

<p>栗子——Client:</p>

<pre><code class="java">private ICallback mServiceCallback = new ICallback.Stub() {
    @Override
    public void call(int code) {
        log("pid:" + android.os.Process.myPid());
        mStartServiceButton.setBackgroundColor(Color.parseColor("#ff00ff"));
    }
};

if (mDemoServiceBinder != null) {
    try {
        mDemoServiceBinder.addCallback(mServiceCallback);
        log("add 1 + 2 = " + mDemoServiceBinder.add(1, 2));
    } catch (RemoteException e) {
        log("add 1 + 2 reveived remoteexception" + e.toString());
    }
} else {
    log("not binded yet");
}
</code></pre>

<p>栗子——Service：</p>

<pre><code class="java">private class MyBinder extends IDemoServiceController.Stub {
...
    @Override
    public boolean addCallback(ICallback callback) throws RemoteException {
        clientCallback = callback;
        return true;
    }

    @Override
    public void invokeCallback() throws RemoteException {
        if (clientCallback != null) {
            clientCallback.call(0);
        }
    }
...
}
</code></pre>

<p>很简单，就酱！</p>

<h3>参考资料</h3>

<p>[API Guide——Service]：<a href="http://developer.android.com/guide/components/services.html">http://developer.android.com/guide/components/services.html</a></p>

<p>[API Guide——AIDL]: <a href="http://developer.android.com/guide/components/aidl.html">http://developer.android.com/guide/components/aidl.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[安卓监听新收到短信]]></title>
    <link href="http://LanderlYoung.github.io/blog/2014/09/30/an-zhuo-jian-ting-xin-shou-dao-duan-xin/"/>
    <updated>2014-09-30T11:52:25+08:00</updated>
    <id>http://LanderlYoung.github.io/blog/2014/09/30/an-zhuo-jian-ting-xin-shou-dao-duan-xin</id>
    <content type="html"><![CDATA[<p>安卓收到短信的事件是由系统发一个有序广播的，所以这里需要一个BroadcastReceiver。receiver收到的Intent里面并不是直接存储的短信内容，而是短信的原始数据。所以我们需要自己解码。</p>

<p><strong>获取短信的原始数据：</strong>
原始数据被叫做<a href="http://en.wikipedia.org/wiki/Protocol_data_unit">PDU</a>，一个PDU就是一个数据段，如果短信比较长的话可能是由几个PDU组成的。</p>

<pre><code class="java">@Override
public void onReceive(Context context, Intent intent) {
    //监听到验证码短信后自动填写验证码
    Log.i(TAG, "SMSBroadcastReceiver SMS_RECEIVED");
    Bundle smsBundle = intent.getExtras();

    if (smsBundle != null) {
        Object[] pdus = (Object[]) smsBundle.get("pdus");
    }
}
</code></pre>

<!--more-->


<p>上面的<code>smsBundle.get("pdus")</code>返回的实际类型是<code>byte[][]</code>，二位数组的每一个子数组就是一个pdu。</p>

<p><strong>解码短信内容：</strong>
这里主要使用到的是<a href="http://developer.android.com/reference/android/telephony/SmsMessage.html#createFromPdu(byte[])"><code>SmsMessage.createFromPdu</code></a>方法。</p>

<pre><code class="java">private String parseMessageFromRawData(Object[] pdus) {
    if (pdus == null) return null;

    try {
        StringBuilder message = new StringBuilder();
        for (Object pdu : pdus) {
            SmsMessage smsMessage = SmsMessage.createFromPdu((byte[]) pdu);
            if (smsMessage == null) continue;
            message.append(smsMessage.getDisplayMessageBody());
        }
        return message.toString();
    } catch (Exception e) {
        Log.e(TAG, "SMSBroadcastReceiver read sms failed", e);
    } catch (OutOfMemoryError oom) {
        Log.e(TAG, "SMSBroadcastReceiver caused OOM =_=!", oom);
        //为了避免后续操作出现问题，gc一下
        System.gc();
        System.gc();
    }
    return null;
}
</code></pre>

<p>上面的重点就是<code>SmsMessage smsMessage = SmsMessage.createFromPdu((byte[]) pdu);</code>这一句了。需要注意的是这个操作容易导致OOM（已经有好多Crash上报了。。。），所以要特别处理一下。</p>

<p><strong>另外：</strong>
上面的<a href="http://developer.android.com/reference/android/telephony/SmsMessage.html#createFromPdu(byte[])"><code>SmsMessage.createFromPdu</code></a>方法已经被官方文档说明即将被废弃（deprecated）原因是为了同时支持<a href="http://en.wikipedia.org/wiki/3GPP">3GPP</a>和<a href="http://en.wikipedia.org/wiki/3GPP2">3GPP2</a>，他们是移动系统通信标准的拟定组织分别拟定了<code>GSM/UMTS/LTE</code>标准和<code>CDMA/LTE</code>标准。因此推荐是用的方法是<code>createFromPdu(byte[] pdu, String format)</code>其中fotmat可以是<code>SmsConstants.FORMAT_3GPP</code>或者<code>SmsConstants.FORMAT_3GPP2</code>。</p>

<p>出于好奇我看了一眼<a href="http://developer.android.com/reference/android/telephony/SmsMessage.html#createFromPdu(byte[])"><code>SmsMessage.createFromPdu</code></a>的代码实现，发现他本身就做了制式判断的（=_=!），代码写的还是不错的，粘出来。万一以后这个方法被废弃了，还有个参考。</p>

<pre><code class="java">public static SmsMessage createFromPdu(byte[] pdu) {
     SmsMessage message = null;

    // cdma(3gpp2) vs gsm(3gpp) format info was not given,
    // guess from active voice phone type
    int activePhone = TelephonyManager.getDefault().getCurrentPhoneType();
    String format = (PHONE_TYPE_CDMA == activePhone) ?
            SmsConstants.FORMAT_3GPP2 : SmsConstants.FORMAT_3GPP;
    message = createFromPdu(pdu, format);

    if (null == message || null == message.mWrappedSmsMessage) {
        // decoding pdu failed based on activePhone type, must be other format
        format = (PHONE_TYPE_CDMA == activePhone) ?
                SmsConstants.FORMAT_3GPP : SmsConstants.FORMAT_3GPP2;
        message = createFromPdu(pdu, format);
    }
    return message;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一次对非静态内部类引用final变量的研究]]></title>
    <link href="http://LanderlYoung.github.io/blog/2014/08/10/yi-ci-dui-fei-jing-tai-nei-bu-lei-yin-yong-finalbian-liang-de-yan-jiu/"/>
    <updated>2014-08-10T13:57:38+08:00</updated>
    <id>http://LanderlYoung.github.io/blog/2014/08/10/yi-ci-dui-fei-jing-tai-nei-bu-lei-yin-yong-finalbian-liang-de-yan-jiu</id>
    <content type="html"><![CDATA[<p>前几天遇到一个奇怪的问题，问题的起因是我把以前的RingfriendDialogBuilder（以下简称builder，没有IDE的自动补全打完全名还是很长的。。）修改了一下，添加了一个clear()方法。目的是避免每次创建一个Dialog都new一个builder的实例，这样一个builder可以用于创建多个dialog，以提高效率。接下来的问题就是因为这个修改导致的。</p>

<!--more-->


<h2>描述现象</h2>

<p>这个DialogBuilder允许构建Dialog，set其中的标题，监听器之类的变量。然后clear掉所有设置，重新再重新构建一个Dialog。问题出现在构建的多个（> 1）Dialog之后，当某个Dialog显示出来时，点击其按钮时，会出现NullPointerException。</p>

<h2>定位Bug：</h2>

<p>起初我觉得这很奇怪，因为每一个Dialog明明都设置了回调函数的呀。然后看到create方法其中一个setOnClickListener的代码段。
因为Dialong中的内容是普通的View，而Dialog的Listener与View的Listener不同，因此代码中做了如下adapt：</p>

<p><a name="anonymousClass"></a>
<code>java
if (mNegativeButtonLinstener != null) {
    negBtn.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
        mNegativeButtonLinstener.onClick(mDialog, DialogInterface.BUTTON_NEGATIVE);
        }
    });
}
</code>
因为dialog的onclick需要传入dialog自身的引用，所以就很 「随意」的把builder的mDialog成员传了过来，这个mDialog是在create的时候new出来的新的Dialog：</p>

<pre><code class="java">//定义
private Dialog mDialog;
//创建
mDialog = new Dialog(mContext, mTheme);
</code></pre>

<p>此时我突然明白了，因为内部匿名类的onClick回调函数使用了外部类（《java编程思想》中称作 enclosing object that made it）的成员变量 mDialog，所以每次onClick，内部类都会resolve外部类的这个成员变量。然而这是不应该发生的，因为：</p>

<blockquote><p><strong>当一个dialog被create之后，builder还有可能再创建一个dialog，或者builder的clear方法可能被调用，其会恢复所有成员变量至默认值，包括设置mDialog为null。所以当某个dialog的按钮被按下时，外部类的mDialog成员可能已经被修改，而不再对应这个dialog。</strong></p></blockquote>

<h2>解决方案</h2>

<p>解决的思路很简单，就是在onClick的<a href="#anonymousClass">内部类</a>中把dialog「定死」，不因成员变量mDialog的变化为转移！这时突然想起来匿名类引用局部变量是必须给局部变量加final修饰符的问题，于是就有了以下解决方案：</p>

<p>在create中声明一个变量
<code>java
final Dialog d = mDialog;
</code>
然后下面需要传入mDialog的地方全部使用d代替。于是问题就顺利的解决了！</p>

<h2>思考</h2>

<p>对于上面解决方案为什么生效，首先说一下<strong>匿名类引用局部变量为什么必须声明final，为什么引用外部类的成员变量又不需要是final</strong>。</p>

<p>首先：
 1. static修饰的内部类和外部类是不能相互引用的，即内部类不能直接引用外部类的任何非static成员变量。因为static内部类不依赖于外部类就可以创建比如<code>new AlertDialog.Builder</code>是可以成功执行的。
 2. 然内非static的内部类是不能这样new出来的，比如：</p>

<pre><code class="java">public class Outer {
    public A() {
    }
    public class Inner {
        public Inner() {
        }
    }
}
</code></pre>

<p>Inner想要被new出来必须这样做：</p>

<pre><code class="java">Outer outer  = new Outer();
Outer.Inner inner = outer.new Inner();

/*
 * can not pass compile, the compiler would complain
 */
 //Outer.Inner inner = new Outer.Inner();
</code></pre>

<p>那么为什么非静态内部类就可以使用外部类的成员变量了呢，那是因为<strong>内部类会保存一个外部类的引用</strong>。可以通过如下方式在内部类中获取该引用。
<code>java
//in inner class
Outer.this
</code>
怎么样！是不是好熟悉，是不是觉得我用过！没错，就是他！</p>

<p>问题逐渐明朗了，需要说明一件事：<strong>anonymous class肯定全都是非static内部类</strong>。</p>

<p>那么匿名类就可以访问外部类的成员变量，这一点和常识想通。但是匿名类一般是在方法体内被创建的，当匿名类想引用方法体内的变量或者方法的参数时该变量必须声明final才行。这是为什么呢？！</p>

<p>这个说来话长，因为方法的参数，乃至方法内的局部变量都是临时性的，他们储存在栈（stack）中。当方法return的时候他们便不复存在。所以匿名类不可能通过外部类的引用来获取局部变量。
而final修饰的变量是不能修改的，因此内部类并不「引用」这个变量，而是在内部直接copy一下！反正她是不会变的，我copy一下也不会导致不一致的问题。（这里需要说明一个事实，copy一个实例的引用时，并不会copy这个实例，只是copy了「指针」而已！）</p>

<p>所以，结论是：</p>

<blockquote><p><strong>final的作用就是告诉编译器，这个变量不会修改的，内部类想用的话可以自己copy一份过去</strong></p></blockquote>

<p>对于上述的解决方案，因为我们使用了一个final变量代替成员变量，因此内部类会直接使用该final变量的copy，而不像原来那样每次都去resolve外部类的成员，这就保证了这个变量在内部类是「定死」的！</p>

<h2>优化升级</h2>

<p>该才说到，非静态内部类会保留一个外部类的引用。在builder这个实例中，dialog的onclick Listener是builder的内部类，因此该listener会保留Builder的引用。但是builder只是辅助构建Dialog用的，当dialog构造出来之后不应该在和builder保有引用。否则会导致builder不能被垃圾回收掉！
因此做一个修改，把dialog的onclick listener改成静态类，如下：</p>

<pre><code class="java"> if (mPositiveButtonLinstener != null) {
            final DialogInterface.OnClickListener listener = mPositiveButtonLinstener;
            posBtn.setOnClickListener(new DialogButtonOnClickListener(dialog,
                    DialogInterface.BUTTON_POSITIVE,
                    listener));
        }
</code></pre>

<p>其中<code>DialogButtonOnClickListener</code>定义如下：
&#8220;`java
private static class DialogButtonOnClickListener implements View.OnClickListener {
        private Dialog mDialog;
        private int mWhich;
        private DialogInterface.OnClickListener mListener;</p>

<pre><code>    public DialogButtonOnClickListener(
            Dialog dialog,
            int whichButton,
            DialogInterface.OnClickListener l) {

        mDialog = dialog;
        mWhich = whichButton;
        mListener = l;
    }

    @Override
    public void onClick(View v) {
        if (mListener != null &amp;&amp; mDialog != null) {
            mListener.onClick(mDialog, mWhich);

        }

    }
}
</code></pre>

<p>&#8220;`</p>

<h3>[完]</h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android 中的Handler相关源代码浅析]]></title>
    <link href="http://LanderlYoung.github.io/blog/2014/06/24/android-zhong-de-handlerxiang-guan-yuan-dai-ma-qian-xi/"/>
    <updated>2014-06-24T17:01:09+08:00</updated>
    <id>http://LanderlYoung.github.io/blog/2014/06/24/android-zhong-de-handlerxiang-guan-yuan-dai-ma-qian-xi</id>
    <content type="html"><![CDATA[<p>简单用法示例：</p>

<pre><code class="java">//在主线程中
private Handler handler = new Handler() {
    // 处理子线程给我们发送的消息。
    @Override
        public void handleMessage(android.os.Message msg) {
            byte[] data = (byte[])msg.obj;
            Bitmap bitmap = BitmapFactory.decodeByteArray(data, 0, data.length);
            imageView.setImageBitmap(bitmap);
            Log.v("handler", "thread:" + Thread.currentThread().getName() +
                    " msg.target=" msg.getTarget());
            if(msg.what == DOWNLOAD_IMG){
                dialog.dismiss();
            }
        }
}
</code></pre>

<!--more-->


<p>然后开启新的线程，在新的线程里面完成后台任务，任务完成后给这个handler发一个消息让它来处理。因为Handler是在主线程实例化(并且在实例化的时候没有指明Looper)，因此handler的handleMessage方法也是在主线程被调用的。</p>

<p>// 使用Handler Message MessageQueue Looper等方式去访问网络资源的时候，我们必须要开启一个子线程</p>

<pre><code>public class MyThread implements Runnable{
    // 在run方法中完成网络耗时的操作
    @Override
        public void run() {
            HttpClient httpClient = new DefaultHttpClient();
            HttpGet httpGet = new HttpGet(imgPath);
            HttpResponse httpResponse = null;
            try {
                Log.v("debug", "start download picture in thread:" +
                        Thread.currentThread().getName());
                httpResponse = httpClient.execute(httpGet);
                Log.v("debug", "download complete with status code" +
                        httpResponse.getStatusLine().getStatusCode());
                if(200 == httpResponse.getStatusLine().getStatusCode()){
                    byte[] data = EntityUtils.toByteArray(httpResponse.getEntity());
                    // 这里的数据data我们必须发送给UI的主线程，所以我们通过Message的方式来做桥梁。
                    Message message = Message.obtain();
                    message.obj = data;
                    message.what = DOWNLOAD_IMG;
                    handler.sendMessage(message);
                }
            } catch (Exception e) {
                // TODO: handle exception
            }
        }
}
</code></pre>

<p>分析一下整个过程的大致流程,首先从Handler的sendMessage下手：从源代码中看，sendMessage最终会调用到Handler中的sendMessageAtTime。</p>

<pre><code class="java">public boolean sendMessageAtTime(Message msg, long uptimeMillis)
{
    boolean sent = false;
    MessageQueue queue = mQueue;
    if (queue != null) {
        msg.target = this;
        sent = queue.enqueueMessage(msg, uptimeMillis);
    }
    else {
        RuntimeException e = new RuntimeException(
                this + " sendMessageAtTime() called with no mQueue");
        Log.w("Looper", e.getMessage(), e);
    }
    return sent;
}
</code></pre>

<p>看得出来主要做的事情就是把消息的target设置成自己，然后把消息存入到消息队列MessageQueue中去，
接着首先去看看MessageQueue mQueue的定义</p>

<p>在Handler类的最后，既然是final的那初始化一定在构造函数了：
默认构造函数，代码中的注释写道“默认构造函数，把这个handler和当前线程的消息队列联系起来，如果没有（当前线程的消息队列），这个handler就不能接收消息了。</p>

<pre><code>/**
 * Default constructor associates this handler with the queue for the
 * current thread.
 *
 * If there isn't one, this handler won't be able to receive messages.
 */
public Handler() {
    ...
        mLooper = Looper.myLooper();
    if (mLooper == null) {
        throw new RuntimeException(
                "Can't create handler inside thread that has not called Looper.prepare()");
    }
    mQueue = mLooper.mQueue;
    mCallback = null;
}
</code></pre>

<p>使用提供的消息队列，而不是使用默认的。</p>

<pre><code class="java">/**
 * Use the provided queue instead of the default one.
 */
public Handler(Looper looper) {
    mLooper = looper;
    mQueue = looper.mQueue;
    mCallback = null;
}
</code></pre>

<p>从上面两个函数可以看出来消息队列是Looper的，handler的sendMessage只是把Message加到了消息队列去。接着去看看Looper对消息对了mQueue做了什么。</p>

<p>Looper中的MessageQueue的定义如下：</p>

<p>然后是Looper 中的loop方法</p>

<pre><code class="java">/**
 * Run the message queue in this thread. Be sure to call
 * {@link #quit()} to end the loop.
 */
public static void loop() {
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread.");
    }
    final MessageQueue queue = me.mQueue;

    // Make sure the identity of this thread is that of the local process,
    // and keep track of what that identity token actually is.
    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();

    for (;;) {
        Message msg = queue.next(); // might block
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }

        // This must be in a local variable, in case a UI event sets the logger
        Printer logging = me.mLogging;
        if (logging != null) {
            logging.println("&gt;&gt;&gt;&gt;&gt; Dispatching to " + msg.target + " " +
                    msg.callback + ": " + msg.what);
        }

        msg.target.dispatchMessage(msg);

        if (logging != null) {
            logging.println("&lt;&lt;&lt;&lt;&lt; Finished to " + msg.target + " " + msg.callback);
        }

        // Make sure that during the course of dispatching the
        // identity of the thread wasn't corrupted.
        final long newIdent = Binder.clearCallingIdentity();
        if (ident != newIdent) {
            Log.wtf(TAG, "Thread identity changed from 0x"
                    + Long.toHexString(ident) + " to 0x"
                    + Long.toHexString(newIdent) + " while dispatching to "
                    + msg.target.getClass().getName() + " "
                    + msg.callback + " what=" + msg.what);
        }

        msg.recycle();
    }
}
</code></pre>

<p>注意到中间的死循环 <code>for(;;;){...}</code>
以及关键的这一句：</p>

<p>猜测target就是这个message对应处理他的handler，于是我圆润的滚过去看看：
Message中的target是这么定义的：</p>

<p>看来八九不离十了。继续看target赋值的语句：</p>

<p>当然还有各种带有Handler参数的obtain方法，都会给target赋值。
于是看看Handler.dispatchMessage(Message)是做什么的：</p>

<pre><code class="java">public void dispatchMessage(Message msg) {
    if (msg.callback != null) {
        handleCallback(msg);
    } else {
        if (mCallback != null) {
            if (mCallback.handleMessage(msg)) {
                return;
            }
        }
        handleMessage(msg);
    }
}
</code></pre>

<p>如果msg的callback不为null就调用callback，否则如果就看看mCallback有没有设置，如果有的话就让callback来处理消息，如果没有就是用默认的处理方法。默认的处理方法是什么都不多，但是子类如果覆盖了handleMessage方法就可以执行子类想要做的代码了。</p>

<p>但是 事情没有那么简单！还有一个无参数的obtain方法，那么没有指定target的message是怎么成功发送到相应的handler的呢？还是圆润的滚过去看Looper的代码吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SNG迷你项目感悟]]></title>
    <link href="http://LanderlYoung.github.io/blog/2014/06/20/sngmi-ni-xiang-mu-gan-wu/"/>
    <updated>2014-06-20T16:38:32+08:00</updated>
    <id>http://LanderlYoung.github.io/blog/2014/06/20/sngmi-ni-xiang-mu-gan-wu</id>
    <content type="html"><![CDATA[<p>来腾讯实习有半个月来，刚进来公司统一培训了一天半，闲扯了点东西。然后SNG部门培训了3天时间，讲解一些业务流程。然后就是重头戏，所谓的迷你项目。我擦，虽然今天做完了，但是我还是想说这个巨坑啊！</p>

<!--more-->


<p>做这个迷你项目首先要说的是，还真的有点累的。。。每天早上做班车从酒店到公司，然后晚上一边九点走，到最后两天就更夸张了。前天在公司通宵了一夜，昨天夜里也是十二点多才走，欣慰的是腾大东侧的路上出租车排排停，估计我鹅长的员工加班都很积极吧。一个安卓应用，7天时间，两个人做，看这数据都觉得恐怖。</p>

<p>不过最后还是搞定了，尽管没拿奖，但是自己仍然很有成就感。做项目期间还是受到导师同事们的很大帮助的。最后一晚要不是wii帮qiuhang调了一个多小时的bug估计就得继续通宵了，而且说不定通宵了也搞不，那就苦逼了。</p>

<p>因为我做和服务器端的接口工作，当时一边商量一边改。一开始觉得商量接口真麻烦，后来才发现没有事先定义好接口才是做苦逼的。最荒唐的一件事是今天上午mini项目要测评了，结果昨天下午还在找后台的同学加接口。所以说：</p>

<blockquote><p>概要设计真的很重要</p></blockquote>

<p>前天晚上的问题是在电脑上调试完毕的net接口整合到Android上却得不到返回数据，比较奇怪的是有一个房屋信息POST请求能上传，而且数据库里会出现相应信息，但是返回值却是空的。一开始怀疑是没有申请网络访问权限，后来发现不是。后来sponsor Lewis 过来帮我调试，教了我安卓单步调试的方法，但是问题还是没能轻松解决。当天晚上熬了一夜，睡醒了4点，突然灵机一现决定把所有的JSON返回值都Log出来，同时所有的Exeption也要Log出来。后来慢慢调试才发现是<code>NetworkOnMainThreadException</code>！网络跑在主UI线程！所以每次执行到connect的时候android系统都会抛出这个异常，但是我却Too young， sometimes too naive！把所有可能抛出异常的地方都catch (Exception e) {}。就是说catch了所有Exception的父类并且什么也不做！对！就是不作为！后来跟我的导师raez说这件事，他说：</p>

<blockquote><p>异常本来是用来发现问题的，不能随便catch。</p></blockquote>

<p>对此我的理解是，需要catch一个exception的时候<strong>尽量精准catch</strong>。比如一个方法可能抛出IOException就不要懒懒的去直接catch Exception，同时如果抛出多种异常也要一个一个catch;
<code>java
try {
    ...
    } catch (IOException e) {
            e.printStackTrace();
            ...
    } catch (FileNotFoundException ex) {
            e.printStackTrace();
            ...
    }
</code>
同时<strong>捕获一个异常之后不能什么都不做</strong>，至少应该<code>printStackTrace</code>或者是Log出来，否则出现问题之后很难排查出来。另外<code>NullPointerException</code> 原则上不允许catch，<code>OutOfMemoryError</code>除了在大量消耗内存的代码片段上（比图图片处理，或者字符串拼接等）不允许catch。还有就是捕获异常是一定<strong>精准捕获</strong>。</p>

<p>另外关于安卓多线程的使用，学习到了两种方式：Activity的<code>runOnUiThread(Runnable)</code>方法，还有使用AsyncTask类, 另外还有是用Handler之类的方法，当时没有还没有学习。</p>

<p>另外一方面是缺少大型软开发的经验，原来自己写过的代码，最多也就一两千行。导致我们缺乏大型软件框架方面的知识。mini项目的Android端事实上来说就分了两个部分，UI和后台。今天听Wii讲了我们组的项目的大致构架，各个模块的分工功能，模块之间怎么通信回调，瞬间觉得高达上！真的是很开眼界。</p>
]]></content>
  </entry>
  
</feed>
