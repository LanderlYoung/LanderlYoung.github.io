<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: linux | Young_Blog]]></title>
  <link href="http://LanderlYoung.github.io/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://LanderlYoung.github.io/"/>
  <updated>2014-03-25T15:07:59+08:00</updated>
  <id>http://LanderlYoung.github.io/</id>
  <author>
    <name><![CDATA[LanderlYoung]]></name>
    <email><![CDATA[landerlyoung@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[linux fork和exec系列函数]]></title>
    <link href="http://LanderlYoung.github.io/blog/2014/01/13/linux-forkhe-execxi-lie-han-shu/"/>
    <updated>2014-01-13T00:31:29+08:00</updated>
    <id>http://LanderlYoung.github.io/blog/2014/01/13/linux-forkhe-execxi-lie-han-shu</id>
    <content type="html"><![CDATA[<p>linux 中的<a href="http://en.wikipedia.org/wiki/Fork_(system_call)">fork</a>和<a href="http://en.wikipedia.org/wiki/Exec_(operating_system)">exec</a>函数是进程相关的两个函数，最早在大二的操作系统课上了解到。今天要写个小东西偶尔用到就研究了一下。</p>

<h2>1.fork</h2>

<p>fork的功能是创建一个和进程完全一样的子进程。完全的意思是指子进程的堆和栈和父进程是完全相同的。在子进程创建完成时，子进程和父进程共享内存。但是一旦共享的内存区域要被写入时（不管是父进程要写还是子进程要写）这块区域就会从父进程的进程空间复制到子进程，然后再执行写入。这就是通常说的<a href="http://en.wikipedia.org/wiki/Fork_(system_call)">copy on write</a>，目的很明显，就是要节省不必要的内存消耗 。</p>

<!--more-->


<p>这一点在安卓的虚拟机孵化进程zygote被使用，zygote在开机时就把所有系统java类的字节码加载到内存，当一个app启动时zygote就fork一下然后fork的子进程去执行app。这样所有app可以调用系统class而整个系统的内存中只有一份系统类，可以很大程度的节省内存, 同时也加快了app的启动。</p>

<p>linux系统中的所有进程都是init进程fork出来的，查看的话可以发现他的pid是1, 是系统内所有进程的父进程（或者祖先进程）。其实init也有个pid为0的父进程，开机完成后就不存在了，本文不涉及这方面。</p>

<p>fork包含在&lt;unistd.h>头文件中， 其原型是：<code>pid_t fork(void)</code>其中pid_t是进程pid的数据结构，可以被cast成int等类型，当frok成功时在父进程中的返回值是子进程的pid, 子进程中是0, 若没能创建子进程则返回负值。</p>

<p>写个小程序看看：</p>

<p>``` cpp</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;stdlib.h>//for exit()</h1>

<p>int main(void) {</p>

<pre><code>pid_t pid;
printf("parent pid:%d\n", getpid());
if(pid = fork()) {
    // pid != 0, in parent process
    printf("in parent child pid:%d\n", pid);
    exit(0);
}

//in child process
printf("I\'m Child process.\n"
        "My pid :%d, parent pid:%d\n",
        getpid(), getppid());

return 0;
</code></pre>

<p>}
```</p>

<p>编译运行看看</p>

<p><code>cpp
young@Y470:~/Desktop$gcc f.c -o f
young@Y470:~/Desktop$./f
parent pid:8627
in parent child pid:8628
I'm Child process.
My pid :8628,  parent pid:8627
</code>
getpid()返回当前进程的pid，getppid（）返回父进程的pid。</p>

<p>这里在fork之后通过返回值知道自己是父进程还是子进程，然后通过if判断进行流程控制，父、子进程各自执行自己的任务。</p>

<h2>2.exec系列函数</h2>

<p>刚才说道linux系统内所有进程都是init进程的子孙进程，但是可能会让人不解：“这样的话所有进程不都是一样的吗”。这里我们要用到exec系列函数了。</p>

<p>exec系列函数在执行时会首先清空当前进程（调用exec函数的进程）的栈和堆等内存空间。然后创建新的空间。但是进程的pid和父进程等信息不会变。</p>

<p>exec系列函数有一下几个：</p>

<p><code>cpp
int execl(char const *path,  char const *arg0,  ...);
int execle(char const *path,  char const *arg0,  ...,  char const *envp);
int execlp(char const *file,  char const *arg0,  ...);
int execv(char const *path,  char const *argv);
int execve(char const *path,  char const *argv,  char const *envp);
int execvp(char const *file,  char const *argv);
</code></p>

<p>可以看出来他们的后缀不一样，各个后缀的含义是：</p>

<pre>
e - 给函数传入一个环境变量`environment virables`来搜索可执行文件
l - 命令的参数通过函数的参数一一传入`list`方式
p - 使用系统环境变量PATH搜索可执行文件
v - 命令的参数通过一个数组`vector`传入
</pre>


<p>需要说明的是：</p>

<ol>
<li>如果使用带<code>l</code>的函数，即execl、execle、execlp应该在参数列表最后传入一个NULL标记参数完毕。</li>
<li>如果是带v的函数就应该在数组的最后一项设置成NULL标记数组的完毕。</li>
<li>并且arg0（就是第一个参数）通常情况下都是可执行文件自身的名字，否则可能会导致函数调用失败，<a name="list"></a>当然也有特例，为了行文通畅，放到<a href="#appendix"> 最后</a>再说。</li>
<li> 如果使用带有e的函数那么环境变量数组envp的最后也要有NULL标记数组的结束。</li>
<li>实验证明对于带有e的函数在传入正确的envp的前提下还要写对正确的路径，否则不能执行。</li>
</ol>


<p>函数返回0表示正常。</p>

<p>写个小程序试试看：</p>

<p>``` cpp</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;unistd.h></h1>

<p>int main() {</p>

<pre><code>printf("process pid: %d\n", getpid());
execlp("./child", "child", NULL);
printf("hello\n");
return 0;
</code></pre>

<p>}
```</p>

<p>编译执行：
<code>cpp
young@Y470:~/Desktop$./a
process pid: 12369
pid: 12369
</code>
执行了<code>./child</code>命令，第一行输出是原进程的输出，第二行输出是新进程（不是子进程）child的输出，注意printf没有执行。那是因为exec函数执行是清理了当强进程的内存空间整个进程可以说是直接换成了child进程。这个child是一个小程序，代码如下：</p>

<p>``` cpp</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;unistd.h></h1>

<p>int main(void) {</p>

<pre><code>printf("pid: %d\n", getpid());
return 0;
</code></pre>

<p>}
```
通过这段代码我们也可以证明，<strong>exec创建的进程和调用进程pid一样</strong>。</p>

<p>然后我们写个程序测试并说明上述所有exec函数的用法：</p>

<p>``` cpp</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;unistd.h></h1>

<p>int main(int argc, char *argv[]) {</p>

<pre><code>char c = argv[1][0];
pid_t p;
char* m_argv[] = {
    "echo", "echo", "Hello world", NULL, 
};
char *envp[] = {
    "/usr/bin", 
    "/bin", 
    NULL, 
};

printf("parent pid: %d\n", getpid());


switch (c){
    case '1':
        if (!fork()) {
            printf("from execl pid: %d\n", getpid());
            execl("/bin/echo", "echo", "Hello world", NULL);
        }
        break;
    case '2':
        if (!fork()) {
            printf("from execle pid: %d\n", getpid());
            execle("/bin/echo", "echo", "Hello world", NULL, envp);
        }
        break;
    case '3':
        if (!fork()) {
            printf("from execlp pid: %d\n", getpid());
            execlp("echo", "echo", "Hello world", NULL);
        }
        break;
    case '4':

        if (!fork()) {
            printf("from execv pid: %d\n", getpid());
            execv("/bin/echo", m_argv);
        }
        break;
    case '5':
        if (!fork()) {
            printf("from execve pid: %d\n", getpid());
            execve("/bin/echo", m_argv, envp);
        }
        break;
    default:
        if (!fork()) {
            printf("from execvp pid: %d\n", getpid());
            execvp("echo", m_argv);
        }
}
return 0;
</code></pre>

<p>}
```</p>

<p>编译执行看看能不能出来结果：</p>

<p>``` cpp
young@Y470:~/Desktop$for ((i = 1; i &lt; 7; i++));do ./exec_test $i; echo ;done
parent pid: 11046
from execl pid: 11047</p>

<p>Hello world
parent pid: 11048
from execle pid: 11049</p>

<p>Hello world
parent pid: 11050
from execlp pid: 11051</p>

<p>Hello world
parent pid: 11052
from execv pid: 11053</p>

<p>echo Hello world
parent pid: 11054
from execve pid: 11055</p>

<p>echo Hello world
parent pid: 11056
from execvp pid: 11057</p>

<p>echo Hello world
```
共六个hello world，虽然有点乱，不过也是没办法的事，谁让人家来自不同进程呢！想想也够吊的，六个hello world来六个自不同进程。</p>

<p>这里也展示了<strong>如何开启一个进程</strong>，就是fork之后在子进程执行exec。</p>

<h2>3.附录</h2>

<p><a name="appendix"></a>
在<a href="#list">上面</a>说到arg0和可执行文件名不一样的情况。比如大家读知道的busybox就这一个例子。</p>

<p>在c/c++语言中main函数想使用命令行参数的话就得使用下面的声明方式：</p>

<pre>
int main(int argc, char *argv[])
</pre>


<p>在程序执行是，argc至少是1, 所以argv<a href="http://en.wikipedia.org/wiki/Fork_(system_call)">0</a>始终有值，他就是程序调用的可执行文件的名字。比如ls命令他的argv<a href="http://en.wikipedia.org/wiki/Fork_(system_call)">0</a>始终都是“ls“。不妨写个程序测试：</p>

<p>``` cpp</p>

<h1>include &lt;stdio.h></h1>

<p>int main(int argc, char *argv[]) {</p>

<pre><code>printf("%s\n", argv[0]);
return 0;
</code></pre>

<p>}
```
编译执行，请看仔细：</p>

<p><code>cpp
young@Y470:~/Desktop$make name
cc     name.c   -o name
young@Y470:~/Desktop$./name
./name
young@Y470:~/Desktop$ln -s name some
young@Y470:~/Desktop$./some
./some
young@Y470:~/Desktop$/home/young/Desktop/name
/home/young/Desktop/name
young@Y470:~/Desktop$../Desktop/name
../Desktop/name
</code></p>

<p>想必你已经看明白了，我也不用多解释了。当我们使用软链接时，argv<a href="http://en.wikipedia.org/wiki/Fork_(system_call)">0</a>的名字就是软链接的名字。busybox就是对自身设置了好多软链接比如:<code>ln -s busybox ls</code>这样再调用ls时，argv<a href="http://en.wikipedia.org/wiki/Fork_(system_call)">0</a>就是”ls“这样就能知道用户的目的然后执行ls的功能。</p>

<p>最后在写个程序测试一下：</p>

<p>``` cpp</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;unistd.h></h1>

<p>int main(void) {</p>

<pre><code>if(!fork()) {
    execlp("busybox", "busybox", NULL);
}
if(!fork()) {
    //arg0 和可执行文件名不一样
    execlp("busybox", "ls", "-l", NULL);
}
return 0;
</code></pre>

<p>}
```</p>

<p>看一下结果：
``` cpp
young@Y470:~/Desktop/busy$Copyright &copy; 1998-2011 Erik Andersen,  Rob Landley,  Denys Vlasenko
and others. Licensed under GPLv2.
See source distribution for full notice.</p>

<p>Usage: busybox [function] [arguments]&hellip;
   or: busybox &mdash;list[-full]
   or: busybox &mdash;install [-s] [DIR]
   or: function [arguments]&hellip;</p>

<pre><code>BusyBox is a multi-call binary that combines many common Unix
utilities into a single executable.  Most people will create a
                …………
cttyhack,  cut,  date,  dc,  -rwxr-xr-x    1 young    young       697656 Jan 13 03:29 busybox
</code></pre>

<p>dd,  -rwxr-xr-x    1 young    young         6935 Jan 13 03:35 t
deallocvt,  -rw-r&mdash;r&mdash;    1 young    young          476 Jan 13 03:35 t.c
depmod,  df-rw-r&mdash;r&mdash;    1 young    young            0 Jan 13 03:30 ??
,  diff,</p>

<pre><code>                …………
</code></pre>

<p>```
busybox 的输出太长了，我删掉了一部分并用省略号标记。可以看到ls的输出（夹杂在busybox之间，因为是两个进程的输出）。</p>

<p>大功告成，没想到好好写一篇博客需要3个小时！！！困死我了，怒睡！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux触摸板自然滚动]]></title>
    <link href="http://LanderlYoung.github.io/blog/2014/01/12/linuxchong-mo-ban-zi-ran-gun-dong/"/>
    <updated>2014-01-12T20:11:36+08:00</updated>
    <id>http://LanderlYoung.github.io/blog/2014/01/12/linuxchong-mo-ban-zi-ran-gun-dong</id>
    <content type="html"><![CDATA[<p>触摸板的自然滚动最早是乔帮主发明的。</p>

<p>所谓自然滚动是指触摸板双指滚动的功能，当用两个手指向上滑动触摸板时，屏幕向上滚动，当双指向下化时，屏幕向下滚动。若是反过来就和鼠标一样了。自然滚动让人觉是得在用爽指控制屏幕而不是在控制触摸板。</p>

<p>开始觉得反人类，谁知道用习惯了才知道那真的很爽！爽到不想再用鼠标了。但是在linux系统里面触摸板还不是自然滚动。</p>

<!--more-->


<p>我是synaptics的触摸板，方法一对其他触摸板不见得管用。如果不是synaptics的触摸板貌似也有利用xorg来改的方法，在文章后面再介绍。</p>

<h3>1. synaptics 触摸板</h3>

<p>首先要安装synapclient的驱动：<code>xserver-xorg-input-synaptics</code>。
其实在大多数linux系统内都已经默认按装了。</p>

<pre>
sudo apt-get install xserver-xorg-input-synaptics
</pre>


<p>然后你可以用两个命令来设置垂直滚动和水平滚动的<code>速度</code>:</p>

<pre>
synclient VertScrollDelta=-103
synclient HorizScrollDelta=-103
</pre>


<p>这里把速度设置成负值意思就是让触摸板按照与原来方向的相反方向移动。需要说明的是数值的绝对值越大滚动越慢。</p>

<p>然后我们就达到目的了。为了让这两个命令开机的之后就能自动执行可以</p>

<ol>
<li>把他们加到home目录里的<code>.bashrc</code>文件里。</li>
<li>或者在<code>/etc/profile.d/</code>里面创建一个脚本，比如我建立的是<br/>
<code>/etc/profile.d/synaptics\_natural\_scrolling.sh</code>
``` cpp

<h6>#</h6>

<h1>File Name:        /etc/profile.d/synaptics_natural_scrolling.sh</h1>

<h1>Author:           Landerl Young</h1>

<h1>e-Mail:           <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#111;&#x3a;&#x4c;&#x61;&#110;&#100;&#101;&#x72;&#x6c;&#x59;&#111;&#x75;&#x6e;&#x67;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;">&#x4c;&#x61;&#x6e;&#x64;&#101;&#x72;&#x6c;&#89;&#111;&#117;&#x6e;&#103;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;</a></h1>

<h1>Created Time:     Thu 31 Oct 2013 01:41:46 PM HST</h1>

<h6>#</h6>

<h1>!/bin/bash</h1>

<p>synclient VertScrollDelta=-103
synclient HorizScrollDelta=-103</p></li>
</ol>


<p>```
最后别忘了加可执行权限</p>

<pre>
sudo chmod a+x /etc/profile.d/synaptics_natural_scrolling.sh
</pre>


<p>大功告成。</p>

<h3>2. 其他方法（所有触摸板通用）</h3>

<p>xorg有个<code>xinput</code>命令。如果，我是说如果，你没有这个命令的话，我帮你查好了它所在的软件包名——<code>xinput</code>：</p>

<pre>
young@Y470:~/Documents/octopress$dpkg -S /usr/bin/xinput 
xinput: /usr/bin/xinput
</pre>


<p>输入之后（不加任何参数），有如下输出：</p>

<p>``` cpp
young@Y470:~/Documents/octopress$xinput
⎡ Virtual core pointer                        id=2    [master pointer  (3)]
⎜   ↳ Virtual core XTEST pointer                id=4    [slave  pointer  (2)]
⎜   ↳ SynPS/2 Synaptics TouchPad                id=14   [slave  pointer  (2)]
⎣ Virtual core keyboard                       id=3    [master keyboard (2)]</p>

<pre><code>↳ Virtual core XTEST keyboard             id=5    [slave  keyboard (3)]
↳ Power Button                                id=6    [slave  keyboard (3)]
↳ Video Bus                                   id=7    [slave  keyboard (3)]
↳ Power Button                                id=8    [slave  keyboard (3)]
↳ Sleep Button                                id=9    [slave  keyboard (3)]
↳ Video Bus                                   id=10   [slave  keyboard (3)]
↳ Lenovo EasyCamera                           id=12   [slave  keyboard (3)]
↳ AT Translated Set 2 keyboard                id=13   [slave  keyboard (3)]
↳ Ideapad extra buttons                       id=15   [slave  keyboard (3)]
↳ ACPI Virtual Keyboard Device                id=16   [slave  keyboard (3)]
</code></pre>

<p>```</p>

<p>这里面就是各个输入设备了，看名字就猜得出来。可以使用<code>xinput --get-button-map &lt;设备名&gt;</code>显示按键映射，显示如下：</p>

<pre>
young@Y470:~/Documents/octopress$xinput --get-button-map "SynPS/2 Synaptics TouchPad" 
1 2 3 4 5 6 7 8 9 10 11 12 
</pre>


<p>于是下面要做的事就很明显了——改按键映射！既然有个<code>--get-button-map</code>参数肯定也有<code>--set-button-map</code>，没错，看了man手册发现真的有。经过测试各个按键的功能发现如下：
4、5、6、7四个值是控制触摸板滚动方向的，修改如下：</p>

<pre>
young@Y470:~/Documents/octopress$xinput --set-button-map "SynPS/2 Synaptics TouchPad" 1 2 3 5 4 7 6 8 9 10 11 12
</pre>


<p>为了使命令开机自动执行，可以使用方法一中介绍的两个方法。</p>

<p>当然方法二放在后面说是因为他有缺点——在一些少数程序比如文件管理器<code>nautilus</code>里面自然滚动失效的T^T。</p>
]]></content>
  </entry>
  
</feed>
