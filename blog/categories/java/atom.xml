<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: java | Young_Blog]]></title>
  <link href="http://LanderlYoung.github.io/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://LanderlYoung.github.io/"/>
  <updated>2015-04-05T01:54:39+08:00</updated>
  <id>http://LanderlYoung.github.io/</id>
  <author>
    <name><![CDATA[LanderlYoung]]></name>
    <email><![CDATA[landerlyoung@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[java序列化实践]]></title>
    <link href="http://LanderlYoung.github.io/blog/2015/04/04/javaxu-lie-hua-shi-jian/"/>
    <updated>2015-04-04T18:06:20+08:00</updated>
    <id>http://LanderlYoung.github.io/blog/2015/04/04/javaxu-lie-hua-shi-jian</id>
    <content type="html"><![CDATA[<p>java中实例的序列化是指将一个实例专程二进制流以用于网络传输或者固化存储之用。事实上，简单点说就是把一个类实例的成员变量存储下来，然而这个过程根据成员变量的类型的不同，可能会很简单，也可能会很复杂。序列化的用处还是很大的，比如跨进程通信（IPC，安卓中的IPC用到了序列化，只是安卓自身实现了一个比java更轻量级、更简单的序列化方式。但是原理大同小异），远程方法调用（RMI，事实上这个和安卓中的Binder通讯很类似）;此外还常见的是把实例序列化到数据库中以blob的形式存储。并且因为java语言本身就是跨平台设计的，序列化之后的数据也是平台无关的，因此你无需关心大小端之类的问题（以及类似于C语言的内存对齐问题）！既然序列化这个有用还是有必要学习一下的。（BTW，java EE中提供了更加严格的固化方案Java Date Object，或着也可以考虑使用Hibernate框架。）</p>

<p>参考的资料是《Thinking in java》，和<a href="http://www.ibm.com/developerworks/cn/java/j-lo-serial/index.html">IBM的一篇博文</a>。下面来做几个实验，一边学习一边实践一下。</p>

<!--more-->


<p>序列化其实是很简单的，你只需要给需要序列化的类实现Serializable接口（这个接口只是标签接口，没有方法）。你的类就被标记为了可序列化。然后序列化的过程是使用ObjectOutputSteram::writeObject()方法;反序列化是使用ObjectInputStream::readObject()。</p>

<h3>1. <code>Serializable</code>方式</h3>

<p>这种方式可以说是由jvm来全权掌控的。序列化的时候，java会把类的每一个实例成员变量（不包括static成员变量）写下来，比较好理解的是原始类型。如果类中有成员是其他Object，就会递归的去序列化这个Object。</p>

<p>比如如下代码：</p>

<pre><code class="java">package com.young;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;

class A implements Serializable {
    private static int instances = 0;

    public A next;
    private int num;

    public A(int num, A next) {
        this.num = num;
        System.out.println("Constructor #" + (instances++));
        this.next = next;
    }

    @Override
    public String toString() {
        return Integer.toString(num) + " " + next;
    }
}

public class Main {

    public static void main(String[] args) throws IOException, ClassNotFoundException {
        A a = new A(7, new A(8, null));

        System.out.println("serialize");
        ObjectOutputStream oo = new ObjectOutputStream(
                new FileOutputStream("oo.out"));
        oo.writeObject(a);
        oo.close();
        System.out.println("deserialize");
        ObjectInputStream oi = new ObjectInputStream(
                new FileInputStream("oo.out"));
        A a1 = (A) oi.readObject();
        oi.close();
        System.out.println("a:" + a);
        System.out.println("a1:" + a1);
    }
}
</code></pre>

<p>输出如下：</p>

<pre><code class="bash">Constructor #0
Constructor #1
serialize
deserialize
a:7 8 null
a1:7 8 null
</code></pre>

<p>然而在反序列化的过程中，<strong>构造函数并没有被调用</strong>！所以Serializable方式的反序列化是直接从数据中“填充”一个实例出来！看上去有点神奇的样子。</p>

<h4>1.1 <code>transient</code>关键字</h4>

<p>在Serializable方式中如果有些成员变量（比如密码等敏感信息）不想被序列化的话，你可以使用transient关键字来修饰之。</p>

<h4>1.2 static fields</h4>

<p>序列化时static变量不会被序列化进去。因为其是class的信息，和实例没什么关系。如果要序列化的话可以自己用方式2或3手动write。</p>

<h3>2. <code>Enternalizable</code>方式</h3>

<p>了解Serializable方式的序列化会发现：在整个序列化过程中我们好像什么都没做，只是实现了Serializable接口而已，对于这种打酱油的行为我表示不安心！感觉局面不在自己的掌控之中呀！好在java中还有另一种序列化方式<code>Externalizable</code>方式。这个接口中有两个方法：<code>void writeExternal(ObjectOutput out)</code>和<code>void readExternal(ObjectInput in)</code>。直接看例子：</p>

<pre><code class="java">package com.young;

import java.io.Externalizable;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectInputStream;
import java.io.ObjectOutput;
import java.io.ObjectOutputStream;

class B implements Externalizable {
    private static int instances = 0;

    private int n;

    public B() {
        System.out.println("Constructor1 #" + (instances++));
    }

    public B(int n) {
        System.out.println("Constructor2 #" + (instances++));
        this.n = n;
    }

    @Override
    public void writeExternal(ObjectOutput out) throws IOException {
        out.writeInt(n ^ 100);
    }

    @Override
    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
        n = in.readInt() ^ 100;
    }

    @Override
    public String toString() {
        return "b:" + n;
    }
}

public class Main {


    public static void main(String[] args) throws IOException, ClassNotFoundException {
        B b1 = new B(7);
        B b2 = new B(9);
        System.out.println("serialize");
        ObjectOutputStream oo = new ObjectOutputStream(
                new FileOutputStream("oo.out"));
        oo.writeObject(b1);
        oo.writeObject(b2);
        oo.close();
        System.out.println("deserialize");
        ObjectInputStream oi = new ObjectInputStream(
                new FileInputStream("oo.out"));

        B b = (B) oi.readObject();
        System.out.println(b);
        b = (B) oi.readObject();
        System.out.println(b);
        oi.close();
    }
}
</code></pre>

<p>输出如下：</p>

<pre><code class="bash">Constructor2 #0
Constructor2 #1
serialize
deserialize
Constructor1 #2
b:7
Constructor1 #3
b:9
</code></pre>

<p>从中可以看出：我们需要在writeExternal中对该类需要序列化的数据进行操作，在readExternal中相应的进行读取，需要注意的是：读和写的顺序要一致。在这种方式下java自身是不会干涉实例的序列化的，所有的序列化、反序列化工作是有开发者自己定义的。这种方式下开发人员有了足够的自由度！比如我可以writeExternal中对数据加密，在readExternal中对数据解密，以此保证序列化的数据是安全的。（上面的代码中使用亦或进行的简单的加解密操作）。</p>

<p>和Serializable不同的是我们看到在反序列化的时候<strong>默认构造函数被调用了</strong>！所以这种方式是比较纯粹的实现接口+接口回调，而不是Serializable中实例直接被java填充出来的黑魔法那样！</p>

<p>因为要调用默认构造函数，因此实现Externalizable接口的类必须有一个public的默认构造函数！这样jvm才能初始化一个类，然后调用其接口实现来进行反序列化。</p>

<h3>3. 第三种序列化方式</h3>

<p>这种序列化方式更像是前两种的综合体，TIJ中称这种方法为“An alternative to Externalizable”。（并且这种方式并不是很符合通常的java语言习惯，因此看起来很奇怪。在Thing in java一书中被作者Bruce Eckel喷得不轻！不过我们还是看一下什么情况。）</p>

<p>实现方式是实现Serializable接口，然后在你的类中加入如下两个方法，而且方法签名要一模一样！：</p>

<pre><code class="java">private void writeObject(ObjectOutputStream stream)
throws IOException;

private void readObject(ObjectInputStream stream)
throws IOException, ClassNotFoundException;
</code></pre>

<p>没错，你没有看错他们的确是private方法！看仔细咯，这个方法和Externalizable中的两个方法的参数是不一样的，这里面是ObjectOutputStream，而后者是ObjectOutput。</p>

<p>然后在两个方法中你可以手动控制序列化，这一点和方式2相同。不同的是他还和方式1结合了！不过到底怎么结合的呢？关键在于<code>ObjectOutputStream：：defaultWriteObject()</code>方法和<code>ObjectOutputStream：：defaultReadObject()</code>。你可以在writeObject最开始调用相应的defaultWriteObject方法。他的作用就是使用默认的序列化实现方式来操作当前实例，在这之后你可以自由其他的操作序列化过程。对于read亦是如此。</p>

<p>是不是显得很奇怪，我调用了ObjectInputStream的方法，而且都没有把this传进去，可是jvm却把“我”给序列化了！对于这真的只能说不要在意细节，java语言就是这么设计的，不喜欢可以不用这种方式嘛～（反正我最喜欢方式2</p>

<p>好!现在&#8221;show me the code&#8221;:</p>

<pre><code class="java">class T implements Serializable {
    public static int instances = 0;
    private int num;
    private transient String passwd;

    public T(int n) {
        num = n;
        passwd = n + "0";
        System.out.println("Constructor #" + (instances++));
    }

    private void writeObject(ObjectOutputStream stream)
            throws IOException {
        stream.defaultWriteObject();
        stream.writeObject("NO PASSWORD");
        System.out.println("writeObject");

    }

    private void readObject(ObjectInputStream stream)
            throws IOException, ClassNotFoundException {
        stream.defaultReadObject();
        passwd = (String) stream.readObject();
        System.out.println("readObject");
    }

    @Override
    public String toString() {
        return num + " " + passwd;
    }
}

public class Main {

    public static void main(String[] args) throws IOException, ClassNotFoundException {

        T t = new T(10);
        T t1 = new T(11);
        //
        System.out.println("serialize");
        ObjectOutputStream oo = new ObjectOutputStream(
                new FileOutputStream("oo.out"));

        oo.writeObject(t);
        oo.writeObject(t1);

        //
        oo.close();
        System.out.println("deserialize");
        ObjectInputStream oi = new ObjectInputStream(
                new FileInputStream("oo.out"));
        T tmp;
        tmp = (T) oi.readObject();
        System.out.println(tmp);
        tmp = (T) oi.readObject();
        System.out.println(tmp);

        //
        oi.close();
    }
}
</code></pre>

<p>输出
<code>bash
Constructor #0
Constructor #1
serialize
writeObject
writeObject
deserialize
readObject
10 NO PASSWORD
readObject
11 NO PASSWORD
</code></p>

<p>可以看出这种<strong>方式3仍然不会调用构造函数</strong>！</p>

<h3>4. serialVersionUID 常量</h3>

<p>不管是上述的那一种序列化方式，都可以使用<code>serialVersionUID</code>控制class的版本问题。<code>serialVersionUID</code>是一个定义在类内部的成员常量比如：<code>private static final int serialVersionUID = 1L;</code>。他的作用是标记class的版本（这是我个人的理解，下面解释一下）。一个类如果定义了这个常量，在系列话时会存储下来这个常量。当反序列化时jvm会先比较加载的class和序列化数据中的类的serialVersionUID是否相同，如果不同的话就认为class版本不一样，抛出<code>java.io.InvalidClassException</code>异常，拒绝反序列化。直白一点说就是“当一个类序列化时候的serialVersionUID和反序列化时候的serialVersionUID相同是，其反序列化才会成功。</p>

<p>当你的某个用于固化的class被更新的时候，他的成员和原来相比已经不再完全相同了，此时之前被序列化的数据——为了避免逻辑混乱——已经不能再反序列化到新的class中了。此时你可以更改新的class的serialVersionUID来达到这一目的。</p>

<hr />

<blockquote><p>  事实上因为Externalizable方式的序列化、反序列化全部是由程序员一手掌握的，因此它显得范围额比较简单，所有逻辑（哪些要序列化，如何序列化）都可以在接口的两个方法中控制。然而Serializable方式由于是由jvm全权负责的，要控制一些逻辑反而会显得不那么简单明了。</p></blockquote>

<h3>5. 一些特殊情况</h3>

<ol>
<li>相同的instance问题：比如一个List中包含了同一个实例的多出引用。那么序列化时<strong>同一个引用只会序列化一次</strong>。反序列化是这些相同的引用最中还是得到的引用仍然是相同的。所以循环引用也不会发生死循环的情况！（不得不说这一点很是机智！</li>
<li>基于1,<strong>当序列化时写入同一个实例（引用相同）时，第二次写入并不会触发其序列化</strong>，因此只是第一次写入时进行了序列化，即使后来写入的时候实例的状态已经发生了改变。所以这一点会需要特别注意。</li>
<li><p>父类没有实现序列化接口而子类实现的时候（Drived extends Base)：</p>

<p> 这里序列化接口有两种（Serializable、Externalizable）分两种情况叙述：</p>

<ul>
<li>Serializable：此时Base因为没有实现Serializable而不能序列化，但是Drived因为实现了接口所以可以序列化。我们知道实现Serializable接口的类不需要调用构造函数就能反序列化。我们还知道类的初始化顺序是首先要初始化父类的。这里发序列化时就会出现要初始化父类的情况，因此需要父类有public默认构造函数。同时如果是方式3的话自然也可以手动序列化父类中的数据。</li>
<li>Externalizable：这个最好说父类子类都要有public默认构造函数。至于哪些会序列化，哪些不会，就自己掌控了。</li>
</ul>
</li>
</ol>


<h3>总结</h3>

<ol>
<li><code>Serializable</code>方式(方式1、3)反序列化时不会调用构造函数。</li>
<li><code>Externalizable</code>方式反序列化会调用默认（无参）构造函数，如果没有public默认构造函数会抛异常。</li>
<li><code>static</code> 变量默认不会序列化。</li>
<li><code>transient</code> 关键字修饰的变量默认也不会序列化。</li>
<li><code>serialVersionUID</code>控制class版本信息，防止出现不正常序列化</li>
<li>相同引用的实例序列化时只会序列化一次。反序列化后引用也是相同的。</li>
<li>父类没有序列化而子类序列化的情况。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java 中JNI的使用]]></title>
    <link href="http://LanderlYoung.github.io/blog/2014/10/16/java-zhong-jnide-shi-yong/"/>
    <updated>2014-10-16T21:10:55+08:00</updated>
    <id>http://LanderlYoung.github.io/blog/2014/10/16/java-zhong-jnide-shi-yong</id>
    <content type="html"><![CDATA[<p>JNI全称是<code>Java Native Interface</code>是在JAVA和Native层（包括但不限于C/C++）相互调用的接口规范。</p>

<p>JNI在JAVA1.1中正式推出，在JAVA1.2版本中加入了<code>JNI_OnLoad</code>，<code>JNI_OnUnload</code>方法，这两个方法还是很有用的，后面再说。</p>

<!--more-->


<h3>JNI基础篇</h3>

<p>Java通过JNI调用本地方法的过程大致是</p>

<ol>
<li>写一个Java类，在其中声明对应要调用的native方法，用<code>native</code>关键字修饰。 比如<code>private static native int native_newInstance();</code></li>
<li>通过<code>javah</code>命令生成java类对应的C/C++头文件。<code>javah -encoding utf-8 -cp src com.young.soundtouch.SoundTouch</code></li>
<li>在C/C++中实现头文件中声明的函数</li>
<li>编译C/C++代码为动态库（Windows中的dll，linux(Android)中的so，MAC OSX中的dylib）。</li>
<li>在java代码中加载动态库，即可像调用Java方法一样，调用到native函数。</li>
</ol>


<p>其中第三步在Java1.2中增加了<code>JNI_OnLoad</code>方法之后有另一种实现方式（<a href="#jni_onload">后面</a>说）。</p>

<p>javah生成的头文件大致是这样的：
&#8220;`java
/<em> DO NOT EDIT THIS FILE - it is machine generated </em>/</p>

<h1>include &lt;jni.h></h1>

<p>/<em> Header for class com_young_soundtouch_SoundTouch </em>/</p>

<h1>ifndef _Included_com_young_soundtouch_SoundTouch</h1>

<h1>define _Included_com_young_soundtouch_SoundTouch</h1>

<h1>ifdef __cplusplus</h1>

<p>extern &ldquo;C&rdquo; {</p>

<h1>endif</h1>

<h1>undef com_young_soundtouch_SoundTouch_SETTING_USE_AA_FILTER</h1>

<h1>define com_young_soundtouch_SoundTouch_SETTING_USE_AA_FILTER 0L</h1>

<pre><code>/*
* Class:     com_young_soundtouch_SoundTouch
* Method:    native_getDefaultSampleElementSize
* Signature: ()I
*/
JNIEXPORT jint JNICALL Java_com_young_soundtouch_SoundTouch_native_1getDefaultSampleElementSize
    (JNIEnv *, jclass);
</code></pre>

<h1>ifdef __cplusplus</h1>

<p>}</p>

<h1>endif</h1>

<h1>endif</h1>

<pre><code>
文件开头就是普通的头文件，但是可以发现： 

 1. 包含了jni.h头文件（一般位于`$JAVA_HOME/jd{jdk-version}/include`文目录内）。这是JNI中所有的[类型][jni_type]、函数、宏等定义的地方。所以C/C++世界的JNI是由他制定的游戏规则。

 2. 在类中生命的常量（`static final`）类型会在头文件中以宏的形式出现，这一点还是很方便的。

 3. 函数的注释还是比较全的，包括了： 
     1. 对应的class  
     2. 对应的java方法名  
     3. 对应java方法的[签名][signature]  
 4. 方法的声明显得有点奇怪，由以下及部分组成：   
     1. `JNIEXPORT`这是函数的导出方式  
     2. jint 返回值类型（jint由jni.h定义，对应int，[下面][jni_type]具体再说吧  
     3. JNICALL 函数的调用方式也就是汇编级别参数的传入方式  
     4.  Java_com_young_soundtouch_SoundTouch_native_1getDefaultSampleElementSize —— 超级长的函数名！！！格式是`Java_` + `类全名` + `_` + JAVA中声明的native方法名。其中会把包名中的点（`.`）替换成下划线（`_`），同时为了避免冲突把下划线替换成`_1`。  
     5. 方法的参数，上面的这个方法在JAVA的声明中实际上是没有参数的，其中的`JNIENV`顾名思义是JNI环境，和具体的线程绑定。而第二个参数`jclass`其实是java中的`Class`因为上面是一个`static`方法，因此第二个参数是`jclass`。如果是一个实例方法则对应第二个参数是`jobject`，相当于java中的`this`。  

下面在C/C++中实现这个方法就行啦。但是在动手前现大致了解以下jni.h制定的游戏规则。

####&lt;a name="jni_type"&gt;类型转换&lt;/a&gt;：  

javah生成的头文件里面使用的类型都是jni.h定义的，目的是做到**平台无关**，比如保证在所有平台上jint都是32位的有符号整型。

**基本对应关系如下：**

|  jni 类型 | JAVA类型 | 对应本地类型  |  类型[签名][signature] |
| :------: | :------: | :--------: | :----------------: |
|  jboolean | boolean | uint8_t | Z|
|  jbyte | byte | char | B |
|  jcahr | char | uint16_t | C |
|  jshort | short | int16_t | S |
|  jint | int | int32_t | I |
|  jlong | long | int64_t | J |
|  jfloat | float | float | F |
|  jdouble | double | double | D |
|  void | void | void | V |

**引用类型对应关系：**

| java类型 |  JNI 类型 | java类型 |  JNI 类型 |
| :-----: | :------: | :------: | :------: |
| 所有的实例引用 | jobject |java.lang.Class |  jclass |
| java.lang.String | jstring | Ocject[] | jobjectArray |
| java.lang.Throwable | jthrowable | 基本类型[] | jxxxArray |

通过表格发现，除了上面定义的`String`，`Class`，`Throwable`，其他的类（除了数组）都是以`jobject`的形式出现的！事实上jstring， jclass也都是object的子类。所以这里还是和java层一样，一切皆jobject。（当然，如果jni在C语言中编译的话是没有继承的概念的，此时jstring，jclass等其实就是jobject！用了typedef转换而已！！）

接下来是`JNIEnv *`这个指针，他提供了JNI中的一系列操作的接口函数。

#### JNI中操作jobject
其实也就是在native层操作java层的实例。
要操作一个实例无疑是：

 1. 获取/设置 （即 get/set ）成员变量（field）的值

 2. 调用成员方法（method）

所以问题来了：（挖掘机技术哪家强？！ o(*≧▽≦)ツ┏━┓ ）

**怎么得到field 和 method？**

通过使用**jfieldID和jmethodID**：
在JNI中使用类似于放射的方式来进行field和method的操作。JNI中使用jfieldID和jmethodID来表示成员变量和成员方法，获取方式是：
</code></pre>

<p>jfieldID GetFieldID(jclass clazz, const char <em>name, const char </em>sig);
jfieldID GetStaticFieldID(jclass clazz, const char <em>name, const char </em>sig);
jmethodID GetMethodID(jclass clazz, const char <em>name, const char </em>sig);
jmethodID GetStaticMethodID(jclass clazz, const char <em>name, const char </em>sig) ;
&#8220;`</p>

<p>其中最后一个参数是<a href="#signature">签名</a>。
<strong>获取jclass的方法</strong>除了实用上面静态方法的第二个参数外，还可以手动获取。
<code>jclass FindClass(const char *name)</code>
需要注意的是<code>name</code>参数，他是一个类包括包名的全称，但是需要把包名中的点<code>.</code>替换成斜杠<code>/</code>。（好吧，事实上我不是太明白为啥要这么做。）</p>

<p>有了jfieldID和jmethodID就知道狗蛋住哪了，现在去狗蛋家找他玩 ♪(^∇^*)</p>

<p><strong>成员变量:</strong></p>

<ol>
<li><p>get:</p>

<ol>
<li><p><code>&lt;type&gt; Get&lt;type&gt;Field(jobject , jfieldID);</code>即可获得对应的field，其中field的类型是type，可以是上面<a href="#jni_type">类型</a>所叙述的任何一种。</p></li>
<li><p><code>&lt;type&gt; GetStatic&lt;type&gt;Field(jobject , jfieldID);</code>同1，唯一的区别是用来获取静态成员。</p></li>
</ol>
</li>
<li><p>set:</p>

<ol>
<li><p><code>void Set&lt;type&gt;Field(jobject obj, jfieldID fieldID, &lt;type&gt; val)</code></p></li>
<li><p><code>void SetStatic&lt;type&gt;Field(jclass clazz, jfieldID fieldID, &lt;type&gt; value);</code></p></li>
</ol>
</li>
</ol>


<p><strong>成员方法：</strong></p>

<p>调用方法自然要把方法的参数传递进去，JNI中实现了三种参数的传递方式：</p>

<ol>
<li><p><code>Call&lt;type&gt;Method(jobject obj, jmethod jmethodID, ...)</code>其中<code>...</code>是C中的可变长参数，类似于<code>printf</code>那样，可以传递不定长个参数。于是你可以把java方法需要的参数在这里面传递进去。</p></li>
<li><p><code>Call&lt;type&gt;MethodV(jobject obj, jmethodID methodID, va_list args)</code>其中的<code>va_list</code>也是C中可变长参数相关的内容（我不了解，不敢瞎说。。。偷懒粘一下Oracle的文档）Programmers place all arguments to the method in an args argument of type va_list that immediately follows the methodID argument. The Call<type>MethodV routine accepts the arguments, and, in turn, passes them to the Java method that the programmer wishes to invoke.</p></li>
<li><p><code>Call&lt;type&gt;MethodA(jobject obj, jmethodID methodID, const jvalue * args)</code>哎！这个我知道可以说两句LOL~~这里的<code>jvalue</code>通过查代码发现就是JNI中各个数据类型的union，所以可以使用任何类型复制！所以参数的传入方式是通过一个jvalue的数组，数组内的元素可以是任何jni类型。</p></li>
</ol>


<p>然后问题又来了：（挖掘机技术到底哪家强？！o(*≧▽≦)ツ┏━┓）
如果传进来的参数和java声明的参数的不一致会怎么样！（即不符合<a href="#signature">方法签名</a>）这里文档中没用明确解释，但是说道:</p>

<blockquote><p>Exceptions raised during the execution of the Java method.</p></blockquote>

<pre><code class="java">typedef union jvalue {
    jboolean z;
    jbyte    b;
    jchar    c;
    jshort   s;
    jint     i;
    jlong    j;
    jfloat   f;
    jdouble  d;
    jobject  l;
} jvalue;
</code></pre>

<ol>
<li>调用实例方法（instance method）：

<ol>
<li><code>&lt;type&gt; Call&lt;type&gt;Method(jobject obj, jmethodID methodID, ...);</code>调用一个具有<code>&lt;type&gt;</code>类型返回值的方法。</li>
<li><code>&lt;type&gt; Call&lt;type&gt;MethodV(jobject obj, jmethodID methodID, va_list args);</code></li>
<li><code>Call&lt;type&gt;MethodA(jobject obj, jmethodID methodID, const jvalue * args)</code></li>
</ol>
</li>
<li>调用静态方法（static method）：

<ol>
<li><code>&lt;type&gt; CallStatic&lt;type&gt;Method(jobject obj, jmethodID methodID, ...);</code></li>
<li><code>&lt;type&gt; CallStatic&lt;type&gt;MethodV(jobject obj, jmethodID methodID, va_list args);</code></li>
<li><code>CallStatic&lt;type&gt;MethodA(jobject obj, jmethodID methodID, const jvalue * args)</code></li>
</ol>
</li>
<li>调用父类方法（super.method)，这个就有点不一样了。多了一个jclass参数，jclass可以使obj的父类，也可以是obj自己的class，但是methodID必须是从jclass获取到的，这样就可以调用到父类的方法。

<ol>
<li><code>&lt;type&gt; CallNonvirtual&lt;type&gt;Method(jobject obj, jclass clazz, jmethodID methodID, ...)</code></li>
<li><code>&lt;type&gt; CallNonvirtual&lt;type&gt;MethodV(JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, va_list args);</code></li>
<li><code>&lt;type&gt; CallNonvirtual&lt;type&gt;MethodA(JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, const jvalue *args);</code></li>
</ol>
</li>
</ol>


<h4>数组的操作</h4>

<p>数组是一个很常用的数据类型，在但是在JNI中并不能直接操作jni数组（比如jshortArray，jfloatArray）。使用方法是：</p>

<ol>
<li>获取数组长度：<code>jsize GetArrayLength(jarray array)</code></li>
<li>创建新数组： <code>ArrayType New&lt;PrimitiveType&gt;Array(jsize length);</code></li>
<li>通过JNI数组获取一个C/C++数组：<code>&lt;type&gt;* Get&lt;type&gt;ArrayElements(jshortArray array, jboolean *isCopy)</code></li>
<li>指定原数组的范围获取一个C/C++数组（该方法只针对于原始数据数组，不包括Object数组）：<code>void Get&lt;PrimitiveType&gt;ArrayRegion(JNIEnv *env, ArrayType array, jsize start, jsize len, NativeType *buf);</code></li>
<li>设置数组元素：<code>void Set&lt;type&gt;ArrayRegion(jshortArray array, jsize start, jsize len,const &lt;type&gt; *buf)</code>。again，如果是Object数组需要使用：<code>void SetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index, jobject value);</code></li>
<li>使用完之后，释放数组：<code>void Release&lt;type&gt;ArrayElements(jshortArray array, jshort *elems, jint mode)</code></li>
</ol>


<p>有点要说明的：</p>

<ol>
<li><p>上面的3中的isCopy：当你调用getArrayElements时JVM（Runtime）可以直接返回数组的原始指针，或者是copy一份，返回给你，这是由JVM决定的。所以isCopy就是用来记录这个的。他的值是<code>JNI_TURE</code>或者<code>JNI_FALSE</code>。</p></li>
<li><p>6释放数组。<strong>一定要释放你所获得数组</strong>。其中有一个<code>mode</code>参数，其有三个可选值，分别表示：</p></li>
<li><p> 0</p>

<ul>
<li><p>原始数组：允许原数组被垃圾回收。</p></li>
<li><p>copy： 数据会从get返回的buffer copy回去，同时buffer也会被释放。</p></li>
</ul>
</li>
<li><p> JNI_COMMIT</p>

<ul>
<li><p>原始数组：什么也不做</p></li>
<li><p>copy： 数据会从get返回的buffer copy回去，同时buffer<strong>不会</strong>被释放。</p></li>
</ul>
</li>
<li><p> JNI_ABORT</p>

<ul>
<li><p>原始数组：允许原数组被垃圾回收。之前由JNI_COMMIT提交的对数组的修改将得以保留。</p></li>
<li><p>copy： buffer会被释放，同时buffer中的修改将不会copy回数组！</p></li>
</ul>
</li>
</ol>


<h4>关于引用与垃圾回收</h4>

<p>比如上面有个方法传了一个jobject进来，然后我把她保存下来，方便以后使用。这样做是<strong>不行哒</strong>！因为他是一个LocalReference，所以不能保证jobject指向的真正的实例不被回收。也就是说有可能你用的时候那个指针已经是个野指针的。然后你的程序就直接Segment Fault了，呵呵。。。</p>

<p>在JNI中提供了三种类型的引用：</p>

<ol>
<li>Local Reference：即本地引用。在JNI层的函数，所有非全局引用对象都是Local Reference， 它包括函数调用是传入的jobject和JNI成函数创建的jobject。Local Reference的特点是一旦JNI层的函数返回，这些jobject就可能被垃圾回收。</li>
<li>Glocal Reference：全局引用，这些对象不会主动释放，永远不会被垃圾回收。</li>
<li>Weak Glocal Reference：弱全局引用，一种特殊的Global Reference，在运行过程中有可能被垃圾回收。所以使用之前需要使用<code>jboolean IsSameObject(jobject obj1, jobject obj2)</code>判断它是否已被回收。</li>
</ol>


<p>Glocal Reference:<br/>
 1. 创建：<code>jobject NewGlobalRef(jobject lobj);</code><br/>
 2. 释放：<code>void DeleteGlobalRef(jobject gref);</code></p>

<p>Local Reference:<br/>
LocalReference也有一个释放的函数：<code>void DeleteLocalRef(jobject obj)</code>，他会立即释放Local Reference。
这个方法可能略显多余，其实也是有它的用处的。刚才说Local Reference会再函数返回后释放掉，但是假如函数返回前就有很多引用占了很多内存，最好函数内就尽早释放不必要的内存。</p>

<h4>关于JNI_OnLoad<a name="jni_onload"></a></h4>

<p>开头提到JNI_OnLoad是java1.2中新增加的方法，对应的还有一个JNI_OnUnload，分别是动态库被JVM加载、卸载的时候调用的函数。有点类似于WIndows里的DllMain。<br/>
前面提到的实现对应native的方法是实现javah生成的头文件中定义的方法，这样有几个弊端：</p>

<ol>
<li>函数名太长。很长。。相当长。。。</li>
<li>函数会被导出，也就谁说可以在动态库的导出函数表里面找到这些函数。这将有利于别人对动态库的逆向工程，因此带来安全问题。</li>
</ol>


<p>现在有了JNI_OnLoad，情况好多了。你不光能在其中完成动态注册native函数的工作还可以完成一些初始化工作。java对应的有了<code>jint RegisterNatives(jclass clazz, const JNINativeMethod *methods,jint nMethods)</code>函数。参数分别是：</p>

<ol>
<li><p>jclass clazz，于native层对应的java class</p></li>
<li><p>const JNINativeMethod *methods这是一个数组，数组的元素是JNI定义的一个结构体JNINativeMethod</p></li>
<li><p>上面的数组的长度</p></li>
</ol>


<p><strong>JNINativeMethod</strong>：代码中的定义如下：</p>

<pre><code class="java">
/*
 * used in RegisterNatives to describe native method name, signature,
 * and function pointer.
 */

typedef struct {
    char *name;
    char *signature;
    void *fnPtr;
} JNINativeMethod;
</code></pre>

<p>所以他有三个字段，分别是</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 字段 </th>
<th style="text-align:left;"> 含义 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">char *name </td>
<td style="text-align:left;"> java class中的native方法名，只需要方法名即可 </td>
</tr>
<tr>
<td style="text-align:left;"> char *signature </td>
<td style="text-align:left;"> 方法<a href="#signature">签名</a></td>
</tr>
<tr>
<td style="text-align:left;"> void *fnPtr </td>
<td style="text-align:left;"> 对应native方法的函数指针 </td>
</tr>
</tbody>
</table>


<p>于是现在你可以不用导出native函数了，而且可以随意给函数命名，唯一要保证的是参数及返回值的统一。然后需要一个<code>const JNINativeMethod *methods</code>数组来完成映射工作。</p>

<p>看起来大概是这样的:</p>

<pre><code class="cpp">//只需导出JNI_OnLoad和JNI_OnUnload（这个函数不实现也行）
/**
 * These are the exported function in this library.
*/
JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *vm, void *reserved);
JNIEXPORT void JNICALL JNI_OnUnload(JavaVM *vm, void *reserved);

//为了在动态库中不用导出函数，全部声明为static
//native methods registered by JNI_OnLoad
static jint native_newInstance (JNIEnv *env, jclass);

//实现native方法
/*
* Class:     com_young_soundtouch_SoundTouch
* Method:    native_newInstance
* Signature: ()I
*/
static jint native_newInstance
(JNIEnv *env, jclass ) {
    int instanceID = ++sInstanceIdentifer;
    SoundTouchWrapper *instance = new SoundTouchWrapper();
    if (instance != NULL) {
        sInstancePool[instanceID] = instance;
        ++sInstanceCount;
    }
    LOGDBG("create new SouncTouch instance:%d", instanceID);
    return instanceID;
}

//构造JNINativeMethod数组
static JNINativeMethod gsNativeMethods[] = {
        {
            "native_newInstance",
            "()I",
            reinterpret_cast&lt;void *&gt; (native_newInstance)
        }
}；
//计算数组大小
static const int gsMethodCount = sizeof(gsNativeMethods) / sizeof(JNINativeMethod)；

//JNI_OnLoad，注册native方法。
JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *vm, void *reserved) {
    JNIEnv* env;
    jclass clazz;
    LOGD("JNI_OnLoad called");
    if (vm-&gt;GetEnv(reinterpret_cast&lt;void**&gt;(&amp;env), JNI_VERSION_1_6) != JNI_OK) {
        return -1;
    }
    //FULL_CLASS_NAME是个宏定义，定义了对应java类的全名（要把包名中的点(.)_替换成斜杠(/)）
    clazz = env-&gt;FindClass(FULL_CLASS_NAME);
    LOGDBG("register method, method count:%d", gsMethodCount);
    //注册JNI函数
    env-&gt;RegisterNatives(clazz, gsNativeMethods,
        gsMethodCount);
    //必须返回一个JNI_VERSION_1_1以上（不含）的版本号，否则直接加载失败
    return JNI_VERSION_1_6;
}
</code></pre>

<h3>实战技巧篇</h3>

<p>这里主要是巧用C中的宏来减少重复工作：</p>

<h4>迅速生成全名</h4>

<pre><code class="cpp">//修改包名时只需要改以下的宏定义即可
#define FULL_CLASS_NAME "com/young/soundtouch/SoundTouch"
#define func(name) Java_ ## com_young_soundtouch_SoundTouch_ ## name
#define constance(cons) com_young_soundtouch_SoundTouch_ ## cons
</code></pre>

<p>比如<code>func(native_1newInstance)</code>展开成：<code>Java_com_young_soundtouch_SoundTouch_native_1newInstance</code>即JNI中需要导出的函数名（不过用动态注册方式没太大用了）</p>

<p><code>constance(AUDIO_FORMAT_PCM16)</code>展开成<code>com_young_soundtouch_SoundTouch_AUDIO_FORMAT_PCM16</code>这个着实有用。</p>

<p>而且如果包名改了也可以很方便的适应之。</p>

<h3>安卓的log</h3>

<pre><code class="cpp">//define __USE_ANDROID_LOG__ in makefile to enable android log
#if defined(__ANDROID__) &amp;&amp; defined(__USE_ANDROID_LOG__)
#include &lt;android/log.h&gt;
#define LOGV(...)   __android_log_print((int)ANDROID_LOG_VERBOSE, "ST_jni", __VA_ARGS__)
#define LOGD(msg)  __android_log_print((int)ANDROID_LOG_DEBUG, "ST_jni_dbg", "line:%3d %s", __LINE__, msg)
#define LOGDBG(fmt, ...) __android_log_print((int)ANDROID_LOG_DEBUG, "ST_jni_dbg", "line:%3d " fmt, __LINE__, __VA_ARGS__)
#else
#define LOGV(...) 
#define LOGD(fmt) 
#define LOGDBG(fmt, ...) 
#endif
</code></pre>

<p>通过这样的宏定义在打LOGD或者LOGDBG的时候还能自动加上行号！调试起来爽多了！</p>

<h4>C++中清理内存的方式</h4>

<p>由于C++里面需要手动清楚内存，因此我的解决方案是定义一个map，给每个实例一个id，用id把java中的对象和native中的对象绑定起来。在java层定义一个<code>release</code>方法，用来释放本地的对象。
本地的 KEY-对象 映射
<code>static std::map&lt;int, SoundTouchWrapper*&gt; sInstancePool;</code></p>

<h4>关于NDK</h4>

<p>因为安卓的约定是把本地代码放到jni目录下面，但是假如有多个jni lib的时候会比较混乱，所以方案是每一个lib都在jni里面建一个子目录，然后jni里面的Android.mk就可以去构建子目录中的lib了。</p>

<p>jni/Android.mk如下（超级简单）：
<code>makefile
LOCAL_PATH := $(call my-dir)
include $(call all-subdir-makefiles)
</code></p>

<p>然后在子目录soundtouch_module中的Android.mk就可以像一般的Android.mk一样书写规则了。</p>

<p>同时记录一下在Andoroid.mk中使用makefile内建函数<code>wildcard</code>的方法。
有时候源文件是一个目录下的所有.cpp/.c文件，这时候<code>wildcard</code>来统配会很方便。但是Android.mk与普通的Makefile的不同在于：</p>

<ol>
<li>调用Android.mkmingling的${CWD}并不是Android.ml所在的目录。所以Android.mk中有一个变量<code>LOCAL_PATH := $(call my-dir)</code>来记录当前 Android.mk所在的目录。</li>
<li>同时还会把所有的<code>LOCAL_SRC_FILES</code> 前面加上<code>$(LOCAL_PATH)</code>这样写makefile的时候就可以用相对路径了，提供了方便。但是这也导致了坑！</li>
</ol>


<p>因为1，直接使用相对路径会导致<code>wildcard</code>匹配不到源文件。所以最好这么写<code>FILE_LIST := $(wildcard $(LOCAL_PATH)/soundtouch_source/source/SoundTouch/*.cpp)</code>。然而又因为2，这样还是不行的。所以还需要匹配之后把<code>$(LOCAL_PATH)</code>的部分去掉，因此还得这样<code>$(FILE_LIST:$(LOCAL_PATH)/%=%)</code>.</p>

<p>还有个小tip：<code>LOCAL_CFLAGS</code>中最好加上这个定义<code>-fvisibility=hidden</code>这样就不会在动态库中导出不必要的函数了。</p>

<h3>附录<a name="signature">签名</a></h3>

<p>JAVA中的函数签名包括了函数的参数类型，返回值类型。因此即使是重载了的函数，其函数签名也不一样。java编译器就会根据函数签名来判断你调用的到地址哪个方法。
签名中表示类型是这样的</p>

<p>1.基本类型都对应一个大写字母，如下：</p>

<table>
<thead>
<tr>
<th style="text-align:center;"> JAVA类型 </th>
<th style="text-align:center;">  类型签名 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> boolean </td>
<td style="text-align:center;"> Z </td>
</tr>
<tr>
<td style="text-align:center;">byte </td>
<td style="text-align:center;"> B </td>
</tr>
<tr>
<td style="text-align:center;"> char  </td>
<td style="text-align:center;"> C </td>
</tr>
<tr>
<td style="text-align:center;"> short </td>
<td style="text-align:center;"> S </td>
</tr>
<tr>
<td style="text-align:center;"> int </td>
<td style="text-align:center;"> I </td>
</tr>
<tr>
<td style="text-align:center;"> long </td>
<td style="text-align:center;"> J </td>
</tr>
<tr>
<td style="text-align:center;"> float </td>
<td style="text-align:center;"> F </td>
</tr>
<tr>
<td style="text-align:center;"> double </td>
<td style="text-align:center;"> D </td>
</tr>
<tr>
<td style="text-align:center;"> void </td>
<td style="text-align:center;"> V </td>
</tr>
</tbody>
</table>


<p>2.如果是类则是：
L + 类全名（报名中的点(.)用(/)代替）+ ；
比如java.lang.String 对应的是 <code>Ljava/lang/String;</code></p>

<p>3.如果是数组，则在前面加<code>[</code>然后加类型签名，几位数组就加几个<code>[</code>
比如int[]对应<code>[I</code>，boolean[][] 对应 <code>[[Z</code>，java.lang.Class[]对应<code>[Ljava/lang/Class;</code></p>

<p>可以通过javap命令来获取签名（javah生成的头文件注释中也有签名）:<code>javap -x -p &lt;类全名&gt;</code>
坑爹的是java中并不能通过反射来获取方法签名，需要自己写一个帮助类。
（其实我还写了个小程序可以自动生成签名，和JNI_OnLoad中注册要用到的<code>JNINativeMethod</code>数组，从此再也不用糟心的去写那该死的数组了。LOL~~~）</p>

<p>[全文完]</p>

<h4>参考资料</h4>

<p>[1] : <a href="http://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html">Oracle java SE documents</a></p>

<p>[2] : <a href="http://baike.baidu.com/view/6415820.htm">深入理解Android 卷 1</a> 第二章 ，邓凡平著，机械工业出版社</p>

<p>[3]: <a href="http://developer.android.com/training/articles/perf-jni.html">Google Android documents &ndash; JNI Tips</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Run commamd before build in IntelliJ IDEA]]></title>
    <link href="http://LanderlYoung.github.io/blog/2014/10/14/run-commamd-before-build-in-intellij-idea/"/>
    <updated>2014-10-14T17:22:29+08:00</updated>
    <id>http://LanderlYoung.github.io/blog/2014/10/14/run-commamd-before-build-in-intellij-idea</id>
    <content type="html"><![CDATA[<p>I came across <a href="http://stackoverflow.com/questions/8380693/run-e-g-calc-exe-before-build-in-intellij-with-android-projects">this question at <code>StackOverflow</code></a> when I was searching the same question in Google.</p>

<p>I found that you don&rsquo;t need a ant build script, that is just use the IntelliJ default system is just fine. For example, I am doing my project with android-ndk, so I want intelliJ run <code>ndk-build NDK_DEBUG=1 -j4</code> before normal build.
 <!--more--></p>

<p>Here is the solution:</p>

<ol>
<li>Run -> Editor configuration</li>
<li>Select on of you build configuration in the left side of the dialog.</li>
<li>On the right side there is an area marked as <strong>Before Launch</strong></li>
<li>Click the &ldquo;plus&rdquo; button, choose <code>Run External Tool</code> in the popup menu.</li>
<li>Click the &ldquo;plus&rdquo; button in the new popup window</li>
<li>Then you get into the real configuration window.</li>
</ol>


<p>Let me show you some fine picture:</p>

<p>1. Select on of you build configuration in the left side of the dialog.</p>

<p><img src="/assets/storage/run_commamd_before_build_in_intellij/step1.png" alt="Select on of you build configuration in the left side of the dialog." /></p>

<p>2. On the right side there is an area marked as <strong>Before Launch</strong></p>

<p><img src="/assets/storage/run_commamd_before_build_in_intellij/step2.png" alt="On the right side there is an area marked as **Before Launch** " /></p>

<p>3. Select on of you build configuration in the left side of the dialog.</p>

<p> <img src="/assets/storage/run_commamd_before_build_in_intellij/step3.png" alt="enter image description here" /></p>

<p>4. Click the &ldquo;plus&rdquo; button in the new popup window</p>

<p><img src="/assets/storage/run_commamd_before_build_in_intellij/step4.png" alt="Click the &quot;plus&quot; button in the new popup window" /></p>

<p>5. Then you get into the real configuration window.</p>

<p><img src="/assets/storage/run_commamd_before_build_in_intellij/step5.png" alt="Then you get into the real configuration window." /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java(Android)中线程池的使用]]></title>
    <link href="http://LanderlYoung.github.io/blog/2014/09/23/javazhong-xian-cheng-chi-de-shi-yong/"/>
    <updated>2014-09-23T17:39:40+08:00</updated>
    <id>http://LanderlYoung.github.io/blog/2014/09/23/javazhong-xian-cheng-chi-de-shi-yong</id>
    <content type="html"><![CDATA[<p>java SE5提供了<code>java.util.concurrent.Executors</code>类来实现线程池的功能。
<em>Thinking in Java</em> 中这么解释Executors：</p>

<blockquote><p><code>Executors</code>允许你执行异步的任务（task）而不用显式的去管理线程的生命周期。</p></blockquote>

<p>可以说Executors是线程们的管理者，让线程们的生存方式从<strong>放养</strong>变成了<strong>圈养</strong>。Executors来处理一次能同时运行多少个线程，哪个线程在哪个线程的后面执行。总的来说Executors之于线程就像操作系统止于进程一样——管理者与被管理者的关系。</p>

<!--more-->


<p><strong>new Thread的弊端如下：</strong></p>

<ol>
<li><p>每次new Thread新建对象性能差。</p></li>
<li><p>线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或oom。</p></li>
<li><p>缺乏更多功能，如定时执行、定期执行、线程中断。</p></li>
</ol>


<p><strong>相比new Thread，Java提供的四种线程池的好处在于：</strong></p>

<ol>
<li><p>重用存在的线程，减少对象创建、消亡的开销，性能佳。</p></li>
<li><p>可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。</p></li>
<li><p>提供定时执行、定期执行、单线程、并发数控制等功能。</p></li>
</ol>


<p>（上述比较摘自：<a href="http://www.trinea.cn/android/java-android-thread-pool/">http://www.trinea.cn/android/java-android-thread-pool/</a> ）</p>

<p>Executors的使用静态方法来创建相应的<code>ExecutorService</code>接口实现，如下：</p>

<ul>
<li><code>Executors.newCachedThreadPool()</code></li>
<li><code>Executors.newFixedThreadPool()</code></li>
<li><code>Executors.newScheduledThreadPool()</code></li>
<li><code>Executors.newSingleThreadExecutor()</code></li>
</ul>


<p> 这些线程池分别具有不同的能力：
 （Java Concurrency in Pratice——java编程实践，如下解释）</p>

<ul>
<li><p>newFixedThreadPool：创建一个定长的线程池，每提交一个任务就创建一个线程，直到达到池的最大长度，这时线程池会保持长度不再变化（如果一个线程由于未预期的Exception而结束，线程池会补充一个新线程）。</p></li>
<li><p>newCachedThreadPool：创建一个可缓存的线程池，如果当前线程池的长度超过了处理的需要时，它可以灵活的回收空闲的线程，当需要增加时，它可以灵活的添加新的线程，而不会对池的长度作任何限制。</p></li>
<li><p>newSingleThreadExecutor：创建一个单线程化的executor，它只创建唯一的worker线程来执行任务，如果这个线程异常结束，会有另一个取代它。executor会保证任务依照任务队列规定的顺序（FIFO，LIFO，优先级）执行。</p></li>
<li><p>newScheduledThreadPool：创建一个定长的线程池，而且支持定时的以及周期性的任务执行，类似于Timer。</p></li>
</ul>


<h3>ExecutorService的使用</h3>

<p><code>ExecutorService</code>接口继承自Executor的接口定义，他提供了一个线程池应该实现的方法定义，包括运行/提交新任务的方法，结束任务的方法，等等。
<code>ExecutorService</code>的接口有：</p>

<p><strong>提交任务</strong>：</p>

<ul>
<li><p><code>execute</code>（该方法继承自Executor）提交一个runnable接口封装的task，没有返回值</p></li>
<li><p><code>submit</code> 提交一个Callable或者Runnable接口封装的任务，返回一个Feature。</p></li>
<li><p><code>invokeAll</code>传入一个task的容器，执行其包含的所有task。</p></li>
<li><p><code>invokeAny</code>传入一个task的容器，只要其中一个task异常终止，就结束其他task（如果还没执行就不再执行）。</p></li>
</ul>


<p><strong>终止线程池</strong>：</p>

<ul>
<li><p><code>shotdown</code>线程池停止接受新的task，所有已有task执行完后线程池随即关闭</p></li>
<li><p><code>shutdownNow</code>立即终止线程池内的所有task，关闭线程池</p></li>
</ul>


<p><strong>重要的一点</strong>：因为只要有一个非Daemon线程运行着，就会阻止JVM的正常退出。所以线程池一定要记得shutdown！</p>

<p>所以向ExecutorService提交的任务可以是通过<code>Runnable</code>或者<code>Callable</code>接口封装的，其中Callable接口带有一个类型参数，表示返回值的类型。Runable可以使用execute方法，提交。但是Runnable和Callable都可以使用submit方法提交。execute方法没有返回值，submit方法会返回一个Future<T>类型，可以查看任务的执行状态以及获取任务的返回）。所以当你想要一个任务完成时返回一个返回值，submit将是你的不二之选（不要三四千，不要一两千，只要998，submit抱回家）。</p>

<p><strong>关于Future<T></strong></p>

<p>Future功能强大，提供了对任务的各种操作：</p>

<ul>
<li><p><code>isDone()</code> 返回任务是否已经执行完成</p></li>
<li><p><code>get()</code>返回任务的返回值，如果调用get的时候任务还没有完成，则会阻塞知道任务完成</p></li>
<li><p><code>get(long timeout, TimeUnit unit)</code>同上，但是多了个参数，表示阻塞的最大时长。如果在设定的最大阻塞时长内没有指定任务没有顺利结束并返回结果，该方法会抛出一个<code>java.util.concurrent.TimeoutException</code>。</p></li>
<li><p><code>cancel(boolean mayInterruptIfRunning)</code> 尝试去取消一个任务的执行，如果一个任务已经结束，或者已经被取消，或者因为一些什么原因不能够取消，则会取消失败，同时返回false。如果一个任务还没有开始执行就被取消了，那么它将不再执行。如果这个方法被调用的时候，任务正在执行，则将由参数<code>mayInterruptIfRunning</code>决定是否终止正在运行的task。</p></li>
<li><p><code>isCancelled()</code> 返回任务是否已经被取消</p></li>
</ul>


<p>了解过强大的Future是否觉得execute可以去死了，连个Future都返回不了，事实上并非如此，因为submit最终调用的还是execute-_-其实现方法是给execute传入一个RunnableFuture接口的实例（在标准库里有一个很好的实现叫FutureTask），RunnableFuteure接口定义了一个觉有Future功能的Runnalbe。想自定义Future就可以通过这种方式。</p>

<p>submit也是可以传入Runnable的，当传入Runnable时会怎样呢：</p>

<ul>
<li><p>当使用 <code>submit(Runnable)</code>时，返回一个<code>Future&lt;?&gt;</code>，它的get方法会返回null，除此之外其他方法调用表现正常。</p></li>
<li><p>当使用<code>submit(Runnable task, T result)</code>时，返回一个Future<T>，它的get方法会返回result。就好比task是一个会返回result的Callable。</p></li>
</ul>


<p>另外一个小tip就是Executors提供了Runnable转Callabe的静态方法：</p>

<ul>
<li><p><code>public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result)</code>将Runnable转换成能返回result的Callable接口</p></li>
<li><p><code>public static Callable&lt;Object&gt; callable(Runnable task)</code>将Runnable转换成返回null的Callable接口</p></li>
</ul>

]]></content>
  </entry>
  
</feed>
