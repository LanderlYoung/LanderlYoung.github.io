<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Vim | Young_Blog]]></title>
  <link href="http://LanderlYoung.github.io/tags/vim/atom.xml" rel="self"/>
  <link href="http://LanderlYoung.github.io/"/>
  <updated>2015-04-05T01:54:39+08:00</updated>
  <id>http://LanderlYoung.github.io/</id>
  <author>
    <name><![CDATA[LanderlYoung]]></name>
    <email><![CDATA[landerlyoung@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Vim quick reference]]></title>
    <link href="http://LanderlYoung.github.io/blog/2014/05/07/vim-quick-reference/"/>
    <updated>2014-05-07T22:46:32+08:00</updated>
    <id>http://LanderlYoung.github.io/blog/2014/05/07/vim-quick-reference</id>
    <content type="html"><![CDATA[<center>
<h2><b>quickref.txt</b>  For Vim version 7.4.  Last change: 2013 Jun 29</h2>
<p>VIM REFERENCE MANUAL    by Bram Moolenaar</p>
<p>Quick reference guide</p>
</center>


<!--more-->




<div style="font-family:monospace">
&#8220;` cpp
 tag      subject            tag      subject   ~
Q_ct    list of help files      Q_re    Repeating commands
Q_lr    motion: Left-right      Q_km    Key mapping
Q_ud    motion: Up-down         Q_ab    Abbreviations
Q_tm    motion: Text object     Q_op    Options
Q_pa    motion: Pattern searches    Q_ur    Undo/Redo commands
Q_ma    motion: Marks           Q_et    External commands
Q_vm    motion: Various         Q_qf    Quickfix commands
Q_ta    motion: Using tags      Q_vc    Various commands
Q_sc    Scrolling           Q_ce    Ex: Command-line editing
Q_in    insert: Inserting text      Q_ra    Ex: Ranges
Q_ai    insert: Keys            Q_ex    Ex: Special characters
Q_ss    insert: Special keys        Q_st    Starting Vim
Q_di    insert: Digraphs        Q_ed    Editing a file
Q_si    insert: Special inserts     Q_fl    Using the argument list
Q_de    change: Deleting text       Q_wq    Writing and quitting
Q_cm    change: Copying and moving  Q_ac    Automatic commands
Q_ch    change: Changing text       Q_wi    Multi-window commands
Q_co    change: Complex         Q_bu    Buffer list commands
Q_vi    Visual mode         Q_sy    Syntax highlighting
Q_to    Text objects            Q_gu    GUI commands
                    Q_fo    Folding

&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;
N is used to indicate an optional count that can be given before the command.
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;
*Q_lr*      Left-right motions

h   N  h        left (also: CTRL-H, <BS>, or <Left> key)
l   N  l        right (also: <Space> or <Right> key)
0      0        to first character in the line (also: <Home> key)
^      ^        to first non-blank character in the line
$   N  $        to the last character in the line (N-1 lines lower)
               (also: <End> key)
g0     g0       to first character in screen line (differs from &#8220;0&#8221;
               when lines wrap)
g^     g^       to first non-blank character in screen line (differs
               from &#8220;^&#8221; when lines wrap)
g$  N  g$       to last character in screen line (differs from &#8220;$&#8221;
               when lines wrap)
gm     gm       to middle of the screen line
bar N       to column N (default: 1)
f   N  f{char}  to the Nth occurrence of {char} to the right
F   N  F{char}  to the Nth occurrence of {char} to the left
t   N  t{char}  till before the Nth occurrence of {char} to the right
T   N  T{char}  till before the Nth occurrence of {char} to the left
;   N  ;        repeat the last &#8220;f&#8221;, &#8220;F&#8221;, &#8220;t&#8221;, or &#8220;T&#8221; N times
,   N  ,        repeat the last &#8220;f&#8221;, &#8220;F&#8221;, &#8220;t&#8221;, or &#8220;T&#8221; N times in
               opposite direction
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;
*Q_ud*      Up-down motions

k   N  k        up N lines (also: CTRL-P and <Up>)
j   N  j        down N lines (also: CTRL-J, CTRL-N, <NL>, and <Down>)
-   N  -        up N lines, on the first non-blank character
+   N  +        down N lines, on the first non-blank character (also:
               CTRL-M and <CR>)
_   N  _        down N-1 lines, on the first non-blank character
G   N  G        goto line N (default: last line), on the first
               non-blank character
gg  N  gg       goto line N (default: first line), on the first
               non-blank character
N%  N  %        goto line N percentage down in the file; N must be
               given, otherwise it is the % command
gk  N  gk       up N screen lines (differs from &#8220;k&#8221; when line wraps)
gj  N  gj       down N screen lines (differs from &#8220;j&#8221; when line wraps)
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;
*Q_tm*      Text object motions

w   N  w        N words forward
W   N  W        N blank-separated WORDs forward
e   N  e        forward to the end of the Nth word
E   N  E        forward to the end of the Nth blank-separated WORD
b   N  b        N words backward
B   N  B        N blank-separated WORDs backward
ge  N  ge       backward to the end of the Nth word
gE  N  gE       backward to the end of the Nth blank-separated WORD

)   N  )        N sentences forward
(   N  (        N sentences backward
}   N  }        N paragraphs forward
{   N  {        N paragraphs backward
]]  N  ]]       N sections forward, at start of section
[[  N  [[       N sections backward, at start of section
][  N  ][       N sections forward, at end of section
[]  N  []       N sections backward, at end of section
[(  N  [(       N times back to unclosed &#8216;(&#8217;
[{  N  [{       N times back to unclosed &#8216;{&#8217;
[m  N  [m       N times back to start of method (for Java)
[M  N  [M       N times back to end of method (for Java)
])  N  ])       N times forward to unclosed &#8216;)&#8217;
]}  N  ]}       N times forward to unclosed &#8216;}&#8217;
]m  N  ]m       N times forward to start of method (for Java)
]M  N  ]M       N times forward to end of method (for Java)
[#  N  [#       N times back to unclosed &#8220;#if&#8221; or &#8220;#else&#8221;
]#  N  ]#       N times forward to unclosed &#8220;#else&#8221; or &#8220;#endif&#8221;
[star   N  [*       N times back to start of comment &#8220;/*&#8221;
]star   N  ]*       N times forward to end of comment &#8220;*/&#8221;
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;
*Q_pa*      Pattern searches

/   N  /{pattern}[/[offset]]<CR>
            search forward for the Nth occurrence of {pattern}
?   N  ?{pattern}[?[offset]]<CR>
            search backward for the Nth occurrence of {pattern}
/<CR>   N  /<CR>    repeat last search, in the forward direction
?<CR>   N  ?<CR>    repeat last search, in the backward direction
n   N  n        repeat last search
N   N  N        repeat last search, in opposite direction
star    N  *        search forward for the identifier under the cursor
#   N  #        search backward for the identifier under the cursor
gstar   N  g*       like &#8220;*&#8221;, but also find partial matches
g#  N  g#       like &#8220;#&#8221;, but also find partial matches
gd     gd       goto local declaration of identifier under the cursor
gD     gD       goto global declaration of identifier under the cursor

pattern     Special characters in search patterns

            meaning           magic   nomagic   ~
        matches any single character    .   &#46;
               matches start of line    ^   ^
                   matches <EOL>    $   $
               matches start of word    \<  \<
             matches end of word    \>  \>
    matches a single char from the range    [a-z]   \[a-z]
      matches a single char not in the range    [^a-z]  \[^a-z]
          matches an identifier char    \i  \i
           idem but excluding digits    \I  \I
         matches a keyword character    \k  \k
           idem but excluding digits    \K  \K
           matches a file name character    \f  \f
           idem but excluding digits    \F  \F
           matches a printable character    \p  \p
           idem but excluding digits    \P  \P
         matches a white space character    \s  \s
     matches a non-white space character    \S  \S

                   matches <Esc>    \e  \e
                   matches <Tab>    \t  \t
                matches <CR>    \r  \r
                matches <BS>    \b  \b

     matches 0 or more of the preceding atom    *   \*
     matches 1 or more of the preceding atom    \+  \+
    matches 0 or 1 of the preceding atom    \=  \=
    matches 2 to 5 of the preceding atom    \{2,5}  \{2,5}
          separates two alternatives    \   \
        group a pattern into an atom    \(\)    \(\)

search-offset       Offsets allowed after search command

    [num]   [num] lines downwards, in column 1
    +[num]  [num] lines downwards, in column 1
    -[num]  [num] lines upwards, in column 1
    e[+num] [num] characters to the right of the end of the match
    e[-num] [num] characters to the left of the end of the match
    s[+num] [num] characters to the right of the start of the match
    s[-num] [num] characters to the left of the start of the match
    b[+num] [num] identical to s[+num] above (mnemonic: begin)
    b[-num] [num] identical to s[-num] above (mnemonic: begin)
    ;{search-command}   execute {search-command} next
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;
*Q_ma*      Marks and motions

m        m{a-zA-Z}  mark current position with mark {a-zA-Z}
`a       `{a-z} go to mark {a-z} within current file
`A       `{A-Z} go to mark {A-Z} in any file
`0       `{0-9} go to the position where Vim was previously exited
&#8220;       &#8220;     go to the position before the last jump
`quote   `&#8221;     go to the position when last editing this file
`[       `[     go to the start of the previously operated or put text
`]       `]     go to the end of the previously operated or put text
`<       `<     go to the start of the (previous) Visual area
`>       `>     go to the end of the (previous) Visual area
`.       `.     go to the position of the last change in this file
&#8217;        &#8216;{a-zA-Z0-9[]&#8217;&#8221;<>.}
            same as `, but on the first non-blank in the line
:marks  :marks  print the active marks
CTRL-O  N  CTRL-O   go to Nth older position in jump list
CTRL-I  N  CTRL-I   go to Nth newer position in jump list
:ju     :ju[mps]    print the jump list
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;
*Q_vm*      Various motions

%      %        find the next brace, bracket, comment, or &#8220;#if&#8221;/
               &#8220;#else&#8221;/&#8221;#endif&#8221; in this line and go to its match
H   N  H        go to the Nth line in the window, on the first
               non-blank
M      M        go to the middle line in the window, on the first
               non-blank
L   N  L        go to the Nth line from the bottom, on the first
               non-blank

go  N  go           go to Nth byte in the buffer
:go :[range]go[to] [off]    go to [off] byte in the buffer
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;
*Q_ta*      Using tags

:ta      :ta[g][!] {tag}    jump to tag {tag}
:ta      :[count]ta[g][!]   jump to [count]&#8217;th newer tag in tag list
CTRL-]      CTRL-]      jump to the tag under cursor, unless changes
                   have been made
:ts      :ts[elect][!] [tag]    list matching tags and select one to jump to
:tjump   :tj[ump][!] [tag]  jump to tag [tag] or select from list when
                   there are multiple matches
:ltag    :lt[ag][!] [tag]   jump to tag [tag] and add matching tags to the
                   location list

:tags    :tags      print tag list
CTRL-T   N  CTRL-T      jump back from Nth older tag in tag list
:po      :[count]po[p][!]   jump back from [count]&#8217;th older tag in tag list
:tnext   :[count]tn[ext][!] jump to [count]&#8217;th next matching tag
:tp      :[count]tp[revious][!] jump to [count]&#8217;th previous matching tag
:tr      :[count]tr[ewind][!]   jump to [count]&#8217;th matching tag
:tl      :tl[ast][!]        jump to last matching tag

:ptag    :pt[ag] {tag}  open a preview window to show tag {tag}
CTRL-W_}    CTRL-W }        like CTRL-] but show tag in preview window
:pts     :pts[elect]        like &#8220;:tselect&#8221; but show tag in preview window
:ptjump  :ptj[ump]      like &#8220;:tjump&#8221; but show tag in preview window
:pclose  :pc[lose]      close tag preview window
CTRL-W_z    CTRL-W z        close tag preview window
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;
*Q_sc*      Scrolling

CTRL-E  N  CTRL-E   window N lines downwards (default: 1)
CTRL-D  N  CTRL-D   window N lines Downwards (default: 1/2 window)
CTRL-F  N  CTRL-F   window N pages Forwards (downwards)
CTRL-Y  N  CTRL-Y   window N lines upwards (default: 1)
CTRL-U  N  CTRL-U   window N lines Upwards (default: 1/2 window)
CTRL-B  N  CTRL-B   window N pages Backwards (upwards)
z<CR>          z<CR> or zt  redraw, current line at top of window
z.         z.    or zz  redraw, current line at center of window
z-         z-    or zb  redraw, current line at bottom of window

These only work when &#8216;wrap&#8217; is off:
zh      N  zh       scroll screen N characters to the right
zl      N  zl       scroll screen N characters to the left
zH      N  zH       scroll screen half a screenwidth to the right
zL      N  zL       scroll screen half a screenwidth to the left
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;
*Q_in*      Inserting text

a   N  a    append text after the cursor (N times)
A   N  A    append text at the end of the line (N times)
i   N  i    insert text before the cursor (N times) (also: <Insert>)
I   N  I    insert text before the first non-blank in the line (N times)
gI  N  gI   insert text in column 1 (N times)
o   N  o    open a new line below the current line, append text (N times)
O   N  O    open a new line above the current line, append text (N times)
:startinsert  :star[tinsert][!]  start Insert mode, append when [!] used
:startreplace :startr[eplace][!]  start Replace mode, at EOL when [!] used

in Visual block mode:
v_b_I      I    insert the same text in front of all the selected lines
v_b_A      A    append the same text after all the selected lines
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;
*Q_ai*      Insert mode keys

insert-index    alphabetical index of Insert mode commands

leaving Insert mode:
i_<Esc> <Esc>         end Insert mode, back to Normal mode
i_CTRL-C    CTRL-C        like <Esc>, but do not use an abbreviation
i_CTRL-O    CTRL-O {command}  execute {command} and return to Insert mode

moving around:
i_<Up>  cursor keys   move cursor left/right/up/down
i_<S-Left>  shift-left/right  one word left/right
i_<S-Up>    shift-up/down     one screenful backward/forward
i_<End> <End>         cursor after last character in the line
i_<Home>    <Home>        cursor to first character in the line
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;
*Q_ss*      Special keys in Insert mode

i_CTRL-V    CTRL-V {char}..   insert character literally, or enter decimal
                     byte value
i_<NL>  <NL> or <CR> or CTRL-M or CTRL-J
                  begin new line
i_CTRL-E    CTRL-E        insert the character from below the cursor
i_CTRL-Y    CTRL-Y        insert the character from above the cursor

i_CTRL-A    CTRL-A        insert previously inserted text
i_CTRL-@    CTRL-@        insert previously inserted text and stop
                     Insert mode
i_CTRL-R    CTRL-R {0-9a-z%#:.-=&#8221;}  insert the contents of a register

i_CTRL-N    CTRL-N        insert next match of identifier before the
                     cursor
i_CTRL-P    CTRL-P        insert previous match of identifier before
                     the cursor
i_CTRL-X    CTRL-X &#8230;    complete the word before the cursor in
                     various ways

i_<BS>  <BS> or CTRL-H    delete the character before the cursor
i_<Del> <Del>         delete the character under the cursor
i_CTRL-W    CTRL-W        delete word before the cursor
i_CTRL-U    CTRL-U        delete all entered characters in the current
                     line
i_CTRL-T    CTRL-T        insert one shiftwidth of indent in front of
                       the current line
i_CTRL-D    CTRL-D        delete one shiftwidth of indent in front of
                     the current line
i_0_CTRL-D  0 CTRL-D      delete all indent in the current line
i_^_CTRL-D  ^ CTRL-D      delete all indent in the current line,
                     restore indent in next line
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;
*Q_di*      Digraphs

:dig       :dig[raphs]      show current list of digraphs
:dig       :dig[raphs] {char1}{char2} {number} &#8230;
                add digraph(s) to the list

In Insert or Command-line mode:
i_CTRL-K    CTRL-K {char1} {char2}
                  enter digraph
i_digraph   {char1} <BS> {char2}
                  enter digraph if &#8216;digraph&#8217; option set
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;
*Q_si*      Special inserts

:r     :r [file]       insert the contents of [file] below the cursor
:r!    :r! {command}   insert the standard output of {command} below the
                  cursor
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;
*Q_de*      Deleting text

x   N  x        delete N characters under and after the cursor
<Del>   N  <Del>    delete N characters under and after the cursor
X   N  X        delete N characters before the cursor
d   N  d{motion}    delete the text that is moved over with {motion}
v_d    {visual}d    delete the highlighted text
dd  N  dd       delete N lines
D   N  D        delete to the end of the line (and N-1 more lines)
J   N  J        join N-1 lines (delete <EOL>s)
v_J    {visual}J    join the highlighted lines
gJ  N  gJ       like &#8220;J&#8221;, but without inserting spaces
v_gJ       {visual}gJ   like &#8220;{visual}J&#8221;, but without inserting spaces
:d  :[range]d [x]   delete [range] lines [into register x]
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;
*Q_cm*      Copying and moving text

quote     &#8220;{char}   use register {char} for the next delete, yank, or put
:reg      :reg      show the contents of all registers
:reg      :reg {arg}    show the contents of registers mentioned in {arg}
y     N  y{motion}  yank the text moved over with {motion} into a register
v_y      {visual}y  yank the highlighted text into a register
yy    N  yy     yank N lines into a register
Y     N  Y      yank N lines into a register
p     N  p      put a register after the cursor position (N times)
P     N  P      put a register before the cursor position (N times)
]p    N  ]p     like p, but adjust indent to current line
[p    N  [p     like P, but adjust indent to current line
gp    N  gp     like p, but leave cursor after the new text
gP    N  gP     like P, but leave cursor after the new text
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;
*Q_ch*      Changing text

r     N  r{char}    replace N characters with {char}
gr    N  gr{char}   replace N characters without affecting layout
R     N  R      enter Replace mode (repeat the entered text N times)
gR    N  gR     enter virtual Replace mode: Like Replace mode but
               without affecting layout
v_b_r        {visual}r{char}
            in Visual block mode: Replace each char of the
               selected text with {char}

    (change = delete text and enter Insert mode)
c     N  c{motion}  change the text that is moved over with {motion}
v_c      {visual}c  change the highlighted text
cc    N  cc     change N lines
S     N  S      change N lines
C     N  C      change to the end of the line (and N-1 more lines)
s     N  s      change N characters
v_b_c        {visual}c  in Visual block mode: Change each of the selected
               lines with the entered text
v_b_C        {visual}C  in Visual block mode: Change each of the selected
               lines until end-of-line with the entered text

~     N  ~      switch case for N characters and advance cursor
v_~      {visual}~  switch case for highlighted text
v_u      {visual}u  make highlighted text lowercase
v_U      {visual}U  make highlighted text uppercase
g~       g~{motion} switch case for the text that is moved over with
               {motion}
gu       gu{motion} make the text that is moved over with {motion}
               lowercase
gU       gU{motion} make the text that is moved over with {motion}
               uppercase
v_g?         {visual}g? perform rot13 encoding on highlighted text
g?       g?{motion} perform rot13 encoding on the text that is moved over
               with {motion}

CTRL-A  N  CTRL-A   add N to the number at or after the cursor
CTRL-X  N  CTRL-X   subtract N from the number at or after the cursor

<     N  <{motion}  move the lines that are moved over with {motion} one
               shiftwidth left
<<    N  <<     move N lines one shiftwidth left
>     N  >{motion}  move the lines that are moved over with {motion} one
               shiftwidth right
>>    N  >>     move N lines one shiftwidth right
gq    N  gq{motion} format the lines that are moved over with {motion} to
               &#8216;textwidth&#8217; length
:ce   :[range]ce[nter] [width]
            center the lines in [range]
:le   :[range]le[ft] [indent]
            left-align the lines in [range] (with [indent])
:ri   :[range]ri[ght] [width]
            right-align the lines in [range]
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;
*Q_co*      Complex changes

!      N  !{motion}{command}<CR>
            filter the lines that are moved over through {command}
!!     N  !!{command}<CR>
            filter N lines through {command}
v_!       {visual}!{command}<CR>
            filter the highlighted lines through {command}
:range!  :[range]! {command}<CR>
            filter [range] lines through {command}
=      N  ={motion}
            filter the lines that are moved over through &#8216;equalprg&#8217;
==     N  ==    filter N lines through &#8216;equalprg&#8217;
v_=       {visual}=
            filter the highlighted lines through &#8216;equalprg&#8217;
:s     :[range]s[ubstitute]/{pattern}/{string}/[g][c]
            substitute {pattern} by {string} in [range] lines;
               with [g], replace all occurrences of {pattern};
               with [c], confirm each replacement
:s     :[range]s[ubstitute] [g][c]
            repeat previous &#8220;:s&#8221; with new range and options
&         &     Repeat previous &#8220;:s&#8221; on current line without options
:ret       :[range]ret[ab][!] [tabstop]
            set &#8216;tabstop&#8217; to new value and adjust white space
               accordingly
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;
*Q_vi*      Visual mode

visual-index    list of Visual mode commands.

v        v      start highlighting characters  }  move cursor and use
V        V      start highlighting linewise    }  operator to affect
CTRL-V   CTRL-V start highlighting blockwise   }  highlighted text
v_o      o      exchange cursor position with start of highlighting
gv       gv     start highlighting on previous visual area
v_v      v      highlight characters or stop highlighting
v_V      V      highlight linewise or stop highlighting
v_CTRL-V CTRL-V highlight blockwise or stop highlighting
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;
*Q_to*      Text objects (only in Visual mode or after an operator)

v_aw       N  aw    Select &#8220;a word&#8221;
v_iw       N  iw    Select &#8220;inner word&#8221;
v_aW       N  aW    Select &#8220;a WORD&#8221;
v_iW       N  iW    Select &#8220;inner WORD&#8221;
v_as       N  as    Select &#8220;a sentence&#8221;
v_is       N  is    Select &#8220;inner sentence&#8221;
v_ap       N  ap    Select &#8220;a paragraph&#8221;
v_ip       N  ip    Select &#8220;inner paragraph&#8221;
v_ab       N  ab    Select &#8220;a block&#8221; (from &#8220;[(&#8221; to &#8220;])&#8221;)
v_ib       N  ib    Select &#8220;inner block&#8221; (from &#8220;[(&#8221; to &#8220;])&#8221;)
v_aB       N  aB    Select &#8220;a Block&#8221; (from &#8220;[{&#8221; to &#8220;]}&#8221;)
v_iB       N  iB    Select &#8220;inner Block&#8221; (from &#8220;[{&#8221; to &#8220;]}&#8221;)
v_a>       N  a>    Select &#8220;a <> block&#8221;
v_i>       N  i>    Select &#8220;inner <> block&#8221;
v_at       N  at    Select &#8220;a tag block&#8221; (from <aaa> to </aaa>)
v_it       N  it    Select &#8220;inner tag block&#8221; (from <aaa> to </aaa>)
v_a&#8217;       N  a&#8217;    Select &#8220;a single quoted string&#8221;
v_i&#8217;       N  i&#8217;    Select &#8220;inner single quoted string&#8221;
v_aquote N  a&#8221;  Select &#8220;a double quoted string&#8221;
v_iquote N  i&#8221;  Select &#8220;inner double quoted string&#8221;
v_a`       N  a`    Select &#8220;a backward quoted string&#8221;
v_i`       N  i`    Select &#8220;inner backward quoted string&#8221;

&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;
*Q_re*      Repeating commands

.      N  .     repeat last change (with count replaced with N)
q         q{a-z}    record typed characters into register {a-z}
q         q{A-Z}    record typed characters, appended to register {a-z}
q         q     stop recording
@      N  @{a-z}    execute the contents of register {a-z} (N times)
@@     N  @@       repeat previous @{a-z} (N times)
:@     :@{a-z}  execute the contents of register {a-z} as an Ex
               command
:@@    :@@      repeat previous :@{a-z}
:g     :[range]g[lobal]/{pattern}/[cmd]
            execute Ex command [cmd] (default: &#8220;:p&#8221;) on the lines
               within [range] where {pattern} matches
:g     :[range]g[lobal]!/{pattern}/[cmd]
            execute Ex command [cmd] (default: &#8220;:p&#8221;) on the lines
               within [range] where {pattern} does NOT match
:so    :so[urce] {file}
            read Ex commands from {file}
:so    :so[urce]! {file}
            read Vim commands from {file}
:sl    :sl[eep] [sec]
            don&#8217;t do anything for [sec] seconds
gs     N  gs    goto Sleep for N seconds
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;
*Q_km*      Key mapping

:map       :ma[p] {lhs} {rhs}     map {lhs} to {rhs} in Normal and Visual mode
:map!      :ma[p]! {lhs} {rhs}  map {lhs} to {rhs} in Insert and Command-line
                     mode
:noremap   :no[remap][!] {lhs} {rhs}
                  same as &#8220;:map&#8221;, no remapping for this {rhs}
:unmap     :unm[ap] {lhs}     remove the mapping of {lhs} for Normal and
                     Visual mode
:unmap!    :unm[ap]! {lhs}    remove the mapping of {lhs} for Insert and
                     Command-line mode
:map_l     :ma[p] [lhs]   list mappings (starting with [lhs]) for
                     Normal and Visual mode
:map_l!    :ma[p]! [lhs]      list mappings (starting with [lhs]) for
                     Insert and Command-line mode
:cmap      :cmap/:cunmap/:cnoremap
                  like &#8220;:map!&#8221;/&#8221;:unmap!&#8221;/&#8221;:noremap!&#8221; but for
                     Command-line mode only
:imap      :imap/:iunmap/:inoremap
                  like &#8220;:map!&#8221;/&#8221;:unmap!&#8221;/&#8221;:noremap!&#8221; but for
                     Insert mode only
:nmap      :nmap/:nunmap/:nnoremap
                  like &#8220;:map&#8221;/&#8221;:unmap&#8221;/&#8221;:noremap&#8221; but for
                     Normal mode only
:vmap      :vmap/:vunmap/:vnoremap
                  like &#8220;:map&#8221;/&#8221;:unmap&#8221;/&#8221;:noremap&#8221; but for
                     Visual mode only
:omap      :omap/:ounmap/:onoremap
                  like &#8220;:map&#8221;/&#8221;:unmap&#8221;/&#8221;:noremap&#8221; but only for
                     when an operator is pending
:mapc      :mapc[lear]    remove mappings for Normal and Visual mode
:mapc      :mapc[lear]!   remove mappings for Insert and Cmdline mode
:imapc     :imapc[lear]   remove mappings for Insert mode
:vmapc     :vmapc[lear]   remove mappings for Visual mode
:omapc     :omapc[lear]   remove mappings for Operator-pending mode
:nmapc     :nmapc[lear]   remove mappings for Normal mode
:cmapc     :cmapc[lear]   remove mappings for Cmdline mode
:mkexrc    :mk[exrc][!] [file]  write current mappings, abbreviations, and
                     settings to [file] (default: &#8220;.exrc&#8221;;
                     use ! to overwrite)
:mkvimrc   :mkv[imrc][!] [file]
                  same as &#8220;:mkexrc&#8221;, but with default &#8220;.vimrc&#8221;
:mksession :mks[ession][!] [file]
                  like &#8220;:mkvimrc&#8221;, but store current files,
                     windows, etc. too, to be able to continue
                     this session later
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;
*Q_ab*      Abbreviations

:abbreviate :ab[breviate] {lhs} {rhs}  add abbreviation for {lhs} to {rhs}
:abbreviate :ab[breviate] {lhs}    show abbr&#8217;s that start with {lhs}
:abbreviate :ab[breviate]          show all abbreviations
:unabbreviate   :una[bbreviate] {lhs}      remove abbreviation for {lhs}
:noreabbrev :norea[bbrev] [lhs] [rhs]  like &#8220;:ab&#8221;, but don&#8217;t remap [rhs]
:iabbrev    :iab/:iunab/:inoreab       like &#8220;:ab&#8221;, but only for Insert mode
:cabbrev    :cab/:cunab/:cnoreab       like &#8220;:ab&#8221;, but only for
                        Command-line mode
:abclear    :abc[lear]         remove all abbreviations
:cabclear   :cabc[lear]        remove all abbr&#8217;s for Cmdline mode
:iabclear   :iabc[lear]        remove all abbr&#8217;s for Insert mode
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;
*Q_op*      Options

:set        :se[t]            show all modified options
:set        :se[t] all        show all non-termcap options
:set        :se[t] termcap        show all termcap options
:set        :se[t] {option}       set boolean option (switch it on),
                      show string or number option
:set        :se[t] no{option}     reset boolean option (switch it off)
:set        :se[t] inv{option}    invert boolean option
:set        :se[t] {option}={value}   set string/number option to {value}
:set        :se[t] {option}+={value}  append {value} to string option, add
                      {value} to number option
:set        :se[t] {option}-={value}  remove {value} to string option,
                      subtract {value} from number option
:set        :se[t] {option}?      show value of {option}
:set        :se[t] {option}&      reset {option} to its default value

:setlocal   :setl[ocal]       like &#8220;:set&#8221; but set the local value
                      for options that have one
:setglobal  :setg[lobal]          like &#8220;:set&#8221; but set the global value
                      of a local option

:fix        :fix[del]         set value of &#8216;t_kD&#8217; according to
                      value of &#8216;t_kb&#8217;
:options    :opt[ions]        open a new window to view and set
                      options, grouped by functionality,
                      a one line explanation and links to
                      the help

Short explanation of each option:       *option-list*
&#8216;aleph&#8217;       &#8216;al&#8217;      ASCII code of the letter Aleph (Hebrew)
&#8216;allowrevins&#8217;     &#8216;ari&#8217;     allow CTRL-_ in Insert and Command-line mode
&#8216;altkeymap&#8217;   &#8216;akm&#8217;     for default second language (Farsi/Hebrew)
&#8216;ambiwidth&#8217;   &#8216;ambw&#8217;    what to do with Unicode chars of ambiguous width
&#8216;antialias&#8217;   &#8216;anti&#8217;    Mac OS X: use smooth, antialiased fonts
&#8216;autochdir&#8217;   &#8216;acd&#8217;     change directory to the file in the current window
&#8216;arabic&#8217;      &#8216;arab&#8217;    for Arabic as a default second language
&#8216;arabicshape&#8217;     &#8216;arshape&#8217; do shaping for Arabic characters
&#8216;autoindent&#8217;      &#8216;ai&#8217;      take indent for new line from previous line
&#8216;autoread&#8217;    &#8216;ar&#8217;      autom. read file when changed outside of Vim
&#8216;autowrite&#8217;   &#8216;aw&#8217;      automatically write file if changed
&#8216;autowriteall&#8217;    &#8216;awa&#8217;     as &#8216;autowrite&#8217;, but works with more commands
&#8216;background&#8217;      &#8216;bg&#8217;      &#8220;dark&#8221; or &#8220;light&#8221;, used for highlight colors
&#8216;backspace&#8217;   &#8216;bs&#8217;      how backspace works at start of line
&#8216;backup&#8217;      &#8216;bk&#8217;      keep backup file after overwriting a file
&#8216;backupcopy&#8217;      &#8216;bkc&#8217;     make backup as a copy, don&#8217;t rename the file
&#8216;backupdir&#8217;   &#8216;bdir&#8217;    list of directories for the backup file
&#8216;backupext&#8217;   &#8216;bex&#8217;     extension used for the backup file
&#8216;backupskip&#8217;      &#8216;bsk&#8217;     no backup for files that match these patterns
&#8216;balloondelay&#8217;    &#8216;bdlay&#8217;   delay in mS before a balloon may pop up
&#8216;ballooneval&#8217;     &#8216;beval&#8217;   switch on balloon evaluation
&#8216;balloonexpr&#8217;     &#8216;bexpr&#8217;   expression to show in balloon
&#8216;binary&#8217;      &#8216;bin&#8217;     read/write/edit file in binary mode
&#8216;bioskey&#8217;     &#8216;biosk&#8217;   MS-DOS: use bios calls for input characters
&#8216;bomb&#8217;              prepend a Byte Order Mark to the file
&#8216;breakat&#8217;     &#8216;brk&#8217;     characters that may cause a line break
&#8216;browsedir&#8217;   &#8216;bsdir&#8217;   which directory to start browsing in
&#8216;bufhidden&#8217;   &#8216;bh&#8217;      what to do when buffer is no longer in window
&#8216;buflisted&#8217;   &#8216;bl&#8217;      whether the buffer shows up in the buffer list
&#8216;buftype&#8217;     &#8216;bt&#8217;      special type of buffer
&#8216;casemap&#8217;     &#8216;cmp&#8217;     specifies how case of letters is changed
&#8216;cdpath&#8217;      &#8216;cd&#8217;      list of directories searched with &#8220;:cd&#8221;
&#8216;cedit&#8217;             key used to open the command-line window
&#8216;charconvert&#8217;     &#8216;ccv&#8217;     expression for character encoding conversion
&#8216;cindent&#8217;     &#8216;cin&#8217;     do C program indenting
&#8216;cinkeys&#8217;     &#8216;cink&#8217;    keys that trigger indent when &#8216;cindent&#8217; is set
&#8216;cinoptions&#8217;      &#8216;cino&#8217;    how to do indenting when &#8216;cindent&#8217; is set
&#8216;cinwords&#8217;    &#8216;cinw&#8217;    words where &#8216;si&#8217; and &#8216;cin&#8217; add an indent
&#8216;clipboard&#8217;   &#8216;cb&#8217;      use the clipboard as the unnamed register
&#8216;cmdheight&#8217;   &#8216;ch&#8217;      number of lines to use for the command-line
&#8216;cmdwinheight&#8217;    &#8216;cwh&#8217;     height of the command-line window
&#8216;colorcolumn&#8217;     &#8216;cc&#8217;      columns to highlight
&#8216;columns&#8217;     &#8216;co&#8217;      number of columns in the display
&#8216;comments&#8217;    &#8216;com&#8217;     patterns that can start a comment line
&#8216;commentstring&#8217;   &#8216;cms&#8217;     template for comments; used for fold marker
&#8216;compatible&#8217;      &#8216;cp&#8217;      behave Vi-compatible as much as possible
&#8216;complete&#8217;    &#8216;cpt&#8217;     specify how Insert mode completion works
&#8216;completefunc&#8217;    &#8216;cfu&#8217;     function to be used for Insert mode completion
&#8216;completeopt&#8217;     &#8216;cot&#8217;     options for Insert mode completion
&#8216;concealcursor&#8217;   &#8216;cocu&#8217;    whether concealable text is hidden in cursor line
&#8216;conceallevel&#8217;    &#8216;cole&#8217;    whether concealable text is shown or hidden
&#8216;confirm&#8217;     &#8216;cf&#8217;      ask what to do about unsaved/read-only files
&#8216;conskey&#8217;     &#8216;consk&#8217;   get keys directly from console (MS-DOS only)
&#8216;copyindent&#8217;      &#8216;ci&#8217;      make &#8216;autoindent&#8217; use existing indent structure
&#8216;cpoptions&#8217;   &#8216;cpo&#8217;     flags for Vi-compatible behavior
&#8216;cryptmethod&#8217;     &#8216;cm&#8217;      type of encryption to use for file writing
&#8216;cscopepathcomp&#8217;  &#8216;cspc&#8217;    how many components of the path to show
&#8216;cscopeprg&#8217;       &#8216;csprg&#8217;   command to execute cscope
&#8216;cscopequickfix&#8217;  &#8216;csqf&#8217;    use quickfix window for cscope results
&#8216;cscoperelative&#8217;  &#8216;csre&#8217;    Use cscope.out path basename as prefix
&#8216;cscopetag&#8217;       &#8216;cst&#8217;     use cscope for tag commands
&#8216;cscopetagorder&#8217;  &#8216;csto&#8217;    determines &#8220;:cstag&#8221; search order
&#8216;cscopeverbose&#8217;   &#8216;csverb&#8217;  give messages when adding a cscope database
&#8216;cursorbind&#8217;      &#8216;crb&#8217;     move cursor in window as it moves in other windows
&#8216;cursorcolumn&#8217;    &#8216;cuc&#8217;     highlight the screen column of the cursor
&#8216;cursorline&#8217;      &#8216;cul&#8217;     highlight the screen line of the cursor
&#8216;debug&#8217;             set to &#8220;msg&#8221; to see all error messages
&#8216;define&#8217;      &#8216;def&#8217;     pattern to be used to find a macro definition
&#8216;delcombine&#8217;      &#8216;deco&#8217;    delete combining characters on their own
&#8216;dictionary&#8217;      &#8216;dict&#8217;    list of file names used for keyword completion
&#8216;diff&#8217;              use diff mode for the current window
&#8216;diffexpr&#8217;    &#8216;dex&#8217;     expression used to obtain a diff file
&#8216;diffopt&#8217;     &#8216;dip&#8217;     options for using diff mode
&#8216;digraph&#8217;     &#8216;dg&#8217;      enable the entering of digraphs in Insert mode
&#8216;directory&#8217;   &#8216;dir&#8217;     list of directory names for the swap file
&#8216;display&#8217;     &#8216;dy&#8217;      list of flags for how to display text
&#8216;eadirection&#8217;     &#8216;ead&#8217;     in which direction &#8216;equalalways&#8217; works
&#8216;edcompatible&#8217;    &#8216;ed&#8217;      toggle flags of &#8220;:substitute&#8221; command
&#8216;encoding&#8217;    &#8216;enc&#8217;     encoding used internally
&#8216;endofline&#8217;   &#8216;eol&#8217;     write <EOL> for last line in file
&#8216;equalalways&#8217;     &#8216;ea&#8217;      windows are automatically made the same size
&#8216;equalprg&#8217;    &#8216;ep&#8217;      external program to use for &#8220;=&#8221; command
&#8216;errorbells&#8217;      &#8216;eb&#8217;      ring the bell for error messages
&#8216;errorfile&#8217;   &#8216;ef&#8217;      name of the errorfile for the QuickFix mode
&#8216;errorformat&#8217;     &#8216;efm&#8217;     description of the lines in the error file
&#8216;esckeys&#8217;     &#8216;ek&#8217;      recognize function keys in Insert mode
&#8216;eventignore&#8217;     &#8216;ei&#8217;      autocommand events that are ignored
&#8216;expandtab&#8217;   &#8216;et&#8217;      use spaces when <Tab> is inserted
&#8216;exrc&#8217;        &#8216;ex&#8217;      read .vimrc and .exrc in the current directory
&#8216;fileencoding&#8217;    &#8216;fenc&#8217;    file encoding for multi-byte text
&#8216;fileencodings&#8217;   &#8216;fencs&#8217;   automatically detected character encodings
&#8216;fileformat&#8217;      &#8216;ff&#8217;      file format used for file I/O
&#8216;fileformats&#8217;     &#8216;ffs&#8217;     automatically detected values for &#8216;fileformat&#8217;
&#8216;fileignorecase&#8217;  &#8216;fic&#8217;     ignore case when using file names
&#8216;filetype&#8217;    &#8216;ft&#8217;      type of file, used for autocommands
&#8216;fillchars&#8217;   &#8216;fcs&#8217;     characters to use for displaying special items
&#8216;fkmap&#8217;       &#8216;fk&#8217;      Farsi keyboard mapping
&#8216;foldclose&#8217;   &#8216;fcl&#8217;     close a fold when the cursor leaves it
&#8216;foldcolumn&#8217;      &#8216;fdc&#8217;     width of the column used to indicate folds
&#8216;foldenable&#8217;      &#8216;fen&#8217;     set to display all folds open
&#8216;foldexpr&#8217;    &#8216;fde&#8217;     expression used when &#8216;foldmethod&#8217; is &#8220;expr&#8221;
&#8216;foldignore&#8217;      &#8216;fdi&#8217;     ignore lines when &#8216;foldmethod&#8217; is &#8220;indent&#8221;
&#8216;foldlevel&#8217;   &#8216;fdl&#8217;     close folds with a level higher than this
&#8216;foldlevelstart&#8217;  &#8216;fdls&#8217;    &#8216;foldlevel&#8217; when starting to edit a file
&#8216;foldmarker&#8217;      &#8216;fmr&#8217;     markers used when &#8216;foldmethod&#8217; is &#8220;marker&#8221;
&#8216;foldmethod&#8217;      &#8216;fdm&#8217;     folding type
&#8216;foldminlines&#8217;    &#8216;fml&#8217;     minimum number of lines for a fold to be closed
&#8216;foldnestmax&#8217;     &#8216;fdn&#8217;     maximum fold depth
&#8216;foldopen&#8217;    &#8216;fdo&#8217;     for which commands a fold will be opened
&#8216;foldtext&#8217;    &#8216;fdt&#8217;     expression used to display for a closed fold
&#8216;formatlistpat&#8217;   &#8216;flp&#8217;     pattern used to recognize a list header
&#8216;formatoptions&#8217;   &#8216;fo&#8217;      how automatic formatting is to be done
&#8216;formatprg&#8217;   &#8216;fp&#8217;      name of external program used with &#8220;gq&#8221; command
&#8216;formatexpr&#8217;      &#8216;fex&#8217;     expression used with &#8220;gq&#8221; command
&#8216;fsync&#8217;       &#8216;fs&#8217;      whether to invoke fsync() after file write
&#8216;gdefault&#8217;    &#8216;gd&#8217;      the &#8220;:substitute&#8221; flag &#8216;g&#8217; is default on
&#8216;grepformat&#8217;      &#8216;gfm&#8217;     format of &#8216;grepprg&#8217; output
&#8216;grepprg&#8217;     &#8216;gp&#8217;      program to use for &#8220;:grep&#8221;
&#8216;guicursor&#8217;   &#8216;gcr&#8217;     GUI: settings for cursor shape and blinking
&#8216;guifont&#8217;     &#8216;gfn&#8217;     GUI: Name(s) of font(s) to be used
&#8216;guifontset&#8217;      &#8216;gfs&#8217;     GUI: Names of multi-byte fonts to be used
&#8216;guifontwide&#8217;     &#8216;gfw&#8217;     list of font names for double-wide characters
&#8216;guiheadroom&#8217;     &#8216;ghr&#8217;     GUI: pixels room for window decorations
&#8216;guioptions&#8217;      &#8216;go&#8217;      GUI: Which components and options are used
&#8216;guipty&#8217;            GUI: try to use a pseudo-tty for &#8220;:!&#8221; commands
&#8216;guitablabel&#8217;     &#8216;gtl&#8217;     GUI: custom label for a tab page
&#8216;guitabtooltip&#8217;   &#8216;gtt&#8217;     GUI: custom tooltip for a tab page
&#8216;helpfile&#8217;    &#8216;hf&#8217;      full path name of the main help file
&#8216;helpheight&#8217;      &#8216;hh&#8217;      minimum height of a new help window
&#8216;helplang&#8217;    &#8216;hlg&#8217;     preferred help languages
&#8216;hidden&#8217;      &#8216;hid&#8217;     don&#8217;t unload buffer when it is abandoned
&#8216;highlight&#8217;   &#8216;hl&#8217;      sets highlighting mode for various occasions
&#8216;hlsearch&#8217;    &#8216;hls&#8217;     highlight matches with last search pattern
&#8216;history&#8217;     &#8216;hi&#8217;      number of command-lines that are remembered
&#8216;hkmap&#8217;       &#8216;hk&#8217;      Hebrew keyboard mapping
&#8216;hkmapp&#8217;      &#8216;hkp&#8217;     phonetic Hebrew keyboard mapping
&#8216;icon&#8217;              let Vim set the text of the window icon
&#8216;iconstring&#8217;            string to use for the Vim icon text
&#8216;ignorecase&#8217;      &#8216;ic&#8217;      ignore case in search patterns
&#8216;imactivatekey&#8217;   &#8216;imak&#8217;    key that activates the X input method
&#8216;imactivatefunc&#8217;  &#8216;imaf&#8217;    function to enable/disable the X input method
&#8216;imcmdline&#8217;   &#8216;imc&#8217;     use IM when starting to edit a command line
&#8216;imdisable&#8217;   &#8216;imd&#8217;     do not use the IM in any mode
&#8216;iminsert&#8217;    &#8216;imi&#8217;     use :lmap or IM in Insert mode
&#8216;imsearch&#8217;    &#8216;ims&#8217;     use :lmap or IM when typing a search pattern
&#8216;imstatusfunc&#8217;    &#8216;imsf&#8217;    function to obtain X input method status
&#8216;include&#8217;     &#8216;inc&#8217;     pattern to be used to find an include file
&#8216;includeexpr&#8217;     &#8216;inex&#8217;    expression used to process an include line
&#8216;incsearch&#8217;   &#8216;is&#8217;      highlight match while typing search pattern
&#8216;indentexpr&#8217;      &#8216;inde&#8217;    expression used to obtain the indent of a line
&#8216;indentkeys&#8217;      &#8216;indk&#8217;    keys that trigger indenting with &#8216;indentexpr&#8217;
&#8216;infercase&#8217;   &#8216;inf&#8217;     adjust case of match for keyword completion
&#8216;insertmode&#8217;      &#8216;im&#8217;      start the edit of a file in Insert mode
&#8216;isfname&#8217;     &#8216;isf&#8217;     characters included in file names and pathnames
&#8216;isident&#8217;     &#8216;isi&#8217;     characters included in identifiers
&#8216;iskeyword&#8217;   &#8216;isk&#8217;     characters included in keywords
&#8216;isprint&#8217;     &#8216;isp&#8217;     printable characters
&#8216;joinspaces&#8217;      &#8216;js&#8217;      two spaces after a period with a join command
&#8216;key&#8217;               encryption key
&#8216;keymap&#8217;      &#8216;kmp&#8217;     name of a keyboard mapping
&#8216;keymodel&#8217;    &#8216;km&#8217;      enable starting/stopping selection with keys
&#8216;keywordprg&#8217;      &#8216;kp&#8217;      program to use for the &#8220;K&#8221; command
&#8216;langmap&#8217;     &#8216;lmap&#8217;    alphabetic characters for other language mode
&#8216;langmenu&#8217;    &#8216;lm&#8217;      language to be used for the menus
&#8216;laststatus&#8217;      &#8216;ls&#8217;      tells when last window has status lines
&#8216;lazyredraw&#8217;      &#8216;lz&#8217;      don&#8217;t redraw while executing macros
&#8216;linebreak&#8217;   &#8216;lbr&#8217;     wrap long lines at a blank
&#8216;lines&#8217;             number of lines in the display
&#8216;linespace&#8217;   &#8216;lsp&#8217;     number of pixel lines to use between characters
&#8216;lisp&#8217;              automatic indenting for Lisp
&#8216;lispwords&#8217;   &#8216;lw&#8217;      words that change how lisp indenting works
&#8216;list&#8217;              show <Tab> and <EOL>
&#8216;listchars&#8217;   &#8216;lcs&#8217;     characters for displaying in list mode
&#8216;loadplugins&#8217;     &#8216;lpl&#8217;     load plugin scripts when starting up
&#8216;macatsui&#8217;          Mac GUI: use ATSUI text drawing
&#8216;magic&#8217;             changes special characters in search patterns
&#8216;makeef&#8217;      &#8216;mef&#8217;     name of the errorfile for &#8220;:make&#8221;
&#8216;makeprg&#8217;     &#8216;mp&#8217;      program to use for the &#8220;:make&#8221; command
&#8216;matchpairs&#8217;      &#8216;mps&#8217;     pairs of characters that &#8220;%&#8221; can match
&#8216;matchtime&#8217;   &#8216;mat&#8217;     tenths of a second to show matching paren
&#8216;maxcombine&#8217;      &#8216;mco&#8217;     maximum nr of combining characters displayed
&#8216;maxfuncdepth&#8217;    &#8216;mfd&#8217;     maximum recursive depth for user functions
&#8216;maxmapdepth&#8217;     &#8216;mmd&#8217;     maximum recursive depth for mapping
&#8216;maxmem&#8217;      &#8216;mm&#8217;      maximum memory (in Kbyte) used for one buffer
&#8216;maxmempattern&#8217;   &#8216;mmp&#8217;     maximum memory (in Kbyte) used for pattern search
&#8216;maxmemtot&#8217;   &#8216;mmt&#8217;     maximum memory (in Kbyte) used for all buffers
&#8216;menuitems&#8217;   &#8216;mis&#8217;     maximum number of items in a menu
&#8216;mkspellmem&#8217;      &#8216;msm&#8217;     memory used before :mkspell compresses the tree
&#8216;modeline&#8217;    &#8216;ml&#8217;      recognize modelines at start or end of file
&#8216;modelines&#8217;   &#8216;mls&#8217;     number of lines checked for modelines
&#8216;modifiable&#8217;      &#8216;ma&#8217;      changes to the text are not possible
&#8216;modified&#8217;    &#8216;mod&#8217;     buffer has been modified
&#8216;more&#8217;              pause listings when the whole screen is filled
&#8216;mouse&#8217;             enable the use of mouse clicks
&#8216;mousefocus&#8217;      &#8216;mousef&#8217;  keyboard focus follows the mouse
&#8216;mousehide&#8217;   &#8216;mh&#8217;      hide mouse pointer while typing
&#8216;mousemodel&#8217;      &#8216;mousem&#8217;  changes meaning of mouse buttons
&#8216;mouseshape&#8217;      &#8216;mouses&#8217;  shape of the mouse pointer in different modes
&#8216;mousetime&#8217;   &#8216;mouset&#8217;  max time between mouse double-click
&#8216;mzquantum&#8217;   &#8216;mzq&#8217;     the interval between polls for MzScheme threads
&#8216;nrformats&#8217;   &#8216;nf&#8217;      number formats recognized for CTRL-A command
&#8216;number&#8217;      &#8216;nu&#8217;      print the line number in front of each line
&#8216;numberwidth&#8217;     &#8216;nuw&#8217;     number of columns used for the line number
&#8216;omnifunc&#8217;    &#8216;ofu&#8217;     function for filetype-specific completion
&#8216;opendevice&#8217;      &#8216;odev&#8217;    allow reading/writing devices on MS-Windows
&#8216;operatorfunc&#8217;    &#8216;opfunc&#8217;  function to be called for g@ operator
&#8216;osfiletype&#8217;      &#8216;oft&#8217;     no longer supported
&#8216;paragraphs&#8217;      &#8216;para&#8217;    nroff macros that separate paragraphs
&#8216;paste&#8217;             allow pasting text
&#8216;pastetoggle&#8217;     &#8216;pt&#8217;      key code that causes &#8216;paste&#8217; to toggle
&#8216;patchexpr&#8217;   &#8216;pex&#8217;     expression used to patch a file
&#8216;patchmode&#8217;   &#8216;pm&#8217;      keep the oldest version of a file
&#8216;path&#8217;        &#8216;pa&#8217;      list of directories searched with &#8220;gf&#8221; et.al.
&#8216;preserveindent&#8217;  &#8216;pi&#8217;      preserve the indent structure when reindenting
&#8216;previewheight&#8217;   &#8216;pvh&#8217;     height of the preview window
&#8216;previewwindow&#8217;   &#8216;pvw&#8217;     identifies the preview window
&#8216;printdevice&#8217;     &#8216;pdev&#8217;    name of the printer to be used for :hardcopy
&#8216;printencoding&#8217;   &#8216;penc&#8217;    encoding to be used for printing
&#8216;printexpr&#8217;   &#8216;pexpr&#8217;   expression used to print PostScript for :hardcopy
&#8216;printfont&#8217;   &#8216;pfn&#8217;     name of the font to be used for :hardcopy
&#8216;printheader&#8217;     &#8216;pheader&#8217; format of the header used for :hardcopy
&#8216;printmbcharset&#8217;  &#8216;pmbcs&#8217;   CJK character set to be used for :hardcopy
&#8216;printmbfont&#8217;     &#8216;pmbfn&#8217;   font names to be used for CJK output of :hardcopy
&#8216;printoptions&#8217;    &#8216;popt&#8217;    controls the format of :hardcopy output
&#8216;pumheight&#8217;   &#8216;ph&#8217;      maximum height of the popup menu
&#8216;quoteescape&#8217;     &#8216;qe&#8217;      escape characters used in a string
&#8216;readonly&#8217;    &#8216;ro&#8217;      disallow writing the buffer
&#8216;redrawtime&#8217;      &#8216;rdt&#8217;     timeout for &#8216;hlsearch&#8217; and :match highlighting
&#8216;regexpengine&#8217;    &#8216;re&#8217;      default regexp engine to use
&#8216;relativenumber&#8217;  &#8216;rnu&#8217;     show relative line number in front of each line
&#8216;remap&#8217;             allow mappings to work recursively
&#8216;report&#8217;            threshold for reporting nr. of lines changed
&#8216;restorescreen&#8217;   &#8216;rs&#8217;      Win32: restore screen when exiting
&#8216;revins&#8217;      &#8216;ri&#8217;      inserting characters will work backwards
&#8216;rightleft&#8217;   &#8216;rl&#8217;      window is right-to-left oriented
&#8216;rightleftcmd&#8217;    &#8216;rlc&#8217;     commands for which editing works right-to-left
&#8216;ruler&#8217;       &#8216;ru&#8217;      show cursor line and column in the status line
&#8216;rulerformat&#8217;     &#8216;ruf&#8217;     custom format for the ruler
&#8216;runtimepath&#8217;     &#8216;rtp&#8217;     list of directories used for runtime files
&#8216;scroll&#8217;      &#8216;scr&#8217;     lines to scroll with CTRL-U and CTRL-D
&#8216;scrollbind&#8217;      &#8216;scb&#8217;     scroll in window as other windows scroll
&#8216;scrolljump&#8217;      &#8216;sj&#8217;      minimum number of lines to scroll
&#8216;scrolloff&#8217;   &#8216;so&#8217;      minimum nr. of lines above and below cursor
&#8216;scrollopt&#8217;   &#8216;sbo&#8217;     how &#8216;scrollbind&#8217; should behave
&#8216;sections&#8217;    &#8216;sect&#8217;    nroff macros that separate sections
&#8216;secure&#8217;            secure mode for reading .vimrc in current dir
&#8216;selection&#8217;   &#8216;sel&#8217;     what type of selection to use
&#8216;selectmode&#8217;      &#8216;slm&#8217;     when to use Select mode instead of Visual mode
&#8216;sessionoptions&#8217;  &#8216;ssop&#8217;    options for :mksession
&#8216;shell&#8217;       &#8216;sh&#8217;      name of shell to use for external commands
&#8216;shellcmdflag&#8217;    &#8216;shcf&#8217;    flag to shell to execute one command
&#8216;shellpipe&#8217;   &#8216;sp&#8217;      string to put output of &#8220;:make&#8221; in error file
&#8216;shellquote&#8217;      &#8216;shq&#8217;     quote character(s) for around shell command
&#8216;shellredir&#8217;      &#8216;srr&#8217;     string to put output of filter in a temp file
&#8216;shellslash&#8217;      &#8216;ssl&#8217;     use forward slash for shell file names
&#8216;shelltemp&#8217;   &#8216;stmp&#8217;    whether to use a temp file for shell commands
&#8216;shelltype&#8217;   &#8216;st&#8217;      Amiga: influences how to use a shell
&#8216;shellxescape&#8217;    &#8216;sxe&#8217;     characters to escape when &#8216;shellxquote&#8217; is (
&#8216;shellxquote&#8217;     &#8216;sxq&#8217;     like &#8216;shellquote&#8217;, but include redirection
&#8216;shiftround&#8217;      &#8216;sr&#8217;      round indent to multiple of shiftwidth
&#8216;shiftwidth&#8217;      &#8216;sw&#8217;      number of spaces to use for (auto)indent step
&#8216;shortmess&#8217;   &#8216;shm&#8217;     list of flags, reduce length of messages
&#8216;shortname&#8217;   &#8216;sn&#8217;      non-MS-DOS: Filenames assumed to be 8.3 chars
&#8216;showbreak&#8217;   &#8216;sbr&#8217;     string to use at the start of wrapped lines
&#8216;showcmd&#8217;     &#8216;sc&#8217;      show (partial) command in status line
&#8216;showfulltag&#8217;     &#8216;sft&#8217;     show full tag pattern when completing tag
&#8216;showmatch&#8217;   &#8216;sm&#8217;      briefly jump to matching bracket if insert one
&#8216;showmode&#8217;    &#8216;smd&#8217;     message on status line to show current mode
&#8216;showtabline&#8217;     &#8216;stal&#8217;    tells when the tab pages line is displayed
&#8216;sidescroll&#8217;      &#8216;ss&#8217;      minimum number of columns to scroll horizontal
&#8216;sidescrolloff&#8217;   &#8216;siso&#8217;    min. nr. of columns to left and right of cursor
&#8216;smartcase&#8217;   &#8216;scs&#8217;     no ignore case when pattern has uppercase
&#8216;smartindent&#8217;     &#8216;si&#8217;      smart autoindenting for C programs
&#8216;smarttab&#8217;    &#8216;sta&#8217;     use &#8216;shiftwidth&#8217; when inserting <Tab>
&#8216;softtabstop&#8217;     &#8216;sts&#8217;     number of spaces that <Tab> uses while editing
&#8216;spell&#8217;             enable spell checking
&#8216;spellcapcheck&#8217;   &#8216;spc&#8217;     pattern to locate end of a sentence
&#8216;spellfile&#8217;   &#8216;spf&#8217;     files where zg and zw store words
&#8216;spelllang&#8217;   &#8216;spl&#8217;     language(s) to do spell checking for
&#8216;spellsuggest&#8217;    &#8216;sps&#8217;     method(s) used to suggest spelling corrections
&#8216;splitbelow&#8217;      &#8216;sb&#8217;      new window from split is below the current one
&#8216;splitright&#8217;      &#8216;spr&#8217;     new window is put right of the current one
&#8216;startofline&#8217;     &#8216;sol&#8217;     commands move cursor to first non-blank in line
&#8216;statusline&#8217;      &#8216;stl&#8217;     custom format for the status line
&#8216;suffixes&#8217;    &#8216;su&#8217;      suffixes that are ignored with multiple match
&#8216;suffixesadd&#8217;     &#8216;sua&#8217;     suffixes added when searching for a file
&#8216;swapfile&#8217;    &#8216;swf&#8217;     whether to use a swapfile for a buffer
&#8216;swapsync&#8217;    &#8216;sws&#8217;     how to sync the swap file
&#8216;switchbuf&#8217;   &#8216;swb&#8217;     sets behavior when switching to another buffer
&#8216;synmaxcol&#8217;   &#8216;smc&#8217;     maximum column to find syntax items
&#8216;syntax&#8217;      &#8216;syn&#8217;     syntax to be loaded for current buffer
&#8216;tabstop&#8217;     &#8216;ts&#8217;      number of spaces that <Tab> in file uses
&#8216;tabline&#8217;     &#8216;tal&#8217;     custom format for the console tab pages line
&#8216;tabpagemax&#8217;      &#8216;tpm&#8217;     maximum number of tab pages for -p and &#8220;tab all&#8221;
&#8216;tagbsearch&#8217;      &#8216;tbs&#8217;     use binary searching in tags files
&#8216;taglength&#8217;   &#8216;tl&#8217;      number of significant characters for a tag
&#8216;tagrelative&#8217;     &#8216;tr&#8217;      file names in tag file are relative
&#8216;tags&#8217;        &#8216;tag&#8217;     list of file names used by the tag command
&#8216;tagstack&#8217;    &#8216;tgst&#8217;    push tags onto the tag stack
&#8216;term&#8217;              name of the terminal
&#8216;termbidi&#8217;    &#8216;tbidi&#8217;   terminal takes care of bi-directionality
&#8216;termencoding&#8217;    &#8216;tenc&#8217;    character encoding used by the terminal
&#8216;terse&#8217;             shorten some messages
&#8216;textauto&#8217;    &#8216;ta&#8217;      obsolete, use &#8216;fileformats&#8217;
&#8216;textmode&#8217;    &#8216;tx&#8217;      obsolete, use &#8216;fileformat&#8217;
&#8216;textwidth&#8217;   &#8216;tw&#8217;      maximum width of text that is being inserted
&#8216;thesaurus&#8217;   &#8216;tsr&#8217;     list of thesaurus files for keyword completion
&#8216;tildeop&#8217;     &#8216;top&#8217;     tilde command &#8220;~&#8221; behaves like an operator
&#8216;timeout&#8217;     &#8216;to&#8217;      time out on mappings and key codes
&#8216;timeoutlen&#8217;      &#8216;tm&#8217;      time out time in milliseconds
&#8216;title&#8217;             let Vim set the title of the window
&#8216;titlelen&#8217;          percentage of &#8216;columns&#8217; used for window title
&#8216;titleold&#8217;          old title, restored when exiting
&#8216;titlestring&#8217;           string to use for the Vim window title
&#8216;toolbar&#8217;     &#8216;tb&#8217;      GUI: which items to show in the toolbar
&#8216;toolbariconsize&#8217; &#8216;tbis&#8217;    size of the toolbar icons (for GTK 2 only)
&#8216;ttimeout&#8217;          time out on mappings
&#8216;ttimeoutlen&#8217;     &#8216;ttm&#8217;     time out time for key codes in milliseconds
&#8216;ttybuiltin&#8217;      &#8216;tbi&#8217;     use built-in termcap before external termcap
&#8216;ttyfast&#8217;     &#8216;tf&#8217;      indicates a fast terminal connection
&#8216;ttymouse&#8217;    &#8216;ttym&#8217;    type of mouse codes generated
&#8216;ttyscroll&#8217;   &#8216;tsl&#8217;     maximum number of lines for a scroll
&#8216;ttytype&#8217;     &#8216;tty&#8217;     alias for &#8216;term&#8217;
&#8216;undodir&#8217;     &#8216;udir&#8217;    where to store undo files
&#8216;undofile&#8217;    &#8216;udf&#8217;     save undo information in a file
&#8216;undolevels&#8217;      &#8216;ul&#8217;      maximum number of changes that can be undone
&#8216;undoreload&#8217;      &#8216;ur&#8217;      max nr of lines to save for undo on a buffer reload
&#8216;updatecount&#8217;     &#8216;uc&#8217;      after this many characters flush swap file
&#8216;updatetime&#8217;      &#8216;ut&#8217;      after this many milliseconds flush swap file
&#8216;verbose&#8217;     &#8216;vbs&#8217;     give informative messages
&#8216;verbosefile&#8217;     &#8216;vfile&#8217;   file to write messages in
&#8216;viewdir&#8217;     &#8216;vdir&#8217;    directory where to store files with :mkview
&#8216;viewoptions&#8217;     &#8216;vop&#8217;     specifies what to save for :mkview
&#8216;viminfo&#8217;     &#8216;vi&#8217;      use .viminfo file upon startup and exiting
&#8216;virtualedit&#8217;     &#8216;ve&#8217;      when to use virtual editing
&#8216;visualbell&#8217;      &#8216;vb&#8217;      use visual bell instead of beeping
&#8216;warn&#8217;              warn for shell command when buffer was changed
&#8216;weirdinvert&#8217;     &#8216;wiv&#8217;     for terminals that have weird inversion method
&#8216;whichwrap&#8217;   &#8216;ww&#8217;      allow specified keys to cross line boundaries
&#8216;wildchar&#8217;    &#8216;wc&#8217;      command-line character for wildcard expansion
&#8216;wildcharm&#8217;   &#8216;wcm&#8217;     like &#8216;wildchar&#8217; but also works when mapped
&#8216;wildignore&#8217;      &#8216;wig&#8217;     files matching these patterns are not completed
&#8216;wildignorecase&#8217;  &#8216;wic&#8217;     ignore case when completing file names
&#8216;wildmenu&#8217;    &#8216;wmnu&#8217;    use menu for command line completion
&#8216;wildmode&#8217;    &#8216;wim&#8217;     mode for &#8216;wildchar&#8217; command-line expansion
&#8216;wildoptions&#8217;     &#8216;wop&#8217;     specifies how command line completion is done
&#8216;winaltkeys&#8217;      &#8216;wak&#8217;     when the windows system handles ALT keys
&#8216;window&#8217;      &#8216;wi&#8217;      nr of lines to scroll for CTRL-F and CTRL-B
&#8216;winheight&#8217;   &#8216;wh&#8217;      minimum number of lines for the current window
&#8216;winfixheight&#8217;    &#8216;wfh&#8217;     keep window height when opening/closing windows
&#8216;winfixwidth&#8217;     &#8216;wfw&#8217;     keep window width when opening/closing windows
&#8216;winminheight&#8217;    &#8216;wmh&#8217;     minimum number of lines for any window
&#8216;winminwidth&#8217;     &#8216;wmw&#8217;     minimal number of columns for any window
&#8216;winwidth&#8217;    &#8216;wiw&#8217;     minimal number of columns for current window
&#8216;wrap&#8217;              long lines wrap and continue on the next line
&#8216;wrapmargin&#8217;      &#8216;wm&#8217;      chars from the right where wrapping starts
&#8216;wrapscan&#8217;    &#8216;ws&#8217;      searches wrap around the end of the file
&#8216;write&#8217;             writing to a file is allowed
&#8216;writeany&#8217;    &#8216;wa&#8217;      write to file with no need for &#8220;!&#8221; override
&#8216;writebackup&#8217;     &#8216;wb&#8217;      make a backup before overwriting a file
&#8216;writedelay&#8217;      &#8216;wd&#8217;      delay this many msec for each char (for debug)
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;
*Q_ur*      Undo/Redo commands

u       N  u        undo last N changes
CTRL-R  N  CTRL-R   redo last N undone changes
U          U        restore last changed line
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;
*Q_et*      External commands

:shell  :sh[ell]    start a shell
:!      :!{command} execute {command} with a shell
K          K        lookup keyword under the cursor with
                   &#8216;keywordprg&#8217; program (default: &#8220;man&#8221;)
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;
*Q_qf*      Quickfix commands

:cc     :cc [nr]    display error [nr] (default is the same again)
:cnext  :cn     display the next error
:cprevious  :cp     display the previous error
:clist  :cl     list all errors
:cfile  :cf     read errors from the file &#8216;errorfile&#8217;
:cgetbuffer :cgetb      like :cbuffer but don&#8217;t jump to the first error
:cgetfile   :cg     like :cfile but don&#8217;t jump to the first error
:cgetexpr   :cgete      like :cexpr but don&#8217;t jump to the first error
:caddfile   :caddf      add errors from the error file to the current
                   quickfix list
:caddexpr   :cad        add errors from an expression to the current
                   quickfix list
:cbuffer    :cb     read errors from text in a buffer
:cexpr  :cex        read errors from an expression
:cquit  :cq     quit without writing and return error code (to
                   the compiler)
:make       :make [args]    start make, read errors, and jump to first
                   error
:grep       :gr[ep] [args]  execute &#8216;grepprg&#8217; to find matches and jump to
                   the first one
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;
*Q_vc*      Various commands

CTRL-L     CTRL-L   clear and redraw the screen
CTRL-G     CTRL-G   show current file name (with path) and cursor
                   position
ga         ga       show ascii value of character under cursor in
                   decimal, hex, and octal
g8         g8       for utf-8 encoding: show byte sequence for
                   character under cursor in hex
g_CTRL-G       g CTRL-G show cursor column, line, and character
                   position
CTRL-C     CTRL-C   during searches: Interrupt the search
dos-CTRL-Break   CTRL-Break MS-DOS: during searches: Interrupt the search
<Del>          <Del>    while entering a count: delete last character
:version    :ve[rsion]  show version information
:mode       :mode N     MS-DOS: set screen mode to N (number, C80,
                   C4350, etc.)
:normal :norm[al][!] {commands}
                execute Normal mode commands
Q          Q        switch to &#8220;Ex&#8221; mode

:redir  :redir >{file}      redirect messages to {file}
:silent :silent[!] {command}    execute {command} silently
:confirm    :confirm {command}  quit, write, etc., asking about
                    unsaved changes or read-only files
:browse :browse {command}   open/read/write file, using a
                    file selection dialog
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;
*Q_ce*      Command-line editing

c_<Esc> <Esc>          abandon command-line (if &#8216;wildchar&#8217; is
                      <Esc>, type it twice)

c_CTRL-V    CTRL-V {char}      insert {char} literally
c_CTRL-V    CTRL-V {number}    enter decimal value of character (up to
                      three digits)
c_CTRL-K    CTRL-K {char1} {char2}
                   enter digraph (See Q_di)
c_CTRL-R    CTRL-R {0-9a-z&#8221;%#:-=}
                   insert the contents of a register

c_<Left>    <Left>/<Right>     cursor left/right
c_<S-Left>  <S-Left>/<S-Right> cursor one word left/right
c_CTRL-B    CTRL-B/CTRL-E      cursor to beginning/end of command-line

c_<BS>  <BS>           delete the character in front of the cursor
c_<Del> <Del>          delete the character under the cursor
c_CTRL-W    CTRL-W         delete the word in front of the cursor
c_CTRL-U    CTRL-U         remove all characters

c_<Up>  <Up>/<Down>    recall older/newer command-line that starts
                      with current command
c_<S-Up>    <S-Up>/<S-Down>    recall older/newer command-line from history
:history    :his[tory]     show older command-lines

Context-sensitive completion on the command-line:

c_wildchar  &#8216;wildchar&#8217;  (default: <Tab>)
                do completion on the pattern in front of the
                   cursor; if there are multiple matches,
                   beep and show the first one; further
                   &#8216;wildchar&#8217; will show the next ones
c_CTRL-D    CTRL-D      list all names that match the pattern in
                   front of the cursor
c_CTRL-A    CTRL-A      insert all names that match pattern in front
                   of cursor
c_CTRL-L    CTRL-L      insert longest common part of names that
                   match pattern
c_CTRL-N    CTRL-N      after &#8216;wildchar&#8217; with multiple matches: go
                   to next match
c_CTRL-P    CTRL-P      after &#8216;wildchar&#8217; with multiple matches: go
                   to previous match
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;
*Q_ra*      Ex ranges

:range  ,       separates two line numbers
:range  ;       idem, set cursor to the first line number
                before interpreting the second one

:range  {number}    an absolute line number
:range  .       the current line
:range  $       the last line in the file
:range  %       equal to 1,$ (the entire file)
:range  *       equal to &#8217;<,'> (visual area)
:range  &#8216;t      position of mark t
:range  /{pattern}[/]   the next line where {pattern} matches
:range  ?{pattern}[?]   the previous line where {pattern} matches

:range  +[num]      add [num] to the preceding line number
                   (default: 1)
:range  -[num]      subtract [num] from the preceding line
                   number (default: 1)
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;
*Q_ex*      Special Ex characters

:bar            separates two commands (not for &#8220;:global&#8221; and &#8220;:!&#8221;)
:quote    &#8221;     begins comment

:_%       %     current file name (only where a file name is expected)
:_#       #[num]    alternate file name [num] (only where a file name is
               expected)
    Note: The next seven are typed literally; these are not special keys!
:<abuf>   <abuf>    buffer number, for use in an autocommand (only where a
               file name is expected)
:<afile>  <afile>   file name, for use in an autocommand (only where a
               file name is expected)
:<amatch> <amatch>  what matched with the pattern, for use in an
               autocommand (only where a file name is expected)
:<cword>  <cword>   word under the cursor (only where a file name is
               expected)
:<cWORD>  <cWORD>   WORD under the cursor (only where a file name is
               expected) (see WORD)
:<cfile>  <cfile>   file name under the cursor (only where a file name is
               expected)
:<sfile>  <sfile>   file name of a &#8220;:source&#8221;d file, within that file (only
               where a file name is expected)

        After &#8220;%&#8221;, &#8220;#&#8221;, &#8221;<cfile>&#8221;, &#8221;<sfile>&#8221; or &#8221;<afile>&#8221;
        ::p     :p      full path
        ::h     :h      head (file name removed)
        ::t     :t      tail (file name only)
        ::r     :r      root (extension removed)
        ::e     :e      extension
        ::s     :s/{pat}/{repl}/    substitute {pat} with {repl}
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;
*Q_st*      Starting Vim

-vim       vim [options]        start editing with an empty buffer
-file      vim [options] {file} ..  start editing one or more files
&#8211;     vim [options] -      read file from stdin
-tag       vim [options] -t {tag}   edit the file associated with {tag}
-qf    vim [options] -q [fname] start editing in QuickFix mode,
                       display the first error

    Most useful Vim arguments (for full list see startup-options)

-gui    -g          start GUI (also allows other options)

-+  +[num]          put the cursor at line [num] (default: last line)
-+c +{command}      execute {command} after loading the file
-+/ +/{pat} {file} ..   put the cursor at the first occurrence of {pat}
-v  -v          Vi mode, start ex in Normal mode
-e  -e          Ex mode, start vim in Ex mode
-R  -R          Read-only mode, implies -n
-m  -m          modifications not allowed (resets &#8216;write&#8217; option)
-d  -d          diff mode diff
-b  -b          binary mode
-l  -l          lisp mode
-A  -A          Arabic mode (&#8216;arabic&#8217; is set)
-F  -F          Farsi mode (&#8216;fkmap&#8217; and &#8216;rightleft&#8217; are set)
-H  -H          Hebrew mode (&#8216;hkmap&#8217; and &#8216;rightleft&#8217; are set)
-V  -V          Verbose, give informative messages
-C  -C          Compatible, set the &#8216;compatible&#8217; option
-N  -N          Nocompatible, reset the &#8216;compatible&#8217; option
-r  -r          give list of swap files
-r  -r {file} ..        recover aborted edit session
-n  -n          do not create a swap file
-o  -o [num]        open [num] windows (default: one for each file)
-f  -f          GUI: foreground process, don&#8217;t fork
                Amiga: do not restart Vim to open a window (for
                e.g., mail)
-s  -s {scriptin}       first read commands from the file {scriptin}
-w  -w {scriptout}      write typed chars to file {scriptout} (append)
-W  -W {scriptout}      write typed chars to file {scriptout} (overwrite)
-T  -T {terminal}       set terminal name
-d  -d {device}     Amiga: open {device} to be used as a console
-u  -u {vimrc}      read inits from {vimrc} instead of other inits
-U  -U {gvimrc}     idem, for when starting the GUI
-i  -i {viminfo}        read info from {viminfo} instead of other files
&#8212; &#8211;          end of options, other arguments are file names
&#8211;help    &#8211;help        show list of arguments and exit
&#8211;version &#8211;version     show version info and exit
&#8211;  -           read file from stdin
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;
*Q_ed*      Editing a file

       Without !: Fail if changes have been made to the current buffer.
          With !: Discard any changes to the current buffer.
:edit_f  :e[dit][!] {file}  edit {file}
:edit    :e[dit][!]     reload the current file
:enew    :ene[w][!]     edit a new, unnamed buffer
:find    :fin[d][!] {file}  find {file} in &#8216;path&#8217; and edit it

CTRL-^   N  CTRL-^      edit alternate file N (equivalent to &#8220;:e #N&#8221;)
gf          gf  or ]f       edit the file whose name is under the cursor
:pwd     :pwd           print the current directory name
:cd      :cd [path]     change the current directory to [path]
:cd-     :cd -      back to previous current directory
:file    :f[ile]        print the current file name and the cursor
                   position
:file    :f[ile] {name} set the current file name to {name}
:files   :files     show alternate file names
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;
*Q_fl*      Using the argument list         argument-list

:args      :ar[gs]      print the argument list, with the current file
                   in &#8220;[]&#8221;
:all       :all  or :sall   open a window for every file in the arg list
:wn    :wn[ext][!]      write file and edit next file
:wn    :wn[ext][!] {file}   write to {file} and edit next file, unless
                   {file} exists; With !, overwrite existing
                   file
:wN    :wN[ext][!] [file]   write file and edit previous file

         in current window    in new window ~
:argument  :argu[ment] N      :sar[gument] N    edit file N
:next      :n[ext]        :sn[ext]      edit next file
:next_f    :n[ext] {arglist}      :sn[ext] {arglist}    define new arg list
                               and edit first file
:Next      :N[ext]        :sN[ext]      edit previous file
:first     :fir[st]       :sfir[st]     edit first file
:last      :la[st]        :sla[st]      edit last file
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;
*Q_wq*      Writing and quitting

:w    :[range]w[rite][!]        write to the current file
:w_f      :[range]w[rite] {file}    write to {file}, unless it already
                       exists
:w_f      :[range]w[rite]! {file}   write to {file}.  Overwrite an existing
                       file
:w_a      :[range]w[rite][!] >>     append to the current file
:w_a      :[range]w[rite][!] >> {file}  append to {file}
:w_c      :[range]w[rite] !{cmd}    execute {cmd} with [range] lines as
                       standard input
:up   :[range]up[date][!]       write to current file if modified
:wall     :wa[ll][!]            write all changed buffers

:q    :q[uit]       quit current buffer, unless changes have been
                   made; Exit Vim when there are no other
                   non-help buffers
:q    :q[uit]!      quit current buffer always, discard any
                   changes.  Exit Vim when there are no other
                   non-help buffers
:qa   :qa[ll]       exit Vim, unless changes have been made
:qa   :qa[ll]!      exit Vim always, discard any changes
:cq   :cq           quit without writing and return error code

:wq   :wq[!]        write the current file and exit
:wq   :wq[!] {file}     write to {file} and exit
:xit      :x[it][!] [file]  like &#8220;:wq&#8221; but write only when changes have
                   been made
ZZ       ZZ         same as &#8220;:x&#8221;
ZQ       ZQ         same as &#8220;:q!&#8221;
:xall     :xa[ll][!]  or :wqall[!]
                write all changed buffers and exit

:stop     :st[op][!]        suspend Vim or start new shell; if &#8216;aw&#8217; option
                   is set and [!] not given write the buffer
CTRL-Z     CTRL-Z       same as &#8220;:stop&#8221;
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;
*Q_ac*      Automatic Commands

viminfo-file    read registers, marks, history at startup, save when exiting.

:rviminfo   :rv[iminfo] [file]  read info from viminfo file [file]
:rviminfo   :rv[iminfo]! [file] idem, overwrite existing info
:wviminfo   :wv[iminfo] [file]  add info to viminfo file [file]
:wviminfo   :wv[iminfo]! [file] write info to viminfo file [file]

modeline    Automatic option setting when editing a file

modeline    vim:{set-arg}: ..   In the first and last lines of the
                    file (see &#8216;ml&#8217; option), {set-arg} is
                    given as an argument to &#8220;:set&#8221;

autocommand Automatic execution of commands on certain events.

:autocmd    :au           list all autocommands
:autocmd    :au {event}       list all autocommands for {event}
:autocmd    :au {event} {pat}     list all autocommands for {event}
                      with {pat}
:autocmd    :au {event} {pat} {cmd}   enter new autocommands for {event}
                      with {pat}
:autocmd    :au!              remove all autocommands
:autocmd    :au! {event}          remove all autocommands for {event}
:autocmd    :au! * {pat}          remove all autocommands for {pat}
:autocmd    :au! {event} {pat}    remove all autocommands for {event}
                      with {pat}
:autocmd    :au! {event} {pat} {cmd}  remove all autocommands for {event}
                      with {pat} and enter new one
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;
*Q_wi*      Multi-window commands

CTRL-W_s    CTRL-W s  or  :split    split window into two parts
:split_f    :split {file}       split window and edit {file} in one of
                       them
:vsplit :vsplit {file}      same, but split vertically
:vertical   :vertical {cmd}     make {cmd} split vertically

:sfind  :sf[ind] {file}     split window, find {file} in &#8216;path&#8217;
                       and edit it
CTRL-W_]    CTRL-W ]        split window and jump to tag under
                       cursor
CTRL-W_f    CTRL-W f        split window and edit file name under
                       the cursor
CTRL-W_^    CTRL-W ^        split window and edit alternate file
CTRL-W_n    CTRL-W n  or  :new  create new empty window
CTRL-W_q    CTRL-W q  or  :q[uit]   quit editing and close window
CTRL-W_c    CTRL-W c  or  :cl[ose]  make buffer hidden and close window
CTRL-W_o    CTRL-W o  or  :on[ly]   make current window only one on the
                       screen

CTRL-W_j    CTRL-W j        move cursor to window below
CTRL-W_k    CTRL-W k        move cursor to window above
CTRL-W_CTRL-W   CTRL-W CTRL-W       move cursor to window below (wrap)
CTRL-W_W    CTRL-W W        move cursor to window above (wrap)
CTRL-W_t    CTRL-W t        move cursor to top window
CTRL-W_b    CTRL-W b        move cursor to bottom window
CTRL-W_p    CTRL-W p        move cursor to previous active window

CTRL-W_r    CTRL-W r        rotate windows downwards
CTRL-W_R    CTRL-W R        rotate windows upwards
CTRL-W_x    CTRL-W x        exchange current window with next one

CTRL-W_=    CTRL-W =        make all windows equal height
CTRL-W_-    CTRL-W -        decrease current window height
CTRL-W_+    CTRL-W +        increase current window height
CTRL-W__    CTRL-W _        set current window height (default:
                       very high)
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;
*Q_bu*      Buffer list commands

:buffers    :buffers  or  :files    list all known buffer and file names

:ball       :ball     or  :sball    edit all args/buffers
:unhide :unhide   or  :sunhide  edit all loaded buffers

:badd       :badd {fname}       add file name {fname} to the list
:bunload    :bunload[!] [N]     unload buffer [N] from memory
:bdelete    :bdelete[!] [N]     unload buffer [N] and delete it from
                       the buffer list

        in current window  in new window       ~
:buffer :[N]buffer [N]     :[N]sbuffer [N]     to arg/buf N
:bnext  :[N]bnext [N]      :[N]sbnext [N]      to Nth next arg/buf
:bNext  :[N]bNext [N]      :[N]sbNext [N]      to Nth previous arg/buf
:bprevious  :[N]bprevious [N]  :[N]sbprevious [N]  to Nth previous arg/buf
:bfirst :bfirst            :sbfirst            to first arg/buf
:blast  :blast             :sblast             to last arg/buf
:bmodified  :[N]bmod [N]       :[N]sbmod [N]       to Nth modified buf
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;
*Q_sy*      Syntax Highlighting

:syn-on :syntax on      start using syntax highlighting
:syn-off    :syntax off     stop using syntax highlighting

:syn-keyword    :syntax keyword {group-name} {keyword} ..
                    add a syntax keyword item
:syn-match  :syntax match {group-name} {pattern} &#8230;
                    add syntax match item
:syn-region :syntax region {group-name} {pattern} &#8230;
                    add syntax region item
:syn-sync   :syntax sync [ccomment  lines {N}  &#8230;]
                    tell syntax how to sync
:syntax :syntax [list]      list current syntax items
:syn-clear  :syntax clear       clear all syntax info

:highlight  :highlight clear    clear all highlight info
:highlight  :highlight {group-name} {key}={arg} ..
                    set highlighting for {group-name}

:filetype   :filetype on        switch on file type detection, without
                    syntax highlighting
:filetype   :filetype plugin indent on
                    switch on file type detection, with
                    automatic indenting and settings
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;
*Q_gu*      GUI commands

:gui        :gui            UNIX: start the GUI
:gui        :gui {fname} ..     idem, and edit {fname} ..

:menu       :menu           list all menus
:menu       :menu {mpath}       list menus starting with {mpath}
:menu       :menu {mpath} {rhs} add menu {mpath}, giving {rhs}
:menu       :menu {pri} {mpath} {rhs}
                    idem, with priorities {pri}
:menu       :menu ToolBar.{name} {rhs}
                    add toolbar item, giving {rhs}
:tmenu  :tmenu {mpath} {text}   add tooltip to menu {mpath}
:unmenu :unmenu {mpath}     remove menu {mpath}
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;
*Q_fo*      Folding

&#8216;foldmethod&#8217;    set foldmethod=manual   manual folding
        set foldmethod=indent   folding by indent
        set foldmethod=expr folding by &#8216;foldexpr&#8217;
        set foldmethod=syntax   folding by syntax regions
        set foldmethod=marker   folding by &#8216;foldmarker&#8217;

zf      zf{motion}      operator: Define a fold manually
:fold       :{range}fold        define a fold for {range} lines
zd      zd          delete one fold under the cursor
zD      zD          delete all folds under the cursor

zo      zo          open one fold under the cursor
zO      zO          open all folds under the cursor
zc      zc          close one fold under the cursor
zC      zC          close all folds under the cursor

zm      zm          fold more: decrease &#8216;foldlevel&#8217;
zM      zM          close all folds: make &#8216;foldlevel&#8217; zero
zr      zr          reduce folding: increase &#8216;foldlevel&#8217;
zR      zR          open all folds: make &#8216;foldlevel&#8217; max.

zn      zn          fold none: reset &#8216;foldenable&#8217;
zN      zN          fold normal set &#8216;foldenable&#8217;
zi      zi          invert &#8216;foldenable&#8217;

 vim:tw=78:ts=8:ft=help:norl:
&#8220;`
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vim插件全攻略]]></title>
    <link href="http://LanderlYoung.github.io/blog/2014/05/07/vimcha-jian-quan-gong-lue/"/>
    <updated>2014-05-07T11:42:23+08:00</updated>
    <id>http://LanderlYoung.github.io/blog/2014/05/07/vimcha-jian-quan-gong-lue</id>
    <content type="html"><![CDATA[<p>原来配置vim插件的时候因为总是要下载解压，试用然后把.vim目录弄得乱七八糟。所以也就用了那几个插件，本着够用就好的原则。今天才发现Vim也有自己的插件管理工具<a href="https://github.com/gmarik/Vundle.vim">Vundle</a>真的是太开心了。然后又发现了有大神共享的<a href="https://github.com/humiaozuzu/dot-vimrc">插件列表</a>，于是我就开始了开开心心的Vim插件攻略。</p>

<!--more-->


<p>除了上面共享的插件列表我还装了另外几个插件：
* TagList
* A.vim</p>

<p><em>hell0</em></p>
]]></content>
  </entry>
  
</feed>
