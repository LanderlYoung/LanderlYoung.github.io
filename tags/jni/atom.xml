<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: JNI | Young_Blog]]></title>
  <link href="http://LanderlYoung.github.io/tags/jni/atom.xml" rel="self"/>
  <link href="http://LanderlYoung.github.io/"/>
  <updated>2014-10-16T21:30:16+08:00</updated>
  <id>http://LanderlYoung.github.io/</id>
  <author>
    <name><![CDATA[LanderlYoung]]></name>
    <email><![CDATA[landerlyoung@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Java 中JNI的使用]]></title>
    <link href="http://LanderlYoung.github.io/blog/2014/10/16/java-zhong-jnide-shi-yong/"/>
    <updated>2014-10-16T21:10:55+08:00</updated>
    <id>http://LanderlYoung.github.io/blog/2014/10/16/java-zhong-jnide-shi-yong</id>
    <content type="html"><![CDATA[<p>最近来电项目打算加入变声的功能，所以决定实用SoundTouch（这个库是LGPL协议的，所以对SoundTouch的代码没有修改的话是不需要开源代码的！LOL~~）。SoundTouch是用C++写的，因此需要一个Java的JNI封装，以便JAVA层比较方便的调用。这次用JNI封装SoundTouch的经历，还是颇有收获的。记录一下，方便以后查看。</p>

<p>JNI全称是<code>Java Native Interface</code>是在JAVA和Native层（包括但不限于C/C++）相互调用的接口规范。</p>

<!--more-->


<p>JNI在JAVA1.1中正式推出，在JAVA1.2版本中加入了<code>JNI_OnLoad</code>，<code>JNI_OnUnload</code>方法，这两个方法还是很有用的，后面再说。</p>

<h3>JNI基础篇</h3>

<p>Java通过JNI调用本地方法的过程大致是</p>

<ol>
<li>写一个Java类，在其中声明对应要调用的native方法，用<code>native</code>关键字修饰。 比如<code>private static native int native_newInstance();</code></li>
<li>通过<code>javah</code>命令生成java类对应的C/C++头文件。<code>javah -encoding utf-8 -cp src com.tencent.soundtouch.SoundTouch</code></li>
<li>在C/C++中实现头文件中声明的函数</li>
<li>编译C/C++代码为动态库（Windows中的dll，linux(Android)中的so，MAC OSX中的dylib）。</li>
<li>在java代码中加载动态库，即可像调用Java方法一样，调用到native函数。</li>
</ol>


<p>其中第三步在Java1.2中增加了<code>JNI_OnLoad</code>方法之后有另一种实现方式（<a href="#jni_onload">后面</a>说）。</p>

<p>javah生成的头文件大致是这样的：
```java
/<em> DO NOT EDIT THIS FILE &ndash; it is machine generated </em>/</p>

<h1>include &lt;jni.h></h1>

<p>/<em> Header for class com_tencent_soundtouch_SoundTouch </em>/</p>

<h1>ifndef _Included_com_tencent_soundtouch_SoundTouch</h1>

<h1>define _Included_com_tencent_soundtouch_SoundTouch</h1>

<h1>ifdef __cplusplus</h1>

<p>extern &ldquo;C&rdquo; {</p>

<h1>endif</h1>

<h1>undef com_tencent_soundtouch_SoundTouch_SETTING_USE_AA_FILTER</h1>

<h1>define com_tencent_soundtouch_SoundTouch_SETTING_USE_AA_FILTER 0L</h1>

<pre><code>/*
* Class:     com_tencent_soundtouch_SoundTouch
* Method:    native_getDefaultSampleElementSize
* Signature: ()I
*/
JNIEXPORT jint JNICALL Java_com_tencent_soundtouch_SoundTouch_native_1getDefaultSampleElementSize
    (JNIEnv *, jclass);
</code></pre>

<h1>ifdef __cplusplus</h1>

<p>}</p>

<h1>endif</h1>

<h1>endif</h1>

<p>```</p>

<p>文件开头就是普通的头文件，但是可以发现：</p>

<ol>
<li><p>包含了jni.h头文件（一般位于<code>$JAVA_HOME/jd{jdk-version}/include</code>文目录内）。这是JNI中所有的<a href="#jni_type">类型</a>、函数、宏等定义的地方。所以C/C++世界的JNI是由他制定的游戏规则。</p></li>
<li><p>在类中生命的常量（<code>static final</code>）类型会在头文件中以宏的形式出现，这一点还是很方便的。</p></li>
<li><p>函数的注释还是比较全的，包括了：</p>

<ol>
<li>对应的class</li>
<li>对应的java方法名</li>
<li>对应java方法的<a href="#signature">签名</a></li>
</ol>
</li>
<li>方法的声明显得有点奇怪，由以下及部分组成：

<ol>
<li><code>JNIEXPORT</code>这是函数的导出方式</li>
<li>jint 返回值类型（jint由jni.h定义，对应int，<a href="#jni_type">下面</a>具体再说吧</li>
<li>JNICALL 函数的调用方式也就是汇编级别参数的传入方式</li>
<li> Java_com_tencent_soundtouch_SoundTouch_native_1getDefaultSampleElementSize —— 超级长的函数名！！！格式是<code>Java_</code> + <code>类全名</code> + <code>_</code> + JAVA中声明的native方法名。其中会把包名中的点（<code>.</code>）替换成下划线（<code>_</code>），同时为了避免冲突把下划线替换成<code>_1</code>。</li>
<li>方法的参数，上面的这个方法在JAVA的声明中实际上是没有参数的，其中的<code>JNIENV</code>顾名思义是JNI环境，和具体的线程绑定。而第二个参数<code>jclass</code>其实是java中的<code>Class</code>因为上面是一个<code>static</code>方法，因此第二个参数是<code>jclass</code>。如果是一个实例方法则对应第二个参数是<code>jobject</code>，相当于java中的<code>this</code>。</li>
</ol>
</li>
</ol>


<p>下面在C/C++中实现这个方法就行啦。但是在动手前现大致了解以下jni.h制定的游戏规则。</p>

<h4><a name="jni_type">类型转换</a>：</h4>

<p>javah生成的头文件里面使用的类型都是jni.h定义的，目的是做到<strong>平台无关</strong>，比如保证在所有平台上jint都是32位的有符号整型。</p>

<p><strong>基本对应关系如下：</strong></p>

<table>
<thead>
<tr>
<th> </th>
<th align="center">  jni 类型 </th>
<th align="center"> JAVA类型 </th>
<th align="center"> 对应本地类型  </th>
<th align="center">  类型<a href="#signature">签名</a> </th>
</tr>
</thead>
<tbody>
<tr>
<td>   jboolean </td>
<td align="center"> boolean </td>
<td align="center"> uint8_t </td>
<td align="center"> Z</td>
<td></td>
</tr>
<tr>
<td>   jbyte </td>
<td align="center"> byte </td>
<td align="center"> char </td>
<td align="center"> B </td>
<td></td>
</tr>
<tr>
<td>   jcahr </td>
<td align="center"> char </td>
<td align="center"> uint16_t </td>
<td align="center"> C </td>
<td></td>
</tr>
<tr>
<td>   jshort </td>
<td align="center"> short </td>
<td align="center"> int16_t </td>
<td align="center"> S </td>
<td></td>
</tr>
<tr>
<td>   jint </td>
<td align="center"> int </td>
<td align="center"> int32_t </td>
<td align="center"> I </td>
<td></td>
</tr>
<tr>
<td>   jlong </td>
<td align="center"> long </td>
<td align="center"> int64_t </td>
<td align="center"> J </td>
<td></td>
</tr>
<tr>
<td>   jfloat </td>
<td align="center"> float </td>
<td align="center"> float </td>
<td align="center"> F </td>
<td></td>
</tr>
<tr>
<td>   jdouble </td>
<td align="center"> double </td>
<td align="center"> double </td>
<td align="center"> D </td>
<td></td>
</tr>
<tr>
<td>   void </td>
<td align="center"> void </td>
<td align="center"> void </td>
<td align="center"> V </td>
<td></td>
</tr>
</tbody>
</table>


<p><strong>引用类型对应关系：</strong></p>

<table>
<thead>
<tr>
<th></th>
<th align="center"> java类型 </th>
<th align="center">  JNI 类型 </th>
<th align="center"> java类型 </th>
<th align="center">  JNI 类型 </th>
</tr>
</thead>
<tbody>
<tr>
<td>  所有的实例引用 </td>
<td align="center"> jobject </td>
<td align="center">java.lang.Class </td>
<td align="center">  jclass </td>
<td></td>
</tr>
<tr>
<td>  java.lang.String </td>
<td align="center"> jstring </td>
<td align="center"> Ocject[] </td>
<td align="center"> jobjectArray </td>
<td></td>
</tr>
<tr>
<td>  java.lang.Throwable </td>
<td align="center"> jthrowable </td>
<td align="center"> 基本类型[] </td>
<td align="center"> jxxxArray </td>
<td></td>
</tr>
</tbody>
</table>


<p>通过表格发现，除了上面定义的<code>String</code>，<code>Class</code>，<code>Throwable</code>，其他的类（除了数组）都是以<code>jobject</code>的形式出现的！事实上jstring， jclass也都是object的子类。所以这里还是和java层一样，一切皆jobject。（当然，如果jni在C语言中编译的话是没有继承的概念的，此时jstring，jclass等其实就是jobject！用了typedef转换而已！！）</p>

<p>接下来是<code>JNIEnv *</code>这个指针，他提供了JNI中的一系列操作的接口函数。</p>

<h4>JNI中操作jobject</h4>

<p>其实也就是在native层操作java层的实例。
要操作一个实例无疑是：
 1. 获取/设置 （即 get/set ）成员变量（field）的值
 2. 调用成员方法（method）</p>

<p>所以问题来了：（挖掘机技术哪家强？！ o(*≧▽≦)ツ┏━┓ ）</p>

<p><strong>怎么得到field 和 method？</strong></p>

<p>通过使用<strong>jfieldID和jmethodID</strong>：
在JNI中使用类似于放射的方式来进行field和method的操作。JNI中使用jfieldID和jmethodID来表示成员变量和成员方法，获取方式是：</p>

<p><code>java
jfieldID GetFieldID(jclass clazz, const char *name, const char *sig);
jfieldID GetStaticFieldID(jclass clazz, const char *name, const char *sig);
jmethodID GetMethodID(jclass clazz, const char *name, const char *sig);
jmethodID GetStaticMethodID(jclass clazz, const char *name, const char *sig) ;
</code></p>

<p>其中最后一个参数是<a href="#signature">签名</a>。
<strong>获取jclass的方法</strong>除了实用上面静态方法的第二个参数外，还可以手动获取。
<code>jclass FindClass(const char *name)</code>
需要注意的是<code>name</code>参数，他是一个类包括包名的全称，但是需要把包名中的点<code>.</code>替换成斜杠<code>/</code>。（好吧，事实上我不是太明白为啥要这么做。）</p>

<p>有了jfieldID和jmethodID就知道狗蛋住哪了，现在去狗蛋家找他玩 ♪(^∇^*)</p>

<p><strong>成员变量:</strong><br/>
 1. get :</p>

<pre><code> 1.  `&lt;type&gt; Get&lt;type&gt;Field(jobject , jfieldID);`即可获得对应的field，其中field的类型是type，可以是上面[类型][jni_type]所叙述的任何一种。  
 2.  `&lt;type&gt; GetStatic&lt;type&gt;Field(jobject , jfieldID);`同1，唯一的区别是用来获取静态成员。  
</code></pre>

<ol>
<li>set:

<ol>
<li><code>void Set&lt;type&gt;Field(jobject obj, jfieldID fieldID, &lt;type&gt; val)</code></li>
<li><code>void SetStatic&lt;type&gt;Field(jclass clazz, jfieldID fieldID, &lt;type&gt; value);</code></li>
</ol>
</li>
</ol>


<p><strong>成员方法：</strong><br/>
调用方法自然要把方法的参数传递进去，JNI中实现了三种参数的传递方式：<br/>
 1. <code>Call&lt;type&gt;Method(jobject obj, jmethod jmethodID, ...)</code>其中<code>...</code>是C中的可变长参数，类似于<code>printf</code>那样，可以传递不定长个参数。于是你可以把java方法需要的参数在这里面传递进去。<br/>
 2. <code>Call&lt;type&gt;MethodV(jobject obj, jmethodID methodID, va_list args)</code>其中的<code>va_list</code>也是C中可变长参数相关的内容（我不了解，不敢瞎说。。。偷懒粘一下Oracle的文档）Programmers place all arguments to the method in an args argument of type va_list that immediately follows the methodID argument. The Call<type>MethodV routine accepts the arguments, and, in turn, passes them to the Java method that the programmer wishes to invoke.<br/>
 3. <code>Call&lt;type&gt;MethodA(jobject obj, jmethodID methodID, const jvalue * args)</code>哎！这个我知道可以说两句LOL~~这里的<code>jvalue</code>通过查代码发现就是JNI中各个数据类型的union，所以可以使用任何类型复制！所以参数的传入方式是通过一个jvalue的数组，数组内的元素可以是任何jni类型。</p>

<p>然后问题又来了：（挖掘机技术到底哪家强？！o(*≧▽≦)ツ┏━┓）
如果传进来的参数和java声明的参数的不一致会怎么样！（即不符合<a href="#signature">方法签名</a>）这里文档中没用明确解释，但是说道:</p>

<blockquote><p>Exceptions raised during the execution of the Java method.</p></blockquote>

<p>```java
typedef union jvalue {</p>

<pre><code>jboolean z;
jbyte    b;
jchar    c;
jshort   s;
jint     i;
jlong    j;
jfloat   f;
jdouble  d;
jobject  l;
</code></pre>

<p>} jvalue;
```</p>

<ol>
<li>调用实例方法（instance method）：

<ol>
<li> <code>&lt;type&gt; Call&lt;type&gt;Method(jobject obj, jmethodID methodID, ...);</code>调用一个具有<code>&lt;type&gt;</code>类型返回值的方法。</li>
<li><code>&lt;type&gt; Call&lt;type&gt;MethodV(jobject obj, jmethodID methodID, va_list args);</code></li>
<li><code>Call&lt;type&gt;MethodA(jobject obj, jmethodID methodID, const jvalue * args)</code></li>
</ol>
</li>
<li>调用静态方法（static method）：

<ol>
<li><code>&lt;type&gt; CallStatic&lt;type&gt;Method(jobject obj, jmethodID methodID, ...);</code></li>
<li><code>&lt;type&gt; CallStatic&lt;type&gt;MethodV(jobject obj, jmethodID methodID, va_list args);</code></li>
<li><code>CallStatic&lt;type&gt;MethodA(jobject obj, jmethodID methodID, const jvalue * args)</code></li>
</ol>
</li>
<li>调用父类方法（super.method)，这个就有点不一样了。多了一个jclass参数，jclass可以使obj的父类，也可以是obj自己的class，但是methodID必须是从jclass获取到的，这样就可以调用到父类的方法。

<ol>
<li><code>&lt;type&gt; CallNonvirtual&lt;type&gt;Method(jobject obj, jclass clazz, jmethodID methodID, ...)</code></li>
<li><code>&lt;type&gt; CallNonvirtual&lt;type&gt;MethodV(JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, va_list args);</code></li>
<li> <code>&lt;type&gt; CallNonvirtual&lt;type&gt;MethodA(JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, const jvalue *args);</code></li>
</ol>
</li>
</ol>


<h4>数组的操作</h4>

<p>数组是一个很常用的数据类型，在但是在JNI中并不能直接操作jni数组（比如jshortArray，jfloatArray）。使用方法是：</p>

<ol>
<li>获取数组长度：<code>jsize GetArrayLength(jarray array)</code></li>
<li>创建新数组： <code>ArrayType New&lt;PrimitiveType&gt;Array(jsize length);</code></li>
<li>通过JNI数组获取一个C/C++数组：<code>&lt;type&gt;* Get&lt;type&gt;ArrayElements(jshortArray array, jboolean *isCopy)</code></li>
<li>指定原数组的范围获取一个C/C++数组（该方法只针对于原始数据数组，不包括Object数组）：<code>void Get&lt;PrimitiveType&gt;ArrayRegion(JNIEnv *env, ArrayType array, jsize start, jsize len, NativeType *buf);</code></li>
<li>设置数组元素：<code>void Set&lt;type&gt;ArrayRegion(jshortArray array, jsize start, jsize len,const &lt;type&gt; *buf)</code>。again，如果是Object数组需要使用：<code>void SetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index, jobject value);</code></li>
<li> 使用完之后，释放数组：<code>void Release&lt;type&gt;ArrayElements(jshortArray array, jshort *elems, jint mode)</code></li>
</ol>


<p>有点要说明的：<br/>
 1. 上面的3中的isCopy：当你调用getArrayElements时JVM（Runtime）可以直接返回数组的原始指针，或者是copy一份，返回给你，这是由JVM决定的。所以isCopy就是用来记录这个的。他的值是<code>JNI_TURE</code>或者<code>JNI_FALSE</code>。<br/>
 2. 6释放数组。<strong>一定要释放你所获得数组</strong>。其中有一个<code>mode</code>参数，其有三个可选值，分别表示：</p>

<pre><code> * 0
     - 原始数组：允许原数组被垃圾回收。  
     - copy： 数据会从get返回的buffer copy回去，同时buffer也会被释放。  
 * JNI_COMMIT  
    - 原始数组：什么也不做  
    - copy： 数据会从get返回的buffer copy回去，同时buffer**不会**被释放。  
 * JNI_ABORT  
     - 原始数组：允许原数组被垃圾回收。之前由JNI_COMMIT提交的对数组的修改将得以保留。  
     - copy： buffer会被释放，同时buffer中的修改将不会copy回数组！  
</code></pre>

<h4>关于引用与垃圾回收</h4>

<p>比如上面有个方法传了一个jobject进来，然后我把她保存下来，方便以后使用。这样做是<strong>不行哒</strong>！因为他是一个LocalReference，所以不能保证jobject指向的真正的实例不被回收。也就是说有可能你用的时候那个指针已经是个野指针的。然后你的程序就直接Segment Fault了，呵呵。。。</p>

<p>在JNI中提供了三种类型的引用：</p>

<ol>
<li>Local Reference：即本地引用。在JNI层的函数，所有非全局引用对象都是Local Reference， 它包括函数调用是传入的jobject和JNI成函数创建的jobject。Local Reference的特点是一旦JNI层的函数返回，这些jobject就可能被垃圾回收。</li>
<li>Glocal Reference：全局引用，这些对象不会主动释放，永远不会被垃圾回收。</li>
<li>Weak Glocal Reference：弱全局引用，一种特殊的Global Reference，在运行过程中有可能被垃圾回收。所以使用之前需要使用<code>jboolean IsSameObject(jobject obj1, jobject obj2)</code>判断它是否已被回收。</li>
</ol>


<p>Glocal Reference:<br/>
 1. 创建：<code>jobject NewGlobalRef(jobject lobj);</code><br/>
 2. 释放：<code>void DeleteGlobalRef(jobject gref);</code></p>

<p>Local Reference:<br/>
LocalReference也有一个释放的函数：<code>void DeleteLocalRef(jobject obj)</code>，他会立即释放Local Reference。
这个方法可能略显多余，其实也是有它的用处的。刚才说Local Reference会再函数返回后释放掉，但是假如函数返回前就有很多引用占了很多内存，最好函数内就尽早释放不必要的内存。</p>

<h4>关于<a name="jni_onload">JNI_OnLoad</a></h4>

<p>开头提到JNI_OnLoad是java1.2中新增加的方法，对应的还有一个JNI_OnUnload，分别是动态库被JVM加载、卸载的时候调用的函数。有点类似于WIndows里的DllMain。<br/>
前面提到的实现对应native的方法是实现javah生成的头文件中定义的方法，这样有几个弊端：</p>

<ol>
<li>函数名太长。很长。。相当长。。。</li>
<li>函数会被导出，也就谁说可以在动态库的导出函数表里面找到这些函数。这将有利于别人对动态库的逆向工程，因此带来安全问题。</li>
</ol>


<p>现在有了JNI_OnLoad，情况好多了。你不光能在其中完成动态注册native函数的工作还可以完成一些初始化工作。java对应的有了<code>jint RegisterNatives(jclass clazz, const JNINativeMethod *methods,jint nMethods)</code>函数。参数分别是：<br/>
 1. jclass clazz，于native层对应的java class<br/>
 2. const JNINativeMethod *methods这是一个数组，数组的元素是JNI定义的一个结构体JNINativeMethod <br/>
 3. 上面的数组的长度<br/>
<strong>JNINativeMethod</strong>：代码中的定义如下：</p>

<p>```java</p>

<p>/<em>
 * used in RegisterNatives to describe native method name, signature,
 * and function pointer.
 </em>/</p>

<p>typedef struct {</p>

<pre><code>char *name;
char *signature;
void *fnPtr;
</code></pre>

<p>} JNINativeMethod;
```
所以他有三个字段，分别是</p>

<table>
<thead>
<tr>
<th></th>
<th align="left"> 字段 </th>
<th align="left"> 含义 </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="left">char *name </td>
<td align="left"> java class中的native方法名，只需要方法名即可 |</td>
</tr>
<tr>
<td></td>
<td align="left"> char *signature </td>
<td align="left"> 方法<a href="#signature">签名</a>|</td>
</tr>
<tr>
<td></td>
<td align="left"> void *fnPtr </td>
<td align="left"> 对应native方法的函数指针 |</td>
</tr>
</tbody>
</table>


<p>于是现在你可以不用导出native函数了，而且可以随意给函数命名，唯一要保证的是参数及返回值的统一。然后需要一个<code>const JNINativeMethod *methods</code>数组来完成映射工作。</p>

<p>看起来大概是这样的:</p>

<p>```cpp
//只需导出JNI_OnLoad和JNI_OnUnload（这个函数不实现也行）
/<em><em>
 * These are the exported function in this library.
</em>/
JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM </em>vm, void <em>reserved);
JNIEXPORT void JNICALL JNI_OnUnload(JavaVM </em>vm, void *reserved);</p>

<p>//为了在动态库中不用导出函数，全部声明为static
//native methods registered by JNI_OnLoad
static jint native_newInstance (JNIEnv *env, jclass);</p>

<p>//实现native方法
/<em>
* Class:     com_tencent_soundtouch_SoundTouch
* Method:    native_newInstance
* Signature: ()I
</em>/
static jint native_newInstance
(JNIEnv *env, jclass ) {</p>

<pre><code>int instanceID = ++sInstanceIdentifer;
SoundTouchWrapper *instance = new SoundTouchWrapper();
if (instance != NULL) {
    sInstancePool[instanceID] = instance;
    ++sInstanceCount;
}
LOGDBG("create new SouncTouch instance:%d", instanceID);
return instanceID;
</code></pre>

<p>}</p>

<p>//构造JNINativeMethod数组
static JNINativeMethod gsNativeMethods[] = {</p>

<pre><code>    {
        "native_newInstance",
        "()I",
        reinterpret_cast&lt;void *&gt; (native_newInstance)
    }
</code></pre>

<p>}；
//计算数组大小
static const int gsMethodCount = sizeof(gsNativeMethods) / sizeof(JNINativeMethod)；</p>

<p>//JNI_OnLoad，注册native方法。
JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM <em>vm, void </em>reserved) {</p>

<pre><code>JNIEnv* env;
jclass clazz;
LOGD("JNI_OnLoad called");
if (vm-&gt;GetEnv(reinterpret_cast&lt;void**&gt;(&amp;env), JNI_VERSION_1_6) != JNI_OK) {
    return -1;
}
//FULL_CLASS_NAME是个宏定义，定义了对应java类的全名（要把包名中的点(.)_替换成斜杠(/)）
clazz = env-&gt;FindClass(FULL_CLASS_NAME);
LOGDBG("register method, method count:%d", gsMethodCount);
//注册JNI函数
env-&gt;RegisterNatives(clazz, gsNativeMethods,
    gsMethodCount);
//必须返回一个JNI_VERSION_1_1以上（不含）的版本号，否则直接加载失败
return JNI_VERSION_1_6;
</code></pre>

<p>}
```</p>

<h3>实战技巧篇</h3>

<p>这里主要是巧用C中的宏来减少重复工作：</p>

<h4>迅速生成全名</h4>

<p>```cpp
//修改包名时只需要改以下的宏定义即可</p>

<h1>define FULL_CLASS_NAME &ldquo;com/tencent/soundtouch/SoundTouch&rdquo;</h1>

<h1>define func(name) Java<em> ## com_tencent_soundtouch_SoundTouch</em> ## name</h1>

<h1>define constance(cons) com_tencent_soundtouch_SoundTouch_ ## cons</h1>

<p><code>``
比如</code>func(native_1newInstance)<code>展开成：</code>Java_com_tencent_soundtouch_SoundTouch_native_1newInstance`即JNI中需要导出的函数名（不过用动态注册方式没太大用了）</p>

<p><code>constance(AUDIO_FORMAT_PCM16)</code>展开成<code>com_tencent_soundtouch_SoundTouch_AUDIO_FORMAT_PCM16</code>这个着实有用。</p>

<p>而且如果包名改了也可以很方便的适应之。</p>

<h3>安卓的log</h3>

<p>```cpp
//define <strong>USE_ANDROID_LOG</strong> in makefile to enable android log</p>

<h1>if defined(<strong>ANDROID</strong>) &amp;&amp; defined(<strong>USE_ANDROID_LOG</strong>)</h1>

<h1>include &lt;android/log.h></h1>

<h1>define LOGV(&hellip;)   <strong>android_log_print((int)ANDROID_LOG_VERBOSE, &ldquo;ST_jni&rdquo;, </strong>VA_ARGS__)</h1>

<h1>define LOGD(msg)  <strong>android_log_print((int)ANDROID_LOG_DEBUG, &ldquo;ST_jni_dbg&rdquo;, &ldquo;line:%3d %s&rdquo;, </strong>LINE__, msg)</h1>

<h1>define LOGDBG(fmt, &hellip;) <strong>android_log_print((int)ANDROID_LOG_DEBUG, &ldquo;ST_jni_dbg&rdquo;, &ldquo;line:%3d &rdquo; fmt, </strong>LINE<strong>, </strong>VA_ARGS__)</h1>

<h1>else</h1>

<h1>define LOGV(&hellip;)</h1>

<h1>define LOGD(fmt)</h1>

<h1>define LOGDBG(fmt, &hellip;)</h1>

<h1>endif</h1>

<p>```
通过这样的宏定义在打LOGD或者LOGDBG的时候还能自动加上行号！调试起来爽多了！</p>

<h4>C++中清理内存的方式</h4>

<p>由于C++里面需要手动清楚内存，因此我的解决方案是定义一个map，给每个实例一个id，用id把java中的对象和native中的对象绑定起来。在java层定义一个<code>release</code>方法，用来释放本地的对象。
本地的 KEY-对象 映射
<code>static std::map&lt;int, SoundTouchWrapper*&gt; sInstancePool;</code></p>

<h4>关于NDK</h4>

<p>因为安卓的约定是把本地代码放到jni目录下面，但是假如有多个jni lib的时候会比较混乱，所以方案是每一个lib都在jni里面建一个子目录，然后jni里面的Android.mk就可以去构建子目录中的lib了。</p>

<p>jni/Android.mk如下（超级简单）：
<code>makefile
LOCAL_PATH := $(call my-dir)
include $(call all-subdir-makefiles)
</code></p>

<p>然后在子目录soundtouch_module中的Android.mk就可以像一般的Android.mk一样书写规则了。</p>

<p>同时记录一下在Andoroid.mk中使用makefile内建函数<code>wildcard</code>的方法。
有时候源文件是一个目录下的所有.cpp/.c文件，这时候<code>wildcard</code>来统配会很方便。但是Android.mk与普通的Makefile的不同在于：</p>

<ol>
<li>调用Android.mkmingling的${CWD}并不是Android.ml所在的目录。所以Android.mk中有一个变量<code>LOCAL_PATH := $(call my-dir)</code>来记录当前 Android.mk所在的目录。</li>
<li>同时还会把所有的<code>LOCAL_SRC_FILES</code> 前面加上<code>$(LOCAL_PATH)</code>这样写makefile的时候就可以用相对路径了，提供了方便。但是这也导致了坑！</li>
</ol>


<p>因为1，直接使用相对路径会导致<code>wildcard</code>匹配不到源文件。所以最好这么写<code>FILE_LIST := $(wildcard $(LOCAL_PATH)/soundtouch_source/source/SoundTouch/*.cpp)</code>。然而又因为2，这样还是不行的。所以还需要匹配之后把<code>$(LOCAL_PATH)</code>的部分去掉，因此还得这样<code>$(FILE_LIST:$(LOCAL_PATH)/%=%)</code>.</p>

<p>还有个小tip：<code>LOCAL_CFLAGS</code>中最好加上这个定义<code>-fvisibility=hidden</code>这样就不会在动态库中导出不必要的函数了。</p>

<h3>附录<a name="signature">签名</a></h3>

<p>JAVA中的函数签名包括了函数的参数类型，返回值类型。因此即使是重载了的函数，其函数签名也不一样。java编译器就会根据函数签名来判断你调用的到地址哪个方法。
签名中表示类型是这样的</p>

<p>1.基本类型都对应一个大写字母，如下：</p>

<table>
<thead>
<tr>
<th></th>
<th align="center"> JAVA类型 </th>
<th align="center">  类型签名 </th>
</tr>
</thead>
<tbody>
<tr>
<td> </td>
<td align="center"> boolean </td>
<td align="center"> Z |</td>
</tr>
<tr>
<td> </td>
<td align="center">byte </td>
<td align="center"> B | </td>
</tr>
<tr>
<td> </td>
<td align="center"> char  </td>
<td align="center"> C |</td>
</tr>
<tr>
<td> </td>
<td align="center"> short </td>
<td align="center"> S |</td>
</tr>
<tr>
<td> </td>
<td align="center"> int </td>
<td align="center"> I |</td>
</tr>
<tr>
<td> </td>
<td align="center"> long </td>
<td align="center"> J | </td>
</tr>
<tr>
<td> </td>
<td align="center"> float </td>
<td align="center"> F | </td>
</tr>
<tr>
<td> </td>
<td align="center"> double </td>
<td align="center"> D |</td>
</tr>
<tr>
<td> </td>
<td align="center"> void </td>
<td align="center"> V |</td>
</tr>
</tbody>
</table>


<p>2.如果是类则是：
L + 类全名（报名中的点(.)用(/)代替）+ ；
比如java.lang.String 对应的是 <code>Ljava/lang/String;</code></p>

<p>3.如果是数组，则在前面加<code>[</code>然后加类型签名，几位数组就加几个<code>[</code>
比如int[]对应<code>[I</code>，boolean[][] 对应 <code>[[Z</code>，java.lang.Class[]对应<code>[Ljava/lang/Class;</code></p>

<p>可以通过javap命令来获取签名（javah生成的头文件注释中也有签名）:<code>javap -x -p &lt;类全名&gt;</code>
坑爹的是java中并不能通过反射来获取方法签名，需要自己写一个帮助类。
（其实我还写了个小程序可以自动生成签名，和JNI_OnLoad中注册要用到的<code>JNINativeMethod</code>数组，从此再也不用糟心的去写那该死的数组了。LOL~~~）</p>

<p>[全文完]</p>

<h4>参考资料</h4>

<p>[1] : <a href="http://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html">Oracle java SE documents</a>
[2] : <a href="http://baike.baidu.com/view/6415820.htm">深入理解Android 卷 1</a> 第二章 ，邓凡平著，机械工业出版社
[3]: <a href="http://developer.android.com/training/articles/perf-jni.html">Google Android documents &mdash; JNI Tips</a></p>
]]></content>
  </entry>
  
</feed>
