<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Java | Young_Blog]]></title>
  <link href="http://LanderlYoung.github.io/tags/java/atom.xml" rel="self"/>
  <link href="http://LanderlYoung.github.io/"/>
  <updated>2014-08-10T14:21:31+08:00</updated>
  <id>http://LanderlYoung.github.io/</id>
  <author>
    <name><![CDATA[LanderlYoung]]></name>
    <email><![CDATA[landerlyoung@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[一次对非静态内部类引用final变量的研究]]></title>
    <link href="http://LanderlYoung.github.io/blog/2014/08/10/yi-ci-dui-fei-jing-tai-nei-bu-lei-yin-yong-finalbian-liang-de-yan-jiu/"/>
    <updated>2014-08-10T13:57:38+08:00</updated>
    <id>http://LanderlYoung.github.io/blog/2014/08/10/yi-ci-dui-fei-jing-tai-nei-bu-lei-yin-yong-finalbian-liang-de-yan-jiu</id>
    <content type="html"><![CDATA[<p>前几天遇到一个奇怪的问题，问题的起因是我把以前的RingfriendDialogBuilder（以下简称builder，没有IDE的自动补全打完全名还是很长的。。）修改了一下，添加了一个clear()方法。目的是避免每次创建一个Dialog都new一个builder的实例，这样一个builder可以用于创建多个dialog，以提高效率。接下来的问题就是因为这个修改导致的。</p>

<!--more-->


<h2>描述现象</h2>

<p>这个DialogBuilder允许构建Dialog，set其中的标题，监听器之类的变量。然后clear掉所有设置，重新再重新构建一个Dialog。问题出现在构建的多个（> 1）Dialog之后，当某个Dialog显示出来时，点击其按钮时，会出现NullPointerException。</p>

<h2>定位Bug：</h2>

<p>起初我觉得这很奇怪，因为每一个Dialog明明都设置了回调函数的呀。然后看到create方法其中一个setOnClickListener的代码段。
因为Dialong中的内容是普通的View，而Dialog的Listener与View的Listener不同，因此代码中做了如下adapt：</p>

<p><a name="anonymousClass"></a>
```java
if (mNegativeButtonLinstener != null) {</p>

<pre><code>negBtn.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
    mNegativeButtonLinstener.onClick(mDialog, DialogInterface.BUTTON_NEGATIVE);
    }
});
</code></pre>

<p>}
```
因为dialog的onclick需要传入dialog自身的引用，所以就很 「随意」的把builder的mDialog成员传了过来，这个mDialog是在create的时候new出来的新的Dialog：</p>

<p><code>java
//定义
private Dialog mDialog;
//创建
mDialog = new Dialog(mContext, mTheme);
</code>
此时我突然明白了，因为内部匿名类的onClick回调函数使用了外部类（《java编程思想》中称作 enclosing object that made it）的成员变量 mDialog，所以每次onClick，内部类都会resolve外部类的这个成员变量。然而这是不应该发生的，因为：</p>

<blockquote><p><strong>当一个dialog被create之后，builder还有可能再创建一个dialog，或者builder的clear方法可能被调用，其会恢复所有成员变量至默认值，包括设置mDialog为null。所以当某个dialog的按钮被按下时，外部类的mDialog成员可能已经被修改，而不再对应这个dialog。</strong></p></blockquote>

<h2>解决方案</h2>

<p>解决的思路很简单，就是在onClick的<a href="#anonymousClass">内部类</a>中把dialog「定死」，不因成员变量mDialog的变化为转移！这时突然想起来匿名类引用局部变量是必须给局部变量加final修饰符的问题，于是就有了以下解决方案：</p>

<p>在create中声明一个变量
<code>java
final Dialog d = mDialog;
</code>
然后下面需要传入mDialog的地方全部使用d代替。于是问题就顺利的解决了！</p>

<h2>思考</h2>

<p>对于上面解决方案为什么生效，首先说一下<strong>匿名类引用局部变量为什么必须声明final，为什么引用外部类的成员变量又不需要是final</strong>。</p>

<p>首先：
 1. static修饰的内部类和外部类是不能相互引用的，即内部类不能直接引用外部类的任何非static成员变量。因为static内部类不依赖于外部类就可以创建比如<code>new AlertDialog.Builder</code>是可以成功执行的。
 2. 然内非static的内部类是不能这样new出来的，比如：</p>

<p>```java
public class Outer {</p>

<pre><code>public A() {
}
public class Inner {
    public Inner() {
    }
}
</code></pre>

<p>}
```
Inner想要被new出来必须这样做：</p>

<p>```java
Outer outer  = new Outer();
Outer.Inner inner = outer.new Inner();</p>

<p>/<em>
 * can not pass compile, the compiler would complain
 </em>/
 //Outer.Inner inner = new Outer.Inner();
<code>
那么为什么非静态内部类就可以使用外部类的成员变量了呢，那是因为**内部类会保存一个外部类的引用**。可以通过如下方式在内部类中获取该引用。
</code>java
//in inner class
Outer.this
```
怎么样！是不是好熟悉，是不是觉得我用过！没错，就是他！</p>

<p>问题逐渐明朗了，需要说明一件事：<strong>anonymous class肯定全都是非static内部类</strong>。</p>

<p>那么匿名类就可以访问外部类的成员变量，这一点和常识想通。但是匿名类一般是在方法体内被创建的，当匿名类想引用方法体内的变量或者方法的参数时该变量必须声明final才行。这是为什么呢？！</p>

<p>这个说来话长，因为方法的参数，乃至方法内的局部变量都是临时性的，他们储存在栈（stack）中。当方法return的时候他们便不复存在。所以匿名类不可能通过外部类的引用来获取局部变量。
而final修饰的变量是不能修改的，因此内部类并不「引用」这个变量，而是在内部直接copy一下！反正她是不会变的，我copy一下也不会导致不一致的问题。（这里需要说明一个事实，copy一个实例的引用时，并不会copy这个实例，只是copy了「指针」而已！）</p>

<p>所以，结论是：</p>

<blockquote><p><strong>final的作用就是告诉编译器，这个变量不会修改的，内部类想用的话可以自己copy一份过去</strong></p></blockquote>

<p>对于上述的解决方案，因为我们使用了一个final变量代替成员变量，因此内部类会直接使用该final变量的copy，而不像原来那样每次都去resolve外部类的成员，这就保证了这个变量在内部类是「定死」的！</p>

<h2>优化升级</h2>

<p>该才说到，非静态内部类会保留一个外部类的引用。在builder这个实例中，dialog的onclick Listener是builder的内部类，因此该listener会保留Builder的引用。但是builder只是辅助构建Dialog用的，当dialog构造出来之后不应该在和builder保有引用。否则会导致builder不能被垃圾回收掉！
因此做一个修改，把dialog的onclick listener改成静态类，如下：</p>

<p>```java
 if (mPositiveButtonLinstener != null) {</p>

<pre><code>        final DialogInterface.OnClickListener listener = mPositiveButtonLinstener;
        posBtn.setOnClickListener(new DialogButtonOnClickListener(dialog,
                DialogInterface.BUTTON_POSITIVE,
                listener));
    }
</code></pre>

<p><code>
其中`DialogButtonOnClickListener`定义如下：
</code>java
private static class DialogButtonOnClickListener implements View.OnClickListener {</p>

<pre><code>    private Dialog mDialog;
    private int mWhich;
    private DialogInterface.OnClickListener mListener;

    public DialogButtonOnClickListener(
            Dialog dialog,
            int whichButton,
            DialogInterface.OnClickListener l) {

        mDialog = dialog;
        mWhich = whichButton;
        mListener = l;
    }

    @Override
    public void onClick(View v) {
        if (mListener != null &amp;&amp; mDialog != null) {
            mListener.onClick(mDialog, mWhich);

        }

    }
}
</code></pre>

<p>```</p>

<h3>[完]</h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[stepByStepAndroid-第一课]]></title>
    <link href="http://LanderlYoung.github.io/blog/2014/05/13/stepbystepandroid-di-%5B%3F%5D-ke/"/>
    <updated>2014-05-13T12:04:19+08:00</updated>
    <id>http://LanderlYoung.github.io/blog/2014/05/13/stepbystepandroid-di-[?]-ke</id>
    <content type="html"><![CDATA[<p>&lt;资源></p>

<ul>
<li>git项目<a href="https://github.com/LanderlYoung/stepByStepAndroid">github</a></li>
<li>详见<a href="https://github.com/LanderlYoung/stepByStepAndroid/releases">release note</a></li>
<li><a href="https://github.com/LanderlYoung/stepByStepAndroid/wiki">项目wiki</a></li>
</ul>


<p>&lt;/资源></p>

<p>梳理一下第一课学到的内容:</p>

<ol>
<li>创建简单的用户界面

<ul>
<li>简单的布局控制</li>
</ul>
</li>
<li>启动另一个Activity

<ul>
<li>给button添加回调函数</li>
<li>使用Intent</li>
</ul>
</li>
</ol>


<!--more-->


<h3>创建用户界面</h3>

<p>修改原来的fragment_main.xml文件，使用LinearLayout：
``` xml
&lt;LinearLayout xmlns:android=&ldquo;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&rdquo;</p>

<pre><code>xmlns:tools="http://schemas.android.com/tools"
android:layout_width="match_parent"
android:layout_height="match_parent"
android:orientation="horizontal" &gt;
</code></pre>

<p></LinearLayout>
<code>
上面的android:orientation属性把LinearLayout设置成水平线性布局，所有元素水平排列。
然后在LinearLayout中添加控件EditText和Button
</code> xml</p>

<pre><code>&lt;EditText 
    android:id="@+id/edit_message"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:hint="@string/edit_message" /&gt;
</code></pre>

<p>  &lt;Button</p>

<pre><code>    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="@string/button_send" /&gt;
</code></pre>

<p>```
然后在相应的strings.xml中添加string值。
效果如图：</p>

<p><img src="https://cloud.githubusercontent.com/assets/5700847/2953445/c8028f00-da59-11e3-9800-89a5c859064b.png" width="360" alt="device-2014-05-12-231827" /></p>

<p>接着控制一下布局：让EditText占据LinearLayout横向的剩余空间。只需要调整两个方面<code>android:layout_weight="1"</code>和<code>android:layout_width="0dp"</code>，其中layout_weight=1可以让它占据剩下的空间，layout_width=0改善性能。
看一下效果：</p>

<p><img src="https://cloud.githubusercontent.com/assets/5700847/2953442/b9d4597c-da59-11e3-886d-08d3f8e667a9.png" width="360" alt="device-2014-05-12-235041" /></p>

<h2>为button添加click事件处理</h2>

<p>在Button中添加一行<code>android:onClick="sendMessage"</code>这样就指定了button的click事件由<code>public void onClick(View view)</code>这样方法签名的方法来处理。
所以对应的去MainActicity.java中添加该函数：
``` java
//call back of the button
public void sendMessage(View view) {</p>

<pre><code>Intent intent = new Intent(getApplication(),DisplayMessageActivity.class);
EditText editText = (EditText)findViewById(R.id.edit_message);
String message = editText.getText().toString();
intent.putExtra(EXTRA_MESSAGE,message);
startActivity(intent);
</code></pre>

<p>}
```
上面的DisplayMessageActivity类是使用向导创建的新Activity。</p>

<h3>创建新Activity</h3>

<p>使用向导创建新的Activity，然后需要在AndroidManifest.xml里注册Activity</p>

<p>``` xml
   &lt;application</p>

<pre><code>   ......
    &lt;activity
        android:name="com.young.stepbystepandroid.DisplayMessageActivity"
        android:label="@string/title_activity_display_message"
        android:parentActivityName="com.young.stepbystepandroid.MainActivity" &gt;
        &lt;meta-data
            android:name="android.support.PARENT_ACTIVITY"
            android:value="com.young.stepbystepandroid.MainActivity" /&gt;
    &lt;/activity&gt;
&lt;/application&gt;
</code></pre>

<p>```</p>

<h3>使用Intent</h3>

<p><em>启动Intent</em>
``` java</p>

<pre><code>Intent intent = new Intent(getApplication(),DisplayMessageActivity.class);
EditText editText = (EditText)findViewById(R.id.edit_message);
String message = editText.getText().toString();
intent.putExtra(EXTRA_MESSAGE,message);
startActivity(intent);
</code></pre>

<p><code>
其中`public static final String EXTRA_MESSAGE = "com.young.stepByStepAndroid.MESSAGE";`
这个是一个显示Intent构造函数第一个参数是Context，可以使用this，因为Activity继承Context；但是推荐使用ApplicationContext防止内存泄漏。
*接收Intent*
</code> java</p>

<pre><code>Intent intent = getIntent();
String message = intent.getStringExtra(
        MainActivity.EXTRA_MESSAGE);

TextView textView = new TextView(this);
textView.setTextSize(40);
textView.setText(message);
</code></pre>

<p>```
代码很明显，不多说什么了。当然在Intent里面附加信息推荐使用<a href="http://developer.android.com/reference/android/os/Bundle.html">Bundle</a>。</p>

<p>看看成果：</p>

<p><img src="https://cloud.githubusercontent.com/assets/5700847/2953446/d6257c5a-da59-11e3-8e67-80bbecb4640f.png" width="360" alt="device-2014-05-13-002646" /></p>

<p><img src="https://cloud.githubusercontent.com/assets/5700847/2953447/d71cdef0-da59-11e3-9d39-e3e5d4de150d.png" width="360" alt="device-2014-05-13-002651" /></p>
]]></content>
  </entry>
  
</feed>
